/*
 * Copyright 2004-2010 Sun Microsystems, Inc. All Rights Reserved.
 * Copyright 2011 Oracle Corporation. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 *
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 * Please contact Oracle Corporation, 500 Oracle Parkway, Redwood
 * Shores, CA 94065 or visit www.oracle.com if you need additional
 * information or have any questions.
 */

/**
 * Check that slot clearing is being done correctly.
 *
 * One small compromise occurs with this option because the this_getfield
 * and this_putfield bytecodes are really loadparm0_getfield and loadparm0_putfield
 * bytecodes, and are used for both virtual methods and static methods.
 * In the case where they are used in a virtual method the translator knows
 * not to clear all the initialized reference slots because a null pointer
 * exeception cannot occur (see com.sun.squawk.translator.ir.GetField#mayCauseGC()).
 * In the case of a static the null pointer check must be made and so any
 * uninitialized slots will be cleared. Because it is not easy to know if the
 * currently executing method is static or virtual a conservative approach is
 * taken where the this_getfield and this_putfield bytecodes never performs
 * a slot clearing check.
 */
/*if[CHECK_SLOT_CLEARING]*/
#define CHECK_SLOT_CLEARING true
/*else[CHECK_SLOT_CLEARING]*/
//#define CHECK_SLOT_CLEARING false
/*end[CHECK_SLOT_CLEARING]*/

#ifndef SILLYADDBUG
#define NOSILLYADDBUG 1
#else
#define NOSILLYADDBUG 0
#endif

/*if[MACROIZE]*/
#define   nextbytecode() continue
/*else[MACROIZE]*/
//#define nextbytecode() return
//INLINE int     getArrayLength(Address oop);
//INLINE Address getMP();
//INLINE void    checkReferenceSlots();
/*end[MACROIZE]*/

static int             MethodHeader_minfoValue1_L(Address);
static int             MethodHeader_minfoValue2_L(Address);
static int             MethodHeader_minfoValue3_L(Address);
static int             MethodHeader_getOffsetToLastMinfoByte0_LII(Address oop, int p, int b0);

static int             VM_lookup_b(int, Address);
static int             VM_lookup_i(int, Address);
static int             VM_lookup_s(int, Address);
static int             VM_arrayOopStoreCheck(Address, int, Address);
static int             VM_findSlot(Address, Address, int);
static boolean         VM_instanceof(Address, Address);
static Address         Isolate_getClassStateForInterpreter_L(Address, Address);

        /*-----------------------------------------------------------------------*\
         *                      Class state cache managemant                     *
         *                                                                       *
         *   Even when compiling the class state lookup code into C, this cache  *
         *   adds about 10% performance for static variable accesses in common   *
         *   case.                                                               *
        \*-----------------------------------------------------------------------*/

#ifdef INTERPRETER_STATS
#define updateCachedClassAccesses() cachedClassAccesses++
#define updateCachedClassHits() cachedClassHits++
#else
#define updateCachedClassAccesses()
#define updateCachedClassHits()
#endif /* INTERPRETER_STATS */

        /**
         * Add a cached class state association.
         *
         * @param klass the klass
         * @param state the klass state

         * @return its class state or null if not found
         */
/*MAC*/ void addClassState(Address $klass, Address $state) {
            int i;
            for (i = CLASS_CACHE_SIZE-1 ; i > 0  ; --i) {
                cachedClass[i]      = cachedClass[i-1];
                cachedClassState[i] = cachedClassState[i-1];
            }
            cachedClass[0]      = $klass;
            cachedClassState[0] = $state;
        }

        /**
         * Get a cached class state.
         *
         * @param klass the klass
         * @return its class state or null if not found
         */
        Address getClassState(Address klass) {
            int i;
            updateCachedClassAccesses();
            for (i = 0 ; i < CLASS_CACHE_SIZE ; i++) {
                if (cachedClass[i] == klass) {
                    updateCachedClassHits();
                    return cachedClassState[i];
                }
            }
            return null;
        }

        INLINE Address VM_getClassStateREAL(Address klass) {
            Address cs = getClassState(klass);
            if (cs != null) {
                return cs;
            }
            return Isolate_getClassStateForInterpreter_L(com_sun_squawk_VM_currentIsolate, klass);
        }

        /**
         * Test to see if a class needs initializing.
         *
         * @param klass the klass
         * @return true if it does.
         */
/*MAC*/ boolean needsInitializing(Address $klass) {
            if (com_sun_squawk_Klass_modifiers($klass) & com_sun_squawk_Modifier_KLASS_MUSTCLINIT) {
                return VM_getClassStateREAL($klass) == null;
            }
            return false;
        }

        /**
         * Invalidate the class state cache.
         *
         * @return true if it was already invalid.
         */
/*MAC*/ boolean invalidateClassStateCache() {
            int i;
            UWord res = 0;
            for (i = 0 ; i < CLASS_CACHE_SIZE ; i++) {
                res |= (UWord)cachedClass[i];
                cachedClass[i] = null;
            }
            return res == 0;
        }

        /*-----------------------------------------------------------------------*\
         *                           Instruction decoding                        *
        \*-----------------------------------------------------------------------*/

        /**
         * Fetch a byte from ip.
         *
         * @return the value
         */
/*DEF*/ signed char fetchByte() {
            return getByteTyped(ip++, 0, AddressType_BYTECODE);
        }

        /**
         * Fetch an unsigned byte from from ip.
         *
         * @return the value
         */
/*DEF*/ unsigned char fetchUByte() {
            return getUByteTyped(ip++, 0, AddressType_BYTECODE);
        }

        /**
         * Fetch a short from ip and place in fparm.
         */
/*DEF*/ void fetchShort() {
            if (PLATFORM_UNALIGNED_LOADS) {
                fparm = getShortTyped(ip, 0, AddressType_BYTECODE);
                ip += sizeof(short);
            } else {
                if (PLATFORM_BIG_ENDIAN) {
                    int b1 = fetchByte();
                    int b2 = fetchUByte();
                    fparm = (b1 << 8) | b2;
                } else {
                    int b1 = fetchUByte();
                    int b2 = fetchByte();
                    fparm = (b2 << 8) | b1;
                }
            }
        }

        /**
         * Fetch an unsigned short from ip and place in fparm.
         */
/*DEF*/ void fetchUShort() {
            if (PLATFORM_UNALIGNED_LOADS) {
                fparm = getUShortTyped(ip, 0, AddressType_BYTECODE);
                ip += sizeof(unsigned short);
            } else {
                int b1 = fetchUByte();
                int b2 = fetchUByte();
                if (PLATFORM_BIG_ENDIAN) {
                    fparm = (b1 << 8) | b2;
                } else {
                    fparm = (b2 << 8) | b1;
                }
            }
        }

        /**
         * Fetch an int from ip and place in fparm.
         */
/*DEF*/ void fetchInt() {
            if (PLATFORM_UNALIGNED_LOADS) {
                fparm = getIntTyped(ip, 0, AddressType_BYTECODE);
                ip += sizeof(int);
            } else {
                int b1 = fetchUByte();
                int b2 = fetchUByte();
                int b3 = fetchUByte();
                int b4 = fetchUByte();
                if (PLATFORM_BIG_ENDIAN) {
                    fparm = (b1 << 24) | (b2 << 16) | (b3 << 8) | b4;
                } else {
                    fparm = (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;
                }
            }
        }

        /**
         * Fetch a long from ip and place in flparm.
         *
         * @return the value
         */
/*DEF*/ void fetchLong() {
            if (PLATFORM_UNALIGNED_64_LOADS) {
                flparm = getLongTyped(ip, 0, AddressType_BYTECODE);
                ip += sizeof(jlong);
            } else {
                flparm = getUnalignedLong(ip, 0);
                ip += sizeof(jlong);
            }
        }


    /*-----------------------------------------------------------------------*\
     *                          Operand stack                                *
    \*-----------------------------------------------------------------------*/

#if ASSUME
        /**
         * Asserts that the stack pointer is within the current stack and decrementing it
         * won't overflow the stack limit.
         */
/*MAC*/ void checkPush() {
/*if[REVERSE_PARAMETERS]*/
            /* if (loeq(sp, sl)) fprintf(stderr, format("sp=%A, sl=%A, ss=%A\n"), sp, sl, ss); */
            assume(sp > sl);
            assume(getUWord(ss, SC_guard) == 0);
            if (ss == com_sun_squawk_VMThread_serviceStack) {
                assume(loeq(sp, Address_add(com_sun_squawk_VMThread_serviceStack, SERVICE_CHUNK_SIZE)));
            } else {
                assume(loeq(sp, &ss[getArrayLength(ss)]));
            }
/*else[REVERSE_PARAMETERS]*/
/*end[REVERSE_PARAMETERS]*/
        }
#else
#define checkPush()
#endif /* ASSUME */

        /**
         * Pushes an int value onto the runtime stack.
         */
/*MAC*/ void pushInt(int $value) {
/*if[REVERSE_PARAMETERS]*/
            checkPush();
            setUWordTyped(--sp, 0, AddressType_INT, (UWord)$value);
/*else[REVERSE_PARAMETERS]*/
//          setUWordTyped(sp++, 0, AddressType_INT, (UWord)$value);
//          checkPush();
/*end[REVERSE_PARAMETERS]*/
        }

        /**
         * Pops an int value from the runtime stack.
         */
/*MAC*/ int popInt() {
/*if[REVERSE_PARAMETERS]*/
            return (int)getUWordTyped(sp++, 0, AddressType_INT);
/*else[REVERSE_PARAMETERS]*/
//          return (int)getUWordTyped(--sp, 0, AddressType_INT);
/*end[REVERSE_PARAMETERS]*/
        }

        /**
         * Pushes an address onto the runtime stack -- always downwards.
         */
/*MAC*/ void downPushAddress(Address $value) {
            checkPush();
            setObject(--sp, 0, $value);
        }

        /**
         * Pushes an address onto the runtime stack.
         */
/*MAC*/ void pushAddress(Address $value) {
/*if[REVERSE_PARAMETERS]*/
            checkPush();
            setObject(--sp, 0, $value);
/*else[REVERSE_PARAMETERS]*/
//          setObject(sp++, 0, $value);
//          checkPush();
/*end[REVERSE_PARAMETERS]*/
        }

        /**
         * Pops an address from the runtime stack.
         */
/*MAC*/ Address popAddress() {
/*if[REVERSE_PARAMETERS]*/
            return getObject(sp++, 0);
/*else[REVERSE_PARAMETERS]*/
//          return getObject(--sp, 0);
/*end[REVERSE_PARAMETERS]*/
        }

        /**
         * Peeks the value on the top of the runtime stack.
         */
/*MAC*/ UWord peek() {
            return getUWordTyped(sp, 0, AddressType_ANY);
        }

        /**
         * Pushes a jlong value onto the runtime stack.
         */
#if SQUAWK_64
/*MAC*/ void pushLong(jlong $value) {
/*if[REVERSE_PARAMETERS]*/
            checkPush();
            setLong(--sp, 0, $value);
            assumeInterp($value == getLong(sp, 0));
/*else[REVERSE_PARAMETERS]*/
//          setLong(sp++, 0, $value);
//          checkPush();
//          assumeInterp($value == getLong(sp, -1));
/*end[REVERSE_PARAMETERS]*/
        }
#else
/*MAC*/ void pushLong(jlong $value) {
/*if[REVERSE_PARAMETERS]*/
            checkPush();
            --sp;
            setLongAtWord(--sp, 0, $value);
            assumeInterp($value == getLongAtWord(sp, 0));
/*else[REVERSE_PARAMETERS]*/
//          setLongAtWord(sp++, 0, $value);
//          sp++;
//          checkPush();
//          assumeInterp($value == getLongAtWord(sp, -2));
/*end[REVERSE_PARAMETERS]*/
        }
#endif

        /**
         * Pops a jlong value from the runtime stack.
         */
#if SQUAWK_64
/*MAC*/ jlong popLong() {
/*if[REVERSE_PARAMETERS]*/
            return getLong(sp++, 0);
/*else[REVERSE_PARAMETERS]*/
//          return getLong(--sp, 0);
/*end[REVERSE_PARAMETERS]*/
        }
#else
/*MAC*/ jlong popLong() {
/*if[REVERSE_PARAMETERS]*/
            return getLongAtWord(sp = sp + 2, -2);
/*else[REVERSE_PARAMETERS]*/
//          return getLongAtWord(sp = sp - 2, 0);
/*end[REVERSE_PARAMETERS]*/
        }
#endif

        /**
         * Pops a UWord from the runtime stack.
         */
/*MAC*/ UWord popWord() {
/*if[REVERSE_PARAMETERS]*/
            return getUWord(sp++, 0);
/*else[REVERSE_PARAMETERS]*/
//          return getUWord(--sp, 0);
/*end[REVERSE_PARAMETERS]*/
        }

        /**
         * Pushes a UWord to the runtime stack.
         */
/*MAC*/ void pushWord(UWord $value) {
/*if[REVERSE_PARAMETERS]*/
            checkPush();
            setUWord(--sp, 0, $value);
/*else[REVERSE_PARAMETERS]*/
//          setUWord(sp++, 0, $value);
//          checkPush();
/*end[REVERSE_PARAMETERS]*/
        }

#if TYPEMAP
        /**
         * Pushes a UWord onto the runtime stack, recording the type of the value pushed.
         */
/*MAC*/ void pushAsType(UWord $value, char $type) {
/*if[REVERSE_PARAMETERS]*/
            checkPush();
            setUWordTyped(--sp, 0, $type, $value);
/*else[REVERSE_PARAMETERS]*/
//          setUWordTyped(sp++, 0, $type, $value);
//          checkPush();
/*end[REVERSE_PARAMETERS]*/
        }

        /**
         * Pops a UWord from the runtime stack, checking that its type matches a given type.
         */
/*MAC*/ UWord popAsType(char $type) {
/*if[REVERSE_PARAMETERS]*/
            return getUWordTyped(sp++, 0, $type);
/*else[REVERSE_PARAMETERS]*/
//          return getUWordTyped(--sp, 0, $type);
/*end[REVERSE_PARAMETERS]*/
        }
#else
#define pushAsType(value, type) pushWord(value)
#define popAsType(type) popWord()
#endif /* TYPEMAP */

        /*-----------------------------------------------------------------------*\
         *                          Bytecode dispatching                         *
        \*-----------------------------------------------------------------------*/

        /**
         * Prefix for bytecode with no parameter.
         */
/*DEF*/ void iparmNone() {
        }

        /**
         * Prefix for bytecode with a byte parameter.
         */
/*DEF*/ void iparmByte() {
            iparm = fetchByte();
        }

        /**
         * Prefix for bytecode with an unsigned byte parameter.
         */
/*DEF*/ void iparmUByte() {
            iparm = fetchUByte();
        }

        /**
         * Add 256 to the next unsigned byte and jump to that bytecode execution.
         */
/*DEF*/ void do_escape() {
            opcode = fetchUByte() + 256;
            goto next;
        }

        /**
         * Or the (parameter<<8) into the value of the next bytecode and then
         * dispatch to the wide version of the opcode.
         */
/*DEF*/ void do_wide_n(int $n) {
            opcode = fetchUByte() + OPC_Properties_WIDE_DELTA;
            iparm  = fetchUByte() | ($n<<8);
            goto next;
        }

        /**
         * Load the inlined short as the value of the next bytecode and then
         * dispatch to the wide version of the opcode.
         */
/*DEF*/ void do_wide_short() {
            int fparm;
            opcode = fetchUByte() + OPC_Properties_WIDE_DELTA;
            fetchShort();
            iparm = fparm;
            goto next;
        }

        /**
         * Load the inlined int as the value of the next bytecode and then
         * dispatch to the wide version of the opcode.
         */
/*DEF*/ void do_wide_int() {
            int fparm;
            opcode = fetchUByte() + OPC_Properties_WIDE_DELTA;
            fetchInt();
            iparm = fparm;
            goto next;
        }

        /**
         * Or the (parameter<<8) in to the value of the next bytecode and then
         * dispatch to the wide version of the opcode.
         */
/*DEF*/ void do_escape_wide_n(int $n) {
            opcode = fetchUByte() + 256 + OPC_Properties_ESCAPE_WIDE_DELTA;
            iparm  = fetchUByte() | ($n<<8);
            goto next;
        }

        /**
         * Load the inlined short as the value of the next bytecode and then
         * dispatch to the wide version of the opcode.
         */
/*DEF*/ void do_escape_wide_short() {
            int fparm;
            opcode = fetchUByte() + 256 + OPC_Properties_ESCAPE_WIDE_DELTA;
            fetchShort();
            iparm = fparm;
            goto next;
        }

        /**
         * Load the inlined int as the value of the next bytecode and then
         * dispatch to the wide version of the opcode.
         */
/*DEF*/ void do_escape_wide_int() {
            int fparm;
            opcode = fetchUByte() + 256 + OPC_Properties_ESCAPE_WIDE_DELTA;
            fetchInt();
            iparm = fparm;
            goto next;
        }


        /*-----------------------------------------------------------------------*\
         *                             Access to data                            *
        \*-----------------------------------------------------------------------*/

        /**
         * Gets a local variable ignoring the typemap.
         *
         * @param n int index to the local variable
         * @return the value
         */
/*MAC*/ UWord peekLocal(int $n) {
            return getUWordTyped(fp, FP_local0 - $n, AddressType_ANY);
        }

        /**
         * Gets a local variable.
         *
         * @param n int index to the local variable
         * @return the value
         */
/*MAC*/ UWord getLocal(int $n) {
            return getUWordTyped(fp, FP_local0 - $n, getMutationType());
        }

        /**
         * Sets a local variable.
         *
         * @param n int index to the local variable
         * @param value the value to set
         */
/*MAC*/ void setLocal(int $n, UWord $value) {
            setUWordTyped(fp, FP_local0 - $n, getMutationType(), $value);
        }

        /**
         * Gets a local jlong variable.
         *
         * @param n int index to the local variable
         * @return the value
         */
/*MAC*/ jlong getLocalLong(int $n) {
            return getLongAtWord(fp, FP_local0 - $n);
        }

        /**
         * Sets a local variable.
         *
         * @param n int index to the local variable
         * @param value the value to set
         */
/*MAC*/ void setLocalLong(int $n, jlong $value) {
            setLongAtWord(fp, FP_local0 - $n, $value);
        }

        /**
         * Gets a parameter word.
         *
         * @param n int index to the local variable
         * @return the value
         */
/*MAC*/ UWord getParmTyped(int $n, char $type) {
            return getUWordTyped(fp, FP_parm0 + $n, $type);
        }

        /**
         * Gets a parameter word.
         *
         * @param n int index to the local variable
         * @return the value
         */
/*MAC*/ UWord getParm(int $n) {
            return getParmTyped($n, getMutationType());
        }

        /**
         * Sets a parameter word.
         *
         * @param n int index to the local variable
         * @param value the value to set
         */
/*MAC*/ void setParm(int $n, UWord $value) {
            setUWordTyped(fp, FP_parm0 + $n, getMutationType(), $value);
        }

        /**
         * Gets a jlong parameter word.
         *
         * @param n int index to the local variable
         * @return the value
         */
/*MAC*/ jlong getParmLong(int $n) {
            return getLongAtWord(fp, FP_parm0 + $n);

        }

        /**
         * Sets a jlong parameter word.
         *
         * @param n int index to the local variable
         * @param value the value to set
         */
/*MAC*/ void setParmLong(int $n, jlong $value) {
            setLongAtWord(fp, FP_parm0 + $n, $value);
        }

#if ASSUME
/*DEF*/ void boundsAssume(Address $oop, int $index) {
            assume($oop);
            /* use the unsigned bounds check trick: */
            assume((unsigned int) $index < (unsigned int)getArrayLength($oop));
        }
#else
/*DEF*/ void boundsAssume(Address $oop, int $index) {
        }
#endif /* ASSUME */


/*DEF*/ void boundsAssumeAlways(Address $oop, int $index) {
            assumeAlways($oop);
            /* use the unsigned bounds check trick: */
            assumeAlways((unsigned int) $index < (unsigned int)getArrayLength($oop));
        }

        /*-----------------------------------------------------------------------*\
         *                             Utility code                              *
        \*-----------------------------------------------------------------------*/

        /**
         * Gets the current method pointer.
         */
/*MAC*/ Address getMP() {
            return getObject(fp, FP_method);
        }

        /**
         * Gets the current class pointer.
         */
/*MAC*/ Address getCP() {
            return getObject(getMP(), HDR_methodDefiningClass);
        }

        /**
         * Gets the object specified by an index from the class of the currently executing method.
         *
         * @param  index the index of the object
         * @return the object
         */
/*MAC*/ Address getKlassObject(int $index) {
            return ((Address *)com_sun_squawk_Klass_objects(getCP()))[$index];
        }

        /**
         * Gets the length of an array object.
         *
         * @param  oop the pointer to the array.
         * @return the length
         */
/*MAC*/ int getArrayLength(Address $oop) {
            assume((int)(getUWord($oop, HDR_length) >> 2) >= 0);
            return (int)(getUWord($oop, HDR_length) >> 2);
        }

        /**
         * Gets the static method specified by an index from the class.
         *
         * @param  index the index of the method
         * @return the method
         */
/*MAC*/ Address getStaticMethod(Address $cls, int $index) {
            Address stable;
            assume($cls);
            stable = com_sun_squawk_Klass_staticMethods($cls);
            assume(stable);
	        assume((unsigned int)$index < (unsigned int)getArrayLength(stable));
            return ((Address *)stable)[$index];
        }

        /**
         * Gets the virtual method specified by an index from the class.
         *
         * @param index the index of the method
         * @return the method
         */
/*MAC*/ Address getVirtualMethod(Address $cls, int $index) {
            Address vtable;
            assume($cls);
            vtable = com_sun_squawk_Klass_virtualMethods($cls);
	        assume((unsigned int)$index < (unsigned int)getArrayLength(vtable));
            return ((Address *)vtable)[$index];
        }

        /**
         * Sets the length of an array object.
         *
         * @param oop the pointer to the array
         * @param size the length
         * @return false if length was too large
         */
/*MAC*/ boolean setArrayLength(Address $oop, int $size) {
		    assume($size >= 0);
            if ($size > 0x3FFFFFF) {
                return false;
            }
            setUWord($oop, HDR_length, ($size << HDR_headerTagBits) | HDR_arrayHeaderTag);
            return true;
        }

        /**
         * Gets the Klass or the ObjectAssociation of an object.
         *
         * @param  oop the pointer to the object.
         * @return the Klass ot the ObjectAssociation
         */
#if ASSUME
/*MAC*/ Address getClassOrAssociation(Address $oop) {
            /* Catches an attempt to dereference a forwarding pointer */
            assume(com_sun_squawk_GC_collecting || ((UWord)getObject($oop, HDR_klass) & HDR_headerTagMask) == 0);
            return getObject($oop, HDR_klass);
        }
#else
/*MAC*/ Address getClassOrAssociation(Address $oop) {
            return getObject($oop, HDR_klass);
        }
#endif
         /**
         * Given a klass or an association, deerefence the self field
         * to return the actual Klass.
         *
         * @param the Klass or the ObjectAssociation
         * @return the Klass, or the klass refered to by the association
         */
/*MAC*/ Address associationToKlass(Address $oop) {
            return com_sun_squawk_Klass_self($oop);
        }

        /**
         * Gets the class of an object.
         *
         * @param  oop the pointer to the object.
         * @return the class
         */
/*MAC*/ Address getClass(Address $oop) {
            return com_sun_squawk_Klass_self(getClassOrAssociation($oop));
        }

        /*
         * Decodes a counter from the minfo area.
         *
         * The routines are translated from Java to C, and are definedin in vm2c.c.spp
         */

        /**
         * Gets the b0 byte of the method header.
         *
         * @param mp the method pointer
         * @return the value
         */
/*MAC*/ int getb0(Address $mp) {
            return getUByte($mp, HDR_methodInfoStart);
        }

        /**
         * Gets the b1 byte of the method header.
         *
         * @param mp the method pointer
         * @return the value
         */
/*MAC*/ int getb1(Address $mp) {
            return getUByte($mp, HDR_methodInfoStart - 1);
        }

        /**
         * Decode the stack count.
         *
         * @param b0 the first byte
         * @param b1 the second byte
         * @return the value
         */
/*MAC*/ int decodeStackCount(int $b0, int $b1) {
            return $b1 & 0x1F;
        }

        /**
         * Decode the stack count.
         *
         * @param b0 the first byte
         * @param b1 the second byte
         * @return the value
         */
/*MAC*/ int decodeLocalCount(int $b0, int $b1) {
            return ((($b0 << 8) | $b1) >> 5) & 0x1F;
        }

        /**
         * Decode the Parm count.
         *
         * @param b0 the first byte
         * @return the value
         */
/*MAC*/ int decodeParmCount(int $b0) {
            return $b0 >> 2;
        }

        /**
         * Gets the number of stack words used by a method.
         *
         * @param mp the method pointer
         * @return the count
         */
/*MAC*/ int getStackCount(Address $mp) {
            int b0 = getb0($mp);
            if (b0 < 128) {
                int b1 = getb1($mp);
                return decodeStackCount(b0, b1);
            } else {
                return MethodHeader_minfoValue1_L($mp);
            }
        }

        /**
         * Gets the number of local words used by a method.
         *
         * @param mp the method pointer
         * @return the count
         */
/*MAC*/ int getLocalCount(Address $mp) {
            int b0 = getb0($mp);
            if (b0 < 128) {
                int b1 = getb1($mp);
                return decodeLocalCount(b0, b1);
            } else {
                return MethodHeader_minfoValue2_L($mp);
            }
        }

        /**
         * Gets the number of parameter words used by a method.
         *
         * @param mp the method pointer
         * @return the count
         */
/*MAC*/ int getParmCount(Address $mp) {
            int b0 = getb0($mp);
            if (b0 < 128) {
                return decodeParmCount(b0);
            } else {
                return MethodHeader_minfoValue3_L($mp);
            }
        }

        /**
         * Get the offset to the last byte of the Minfo area.
         *
         * @param np the pointer to the method
         * @return the length in bytes
         */
/*MAC*/ int getOffsetToLastMinfoByte(Address $mp) {
            int p = HDR_methodInfoStart;
            int b0 = getUByte($mp, p--);
            if (b0 < 128) {
                return p;
            } else {
                return MethodHeader_getOffsetToLastMinfoByte0_LII($mp, p, b0);
            }
        }

#ifdef _MSC_VER
#pragma auto_inline(off)
#endif

        /**
         * Gets the number of local words plus stack words used by a method.
         *
         * @param mp the method pointer
         * @return the count
         */
        int getLocalCountPlusStackCountIfNotReversingParms(Address mp) {
            int res = getLocalCount(mp);
/*if[REVERSE_PARAMETERS]*/
/*else[REVERSE_PARAMETERS]*/
//          res += getStackCount(mp);
/*end[REVERSE_PARAMETERS]*/
            return res;
        }

#ifdef _MSC_VER
#pragma auto_inline(on)
#endif

        /**
         * Clears the operand stack given the number of locals in the current method.
         *
         * @param delta the number of words to adjust by
         */
/*MAC*/ void resetStackPointerFromDelta(int $delta) {
            sp = fp - $delta + 1; /* + 1 so sp points one word before first stack word */
        }

        /**
         * Clears the operand stack.
         */
/*MAC*/ void resetStackPointer() {
            Address mp = getMP();
            int delta;
            int b0 = getb0(mp);
            if (b0 < 128) {
                int b1 = getb1(mp);
/*if[REVERSE_PARAMETERS]*/
                delta = decodeLocalCount(b0, b1);
/*else[REVERSE_PARAMETERS]*/
//              delta = decodeLocalCount(b0, b1) + decodeStackCount(b0, b1);
/*end[REVERSE_PARAMETERS]*/
            } else {
                delta = getLocalCountPlusStackCountIfNotReversingParms(mp);
            }
            resetStackPointerFromDelta(delta);
        }

        /**
         * Clears the operand stack when REVERSE_PARAMETERS is true.
         */
/*MAC*/ void resetStackPointerIfRevParms() {
/*if[REVERSE_PARAMETERS]*/
            resetStackPointer();
/*end[REVERSE_PARAMETERS]*/
        }

        /**
         * Clears the operand stack when REVERSE_PARAMETERS is false.
         */
/*MAC*/ void resetStackPointerIfNotRevParms() {
/*if[REVERSE_PARAMETERS]*/
/*else[REVERSE_PARAMETERS]*/
//          resetStackPointer();
/*end[REVERSE_PARAMETERS]*/
        }


        /*-----------------------------------------------------------------------*\
         *                      Java String printing                             *
        \*-----------------------------------------------------------------------*/

/**
 * A macro defining whether or not the printJavaString function should
 * handle Strings with non-ascii characters.
 */
//#define UNICODE true

        /**
         * Prints the contents of a Java String object to a given stream.
         * No trailing '\0' is printed/appended.
         *
         * @param str  the address of a Java String object
         * @param out  where to print the string's contents
         * @return the number of characters printed
         */
        int printJavaString(Address str, FILE* out) {
            int i;
            int written = 0;
            if (str == null) {
                written = fprintf(out, "null");
            } else {
                int length = getArrayLength(str);
#ifdef UNICODE
                Address cls = getClass(str);
				assume(((UWord)getObject(str, HDR_klass) & HDR_headerTagMask) == 0);
                if (com_sun_squawk_Klass_id(cls) == com_sun_squawk_StringOfBytes) {
#endif
                    unsigned char *chars = (unsigned char *)str;
                    fprintf(out, "%.*s", length, chars);
                    written = length;
#ifdef UNICODE
                } else {
                    unsigned short *chars = (unsigned short *)str;
                    if (com_sun_squawk_Klass_id(cls) != com_sun_squawk_String) {
                        fatalVMError("com_sun_squawk_VM_printString was not passed a string");
                    }
                    for (i = 0; i < length; i++) {
                        fprintf(out, "%lc", chars[i]);
                    }
                    written = length;
                }
#endif
            }
            fflush(out);
            return written;
        }

        /**
         * Appends the contents of a Java String object
         * to a given buffer. No trailing '\0' is printed/appended.
         *
         * @param str  the address of a Java String object
         * @param buf  where to append the string's contents
         * @param bufLength the length of 'buf'
         * @return the number of characters appended
         */
        int printJavaStringBuf(Address str, char *buf, int bufLength) {
            int i;
            int written = 0;
            if (str == null) {
                int min = 4;
                if (min > bufLength) {
                    min = bufLength;
                }
                memmove(buf, "null", min);
                written = min;
            } else {
                int length = getArrayLength(str);
#ifdef UNICODE
                Address cls = getClass(str);
				assume(((UWord)getObject(str, HDR_klass) & HDR_headerTagMask) == 0);
                if (com_sun_squawk_Klass_id(cls) == com_sun_squawk_StringOfBytes) {
#endif
                    unsigned char *chars = (unsigned char *)str;
                    int min = length;
                    if (min > bufLength) {
                        min = bufLength;
                    }
                    memmove(buf, chars, min);
                    written = min;
#ifdef UNICODE
                } else {
                    unsigned short *chars = (unsigned short *)str;
                    if (com_sun_squawk_Klass_id(cls) != com_sun_squawk_String) {
                        fatalVMError("com_sun_squawk_VM_printString was not passed a string");
                    }
                    for (i = 0; i < length && i < bufLength; i++) {
                        buf[i] = (char)chars[i];
                    }
                    written = i;
                }
#endif
            }
            return written;
        }


        /*-----------------------------------------------------------------------*\
         *                                Upcalls                                *
        \*-----------------------------------------------------------------------*/

        /**
         * Causes the Java method at 'mth' to be invoked without resetting the stack pointer.
         *
         * @param mth the address of the method to be invoked
         */
/*MAC*/ void callNoReset(Address $mth) {
            assumeInterp($mth != 0);
			assumeInterp(((UWord)getObject($mth, HDR_klass) & HDR_headerTagMask) == 0);
            assumeInterp(com_sun_squawk_Klass_id(getClass($mth)) == CID_BYTECODE_ARRAY);
            assumeInterp(inCode($mth));
            checkReferenceSlots();
            downPushAddress(ip);
            ip = $mth;
        }

        /**
         * Causes the Java method at 'mth' to be invoked, resetting the stack pointer first if necessary.
         *
         * @param mth the address of the method to be invoked
         */
/*MAC*/ void call(Address $mth) {
            resetStackPointerIfNotRevParms();
            callNoReset($mth);
        }

       /*
        * Call exception reporting method - and leave stack as if thrower called.
        * This call returns by rethrowing the original exception. VM.throwException notices the re-throw,
        * clears these magic flags, and sets up SC_lastFP (etc) to the catch block (see below).
        *
        * Using code fragment macro becuase of interaction of #ifdef and MACRO processing
        */
#if SDA_DEBUGGER
#define SDA_HANDLE_BREAKPOINT_CODE_FRAG                                                                      \
                if (!runningOnServiceThread &&                                                               \
                    (hbp = com_sun_squawk_VMThread_hitBreakpoint(newThread)) != null &&                      \
                    com_sun_squawk_HitBreakpoint_state(hbp) == com_sun_squawk_HitBreakpoint_EXC_HIT) {       \
                    set_com_sun_squawk_HitBreakpoint_state(hbp, com_sun_squawk_HitBreakpoint_EXC_REPORTING); \
                    /* fprintf(stderr, format("Calling do_reportException. newMP: %A, ipOffset: %O, ip: %A, fp: %A.\n", newMP, ipOffset, ip, fp); */ \
                    call(com_sun_squawk_VM_reportException);                                                 \
                } else {                                                                                     \
                    /*fprintf(stderr, format("fp = %d newMP = %d ipoffset = %d ip=%d tid=%d returnFP=%A\n"), fp, newMP, ipOffset, ip, com_sun_squawk_VMThread_threadNumber(newThread), getObject(fp, FP_returnFP));*/ \
                }
#else
#define SDA_HANDLE_BREAKPOINT_CODE_FRAG FALSE
#endif /*SDA_DEBUGGER */

        /**
         * Switch to the 'other' thread.
         */
/*MAC*/ void threadswitchmain() {
            Address oldThread  = com_sun_squawk_VMThread_currentThread;
            Address oldStack   = (Address)com_sun_squawk_VMThread_stack(oldThread);
            UWord   oldMP      = (UWord)getObject(fp, FP_method);
            UWord   ipOffset   = ((UWord)ip) - oldMP;
            Address newThread  = com_sun_squawk_VMThread_otherThread;
            Address newStack   = (Address)com_sun_squawk_VMThread_stack(newThread);
            assumeInterp(newStack != null);
            assumeInterp(!com_sun_squawk_GC_collecting);

            /*fprintf(stderr, format("%%%%%%%%%%%%%% fp = %A oldMP = %A ipoffset = %d ip=%A tid=%d oldThread=%A oldStack=%A newThread=%A newStack=%A\n"), fp, oldMP, ipOffset, ip, com_sun_squawk_VMThread_threadNumber(oldThread), oldThread, oldStack, newThread, newStack);*/

            /*
             * Save current VM state in the current thread.
             */
            if (oldStack == null) {
                /* handle case from VMThread.abandonThread(). oldThread has died, and will not come back.*/
                assumeInterp(com_sun_squawk_VMThread_state(oldThread) == com_sun_squawk_VMThread_DEAD);
            } else {
                assumeInterp(oldStack == (Address)ss);
                setObject(oldStack, SC_lastFP, fp);
                setUWord(oldStack, SC_lastBCI, ipOffset);
            }

            /*
             * Swap the threads and setup the current isolate.
             */
            com_sun_squawk_VMThread_otherThread = oldThread;
            com_sun_squawk_VMThread_currentThread = newThread;
            if (TRACE) {
                currentThreadID = com_sun_squawk_VMThread_threadNumber(newThread);
            }

            /*
             * If the new thread is not the service thread then switch the
             * the current isolate to the new thread's isolate. This test means
             * that code run on the service thread will run in the isolate
             * context of the caller.
             */
            if (newThread != com_sun_squawk_VMThread_serviceThread) {
                int oldRunningOnServiceThread = runningOnServiceThread;
                Address newIsolate = (Address)com_sun_squawk_VMThread_isolate(newThread);

                runningOnServiceThread = false;
                if (com_sun_squawk_VM_currentIsolate != newIsolate) {
                    com_sun_squawk_VM_currentIsolate = newIsolate;
                    invalidateClassStateCache();
                    set_sda_bp_set_or_stepping(newIsolate); /* changed isolate */
                } else if (oldRunningOnServiceThread) {
                    set_sda_bp_set_or_stepping(newIsolate); /* coming off of service thread */
                }

                /*
                 * If not simply switching back from the service thread to its caller
                 * then check that the number of pending monitor enter operations is zero.
                 */
                assumeInterp(oldThread == com_sun_squawk_VMThread_serviceThread || pendingMonitorStackPointer == 0);

            } else {
                runningOnServiceThread = true;
                set_sda_bp_set_or_stepping(null); /* coming on to service thread */
            }

            /*
             * Switch to the new context.
             */
            setStack(newStack);
            fp = getObject(ss, SC_lastFP);
            if (fp == null) {   /* New thread                   */
                fp = null;      /* The return FP should be zero */
                ip = null;      /* The return IP should be zero */
                sp = &ss[getArrayLength(ss)];
/*if[REVERSE_PARAMETERS]*/
                call(com_sun_squawk_VM_callRun);
/*else[REVERSE_PARAMETERS]*/
//              downPushAddress(ip);         /* don't call call() ... */
//              ip = com_sun_squawk_VM_callRun;   /* because resetStackPointer() will not work */
/*end[REVERSE_PARAMETERS]*/
                /*fprintf(stderr, "callRun: fp = %d sp=%d ip=%d tid = %d\n", fp, sp, ip, com_sun_squawk_VMThread_threadNumber(newThread));*/
            } else {
                Address hbp;

                assumeInterp(getMP() != null);
                ipOffset = getUWord(ss, SC_lastBCI);
                resetStackPointer();
                ip = (ByteAddress)getMP() + ipOffset;
                assumeInterp(inCode(ip));
                
                SDA_HANDLE_BREAKPOINT_CODE_FRAG;
            }
        }

        /**
         * Switch to the 'other' thread.
         *
         * @param code the service operation code
         */
/*MAC*/ void threadSwitch(int $code) {
            /*
             * Set the service operation code.
             */
            com_sun_squawk_ServiceOperation_code = $code;
/*if[MACROIZE]*/
            goto threadswitchstart;
/*else[MACROIZE]*/
//          threadswitchmain();
/*end[MACROIZE]*/
        }

        /**
         * Switch to the service thread.
         */
/*MAC*/ void threadSwitchFor(int $code) {
            assumeInterp(!runningOnServiceThread);
            com_sun_squawk_VMThread_otherThread = com_sun_squawk_VMThread_serviceThread;
            threadSwitch($code);
        }

        /**
         * Execute a service operation for channel I/O.
         */
/*MAC*/ void executeCIO(int $context, int $op, int $channel, int $i1, int $i2, int $i3, int $i4, int $i5, int $i6, Address $o1, Address $o2) {
            com_sun_squawk_ServiceOperation_context = $context;
            com_sun_squawk_ServiceOperation_op      = $op;
            com_sun_squawk_ServiceOperation_channel = $channel;
            com_sun_squawk_ServiceOperation_i1      = $i1;
            com_sun_squawk_ServiceOperation_i2      = $i2;
            com_sun_squawk_ServiceOperation_i3      = $i3;
            com_sun_squawk_ServiceOperation_i4      = $i4;
            com_sun_squawk_ServiceOperation_i5      = $i5;
            com_sun_squawk_ServiceOperation_i6      = $i6;
            com_sun_squawk_ServiceOperation_o1      = $o1;
            com_sun_squawk_ServiceOperation_o2      = $o2;
            if (runningOnServiceThread) {
                void cioExecute(void);
                cioExecute();
            } else {
                threadSwitchFor(com_sun_squawk_ServiceOperation_CHANNELIO);
            }
        }

        /*-----------------------------------------------------------------------*\
         *                               Debugging                               *
        \*-----------------------------------------------------------------------*/

#if SDA_DEBUGGER
#define SDA_DEBUG_PRINT false

/*MAC*/ Address frameOffsetAsPointer(Address $stack, Offset $fpOffset) {
            return Address_sub(Address_add($stack, getArrayLength($stack) * HDR_BYTES_PER_WORD), $fpOffset);
        }

/*MAC*/ Offset framePointerAsOffset(Address $stack, Address $fpPointer) {
            return Address_diff(Address_add($stack, getArrayLength($stack) * HDR_BYTES_PER_WORD), $fpPointer);
        }

/*MAC*/ void sda_checkStepPrim(ByteAddress $actual_ip, UWordAddress $actual_fp, UWordAddress $actual_sp) {
            Address thread = com_sun_squawk_VMThread_currentThread;
            Address step = com_sun_squawk_VMThread_step(thread);
            Offset currentFO = framePointerAsOffset(ss, $actual_fp);
            Address startFP = frameOffsetAsPointer(ss, com_sun_squawk_Debugger_SingleStep_startFO(step));
            int state = com_sun_squawk_Debugger_SingleStep_state(step);

            if (!inSystemFrame(startFP, (Address)$actual_fp)) {
                switch (state) {
                    case com_sun_squawk_Debugger_SingleStep_DEFERRED: {
                        /* A couple of optimizations for determining when we should go from DEFERRED to REQUESTED.
                         *
                         * 1) The last 'hit' was cancelled because it was in a class excluded by step request (via a ClassExclude modifier).
                         * Each successive hit will fail until the current frame changes.
                         *
                         * Once the current frame changes, the state is reset to REQUESTED.
                         *
                         * 2) If the class of the method where the step was cancelled is the same as the
                         * current method's class, break.
                         */

                        Offset reportedFO = com_sun_squawk_Debugger_SingleStep_reportedFO(step);
                        if (currentFO == reportedFO) {
                            /* Still in a method of an excluded class */
                            break;
                        } else if (currentFO < reportedFO) {
                            Address reportedFP = frameOffsetAsPointer(ss, reportedFO);
                            Address reportedMP = getObject(reportedFP, FP_method);
                            Address currentMP = getObject($actual_fp, FP_method);
							assumeInterp(((UWord)getObject(reportedMP, HDR_klass) & HDR_headerTagMask) == 0);
							assumeInterp(((UWord)getObject(currentMP, HDR_klass) & HDR_headerTagMask) == 0);
                            {
                                Address classOfReportedMP = getClass(reportedMP);
                                Address classOfCurrentMP = getClass(currentMP);

                                if (classOfReportedMP == classOfCurrentMP) {
                                    break;
                                }
                            }
                        }

                        set_com_sun_squawk_Debugger_SingleStep_state(step, com_sun_squawk_Debugger_SingleStep_REQUESTED);
                        set_com_sun_squawk_Debugger_SingleStep_reportedFO(step, (Offset) 0);
                        set_com_sun_squawk_Debugger_SingleStep_reportedBCI(step, (Offset) 0);
                        /* intentionally falls through to case com_sun_squawk_Debugger_SingleStep_REQUESTED */
                    }
                    case com_sun_squawk_Debugger_SingleStep_REQUESTED: {
                        Address mp = getObject($actual_fp, FP_method);
                        boolean stepped = sda_handleSingleStep($actual_ip, $actual_fp, $actual_sp, mp, step);
                        /* Report the step event */
                        if (stepped) {
                            Offset currentBCI = Address_diff($actual_ip, mp);
                            /*fprintf(stderr, format("Signaling STEP event hit @ currentFO: %A, currentBCI: %A\n"), currentFO, currentBCI);*/
                            /* We set the state here - otherwise the this method will check for step events when the handler is running */
                            set_com_sun_squawk_Debugger_SingleStep_state(step, com_sun_squawk_Debugger_SingleStep_HIT);
                            set_com_sun_squawk_Debugger_SingleStep_reportedFO(step, currentFO);
                            set_com_sun_squawk_Debugger_SingleStep_reportedBCI(step, currentBCI);

                            pushWord(currentFO);
                            pushWord(currentBCI);
                            callNoReset(com_sun_squawk_VM_reportStepEvent);
                        }
                        break;
                    }
                    default: {
                        fatalInterpreterError("sda_checkStep(): Should not reach here\n");
                    }
                }
           }
       }

        /**
         * Checks for stepping events.
         */
/*MAC*/ void sda_checkStep(ByteAddress $actual_ip, UWordAddress $actual_fp, UWordAddress $actual_sp) {
            Address thread = com_sun_squawk_VMThread_currentThread;
            Address step = com_sun_squawk_VMThread_step(thread);
            int state;

            /* We proceed if:
             *      1) step is not null and state is not STATE_HIT
             *      2) operand stack is empty
             *      3) opcode != EXTEND, EXTEND0, EXTEND_WIDE, CLASS_CLINIT, BBTARGET_APP, BBTARGET_SYS
             */
            if (step != null && (state = com_sun_squawk_Debugger_SingleStep_state(step)) != com_sun_squawk_Debugger_SingleStep_HIT &&
                sda_isOperandStackEmpty($actual_fp, $actual_sp))
            {
                int thisOpcode = getUByteTyped($actual_ip, 0, AddressType_BYTECODE);
                switch (thisOpcode) {
                    case OPC_EXTEND:
                    case OPC_EXTEND0:
                    case OPC_EXTEND_WIDE:
                    case OPC_CLASS_CLINIT:
                    case OPC_BBTARGET_APP:
                    case OPC_BBTARGET_SYS: break;
                    default:
                        sda_checkStepPrim($actual_ip, $actual_fp, $actual_sp);
                        break;
                }
            }
        }
/**
 * Handles the logic for determining if a step event has occurred when the frames are different.
 * We want to know if the startFO is still on the stack - this tells us that we are in a frame
 * that the startFO has called.
 *
 * If we are in STEP_OVER or STEP_OUT, we don't want this to cause an event, so we return false, otherwise we don't.
 * If we are in STEP_IN, the above test doesn't apply so we return true.
 */
boolean sda_handleSingleStepWhenFrameIsDifferent(UWordAddress actual_fp, Offset startFO, int depth) {
    boolean sendEvent = true;

    if (depth == com_sun_squawk_debugger_JDWP_StepDepth_OVER || depth == com_sun_squawk_debugger_JDWP_StepDepth_OUT) {
        UWordAddress prevFP = (UWordAddress)getObject(actual_fp, FP_returnFP);
        assume(prevFP > actual_fp);
        while (prevFP != null) {
            if (framePointerAsOffset(ss, prevFP) == startFO) {
#if SDA_DEBUG_PRINT
                fprintf(stderr, format("sda_handleSingleStep(): Found the frame where stepping was initiated\n"));
#endif
                sendEvent = false;
                break;
            }
            prevFP = (UWordAddress)getObject(prevFP, FP_returnFP);
        }
    }
    return sendEvent;
}

/**
 * Determines whether or not a requested step event has been completed and should be reported to
 * the attached debugger.
 */
boolean sda_handleSingleStep(ByteAddress actual_ip, UWordAddress actual_fp, UWordAddress actual_sp, Address mp, Address step) {
    Offset currentFO = framePointerAsOffset(ss, actual_fp);
    Offset startFO = com_sun_squawk_Debugger_SingleStep_startFO(step);
    int targetBCI = com_sun_squawk_Debugger_SingleStep_targetBCI(step);
    int size = com_sun_squawk_Debugger_SingleStep_size(step);
    int depth = com_sun_squawk_Debugger_SingleStep_depth(step);

    /* Squawk does -not- support com_sun_squawk_debugger_JDWP_StepSize_MIN */
    assume(size == com_sun_squawk_debugger_JDWP_StepSize_LINE);
    /* We're assuming that the current method pointer is not one invoked by the interpreter */
    assume(!isInterpreterInvoked(mp));

#if SDA_DEBUG_PRINT
    fprintf(stderr, format("sda_handleSingleStep(): targetBCI: %d, currentFO: %O, startFO: %O, size: %d, depth: %d\n"), targetBCI, currentFO, startFO, size, depth);
#endif

    if (targetBCI == -1) {
        /* Wait for the frame to change and that will mean we popped up to
         * the calling frame. (Or we called down to another frame, maybe...
         * should look into that possibility)
         */
        boolean sendEvent = false;
        if (currentFO != startFO) {
            sendEvent = sda_handleSingleStepWhenFrameIsDifferent(actual_fp, startFO, depth);
        }
#if SDA_DEBUG_PRINT
        if (sendEvent) {
            fprintf(stderr, format("sda_handleSingleStep(): targetBCI == -1 and step event occurred\n"));
        }
#endif
        return sendEvent;
    } else {
        Offset currentBCI = Address_diff(actual_ip, mp);
        if (currentFO == startFO) {
            Offset startBCI = com_sun_squawk_Debugger_SingleStep_startBCI(step);
            int dupBCI = com_sun_squawk_Debugger_SingleStep_dupBCI(step);
            int afterDupBCI = com_sun_squawk_Debugger_SingleStep_afterDupBCI(step);
#if SDA_DEBUG_PRINT
            dumpSteppingInfo(currentBCI, currentFO, step);
#endif
            /* if the frame is the same and we are not running to the
             * end of a function we need to see if we have reached
             * the location we are looking for
             */
            if (depth != com_sun_squawk_debugger_JDWP_StepDepth_OUT) {
                if (currentBCI == targetBCI) {
#if SDA_DEBUG_PRINT
                    fprintf(stderr, format("handleSingleStep() - CASE 1: we are at the target offset\n"));
#endif
                    /* At the target offset */
                    return true;
                } else if (currentBCI < startBCI && (dupBCI == -1 || afterDupBCI == -1)) {
#if SDA_DEBUG_PRINT
                    fprintf(stderr, format("handleSingleStep() - CASE 2: we are before the start offset \n"));
#endif
                    /* Reached an offset before the offset where stepping was initiated - there's also
                     * no duplicate information
                     */
                    return true;
                } else if (currentBCI > targetBCI && currentBCI > startBCI) {
                    /* Past the target offset and the offset where stepping was initiated */
                    if (dupBCI == -1 || afterDupBCI == -1) {
#if SDA_DEBUG_PRINT
                        fprintf(stderr, format("handleSingleStep() - CASE 3: we are after the target and start offsets and there is no duplicate offset\n"));
#endif
                        /* there's no duplicate information (like there would be in a for/while loop)
                         * Sometimes caused by a break in a switch/case.  We checked if the starting
                         * offset is equal to our current - if so don't issue an event otherwise we'll
                         * be in an infinite loop.
                         */
                        return true;
                    } else if (currentBCI >= dupBCI && currentBCI >= afterDupBCI) {
#if SDA_DEBUG_PRINT
                        fprintf(stderr, format("handleSingleStep() - CASE 4: we are after the target and start offsets and either at or past the duplicate offset\n"));
#endif
                        /* we are at or beyond the end of a for/while loop (doing the loop test). */
                        return true;
                    }
                }
            }
        } else {
            /* the frame has changed but we don't know whether we have gone into a function or gone up one.
             * if we look up the call stack and find the frame that originally set the request then we stepped
             * into a function, otherwise we stepped out
             */
            boolean sendEvent = sda_handleSingleStepWhenFrameIsDifferent(actual_fp, startFO, depth);

#if SDA_DEBUG_PRINT
            dumpSteppingInfo(currentBCI, currentFO, step);
            if (sendEvent) {
                fprintf(stderr, format("sda_handleSingleStep(): frame has changed, causing a step event\n"));
            }
#endif
            return sendEvent;
        }
    }
    return false;
}

        /**
         * Determines if the interpreter is at a breakpoint or end of a step and calls
         * into the appropriate Java routine if it is.
         */
/*MAC*/ void sda_checkBreakOrStep(ByteAddress $actual_ip, UWordAddress $actual_fp, UWordAddress $actual_sp) {
            if (unlikely(sda_bp_set_or_stepping)) {
                Address thread = com_sun_squawk_VMThread_currentThread;
                Address hbp = com_sun_squawk_VMThread_hitBreakpoint(thread);
                if (hbp == null) {
                    boolean atBreakpoint = false;
                    ByteAddress bp_ip;
                    if (sda_breakpoints[0] != NULL) {
                        int i = 0;
                        while ((bp_ip = sda_breakpoints[i++]) != null) {
                            if (bp_ip == $actual_ip) {
                                /*
                                 * Call breakpoint reporting method - and leave stack as if current method called.
                                 * com_sun_squawk_VM_reportBreakpoint().
                                 */
                                Address mp      = getObject($actual_fp, FP_method);
                                Offset currentBCI = Address_diff($actual_ip, mp);
                                Offset currentFO = framePointerAsOffset(ss, $actual_fp);
                                /*fprintf(stderr, format("Hit breakpoint #%d: in method: %A, currentBCI: %O ip: %A currentFO: %O fp: %A\n"),  i, mp, currentBCI, $actual_ip, currentFO, $actual_fp);*/

                                if (!sda_isOperandStackEmpty($actual_fp, $actual_sp)) {
                                    fatalInterpreterError("Tried to report a breakpoint when operand stack was not empty.\n");
                                }

                                pushWord(currentFO);
                                pushWord(currentBCI);
                                call(com_sun_squawk_VM_reportBreakpoint);
                                atBreakpoint = true;
                                break;
                            }
                        }
                    }
                    if (!atBreakpoint) {
                        sda_checkStep($actual_ip, $actual_fp, $actual_sp);
                    }
                } else if (com_sun_squawk_HitBreakpoint_state(hbp) == com_sun_squawk_HitBreakpoint_BP_REPORTED) {
                    /*
                     * In the middle of reporting the breakpoint. If the current frame and BCI
                     * is equal to the thread's saved frame and BCI, then we are done reporting the
                     * breakpoint, and we clean up reporting, and execute the next instruction normally.
                     */
                    if (framePointerAsOffset(ss, $actual_fp) == com_sun_squawk_HitBreakpoint_hitOrThrowFO(hbp)) {
                        Address mp      = getObject($actual_fp, FP_method);
                        Offset currentBCI = Address_diff($actual_ip, mp);
                        if (currentBCI == com_sun_squawk_HitBreakpoint_hitOrThrowBCI(hbp)) {
                            set_com_sun_squawk_VMThread_hitBreakpoint(thread, null);
                            /*fprintf(stderr, format("Done reporting breakpoint in method: %A, offset: %O\n"), mp, currentBCI);*/
                        }
                    }
                }
            }
        }
#endif /* SDA_DEBUGGER */

        /*-----------------------------------------------------------------------*\
         *                               Constants                               *
        \*-----------------------------------------------------------------------*/
        /**
         * Pushes a constant value.
         *
         * <p>
         * Java Stack: ... -> ..., INT
         * <p>
         *
         * @param n the integer value
         */
/*MAC*/ void do_const_n(Offset $n) {
            pushInt($n);
        }

        /**
         * Pushes a constant null value.
         *
         * <p>
         * Java Stack: ... -> ..., INT
         * <p>
         *
         * @param n the integer value
         */
/*MAC*/ void do_const_null() {
            pushAddress(0);
        }

        /**
         * Pushes a constant byte value.
         *
         * <p>
         * Java Stack: ... -> ..., INT
         * <p>
         */
/*MAC*/ void do_const_byte() {
            pushInt(fetchByte());
        }

        /**
         * Pushes a constant short value.
         *
         * <p>
         * Java Stack: ... -> ..., INT
         * <p>
         */
/*MAC*/ void do_const_short() {
            int fparm;
            fetchShort();
            pushInt(fparm);
        }

        /**
         * Pushes a constant char value.
         *
         * <p>
         * Java Stack: ... -> ..., INT
         * <p>
         */
/*MAC*/ void do_const_char() {
            int fparm;
            fetchUShort();
            pushInt(fparm);
        }

        /**
         * Pushes a constant int value.
         *
         * <p>
         * Java Stack: ... -> ..., INT
         * <p>
         */
/*MAC*/ void do_const_int() {
            int fparm;
            fetchInt();
            pushInt(fparm);
        }

        /**
         * Pushes a constant long value.
         *
         * <p>
         * Java Stack: ... -> ..., LONG
         * <p>
         */
/*MAC*/ void do_const_long() {
            jlong flparm;
            fetchLong();
            pushLong(flparm);
        }

        /**
         * Pushes a constant floa value.
         *
         * <p>
         * Java Stack: ... -> ..., FLOAT
         * <p>
         */
/*MAC*/ void do_const_float() {
            int fparm;
            fetchInt();
            pushInt(fparm);
        }

        /**
         * Pushes a constant double value.
         *
         * <p>
         * Java Stack: ... -> ..., DOUBLE
         * <p>
         */
/*MAC*/ void do_const_double() {
            jlong flparm;
            fetchLong();
            pushLong(flparm);
        }

        /**
         * Pushes a constant object value.
         *
         * <p>
         * Java Stack: ... -> ..., OOP
         * <p>
         *
         * @param n the index into the class object table
         */
/*MAC*/ void do_object_n(int $n) {
            pushAddress(getKlassObject($n));
        }

        /**
         * Pushes a constant object value.
         *
         * <p>
         * Java Stack: ... -> ..., OOP
         * <p>
         */
/*MAC*/ void do_object() {
            do_object_n(iparm);
        }


        /*-----------------------------------------------------------------------*\
         *                          Access to locals                             *
        \*-----------------------------------------------------------------------*/

        /**
         * Pushes a single word local.
         *
         * <p>
         * Java Stack: ... -> ..., VALUE
         * <p>
         *
         * @param n the index to local
         */
/*MAC*/ void do_load_n(int $n) {
            pushAsType(getLocal($n), getMutationType());
        }

        /**
         * Pushes a single word local.
         *
         * <p>
         * Java Stack: ... -> ..., VALUE
         * <p>
         */
/*MAC*/ void do_load() {
            do_load_n(iparm);
        }

        /**
         * Pops a single word local.
         *
         * <p>
         * Java Stack: ..., VALUE -> ...
         * <p>
         *
         * @param n the index to local
         */
/*MAC*/ void do_store_n(int $n) {
            setLocal($n, popAsType(getMutationType()));
        }

        /**
         * Pops a single word local.
         *
         * <p>
         * Java Stack: ..., VALUE -> ...
         * <p>
         */
/*MAC*/ void do_store() {
            do_store_n(iparm);
        }

        /**
         * Pushes a double word local.
         *
         * <p>
         * Java Stack: ... -> ..., LONG
         * <p>
         */
/*MAC*/ void do_load_i2() {
            if (TYPEMAP & SQUAWK_64) {
                if (getMutationType() == AddressType_REF) {
                    pushAsType(getLocal(iparm), AddressType_REF);
                } else if (getMutationType() == AddressType_UWORD) {
                    pushAsType(getLocal(iparm), AddressType_UWORD);
                } else {
                    pushLong(getLocalLong(iparm));
                }
            } else {
                pushLong(getLocalLong(iparm));
            }
        }

        /**
         * Pops a double word local.
         *
         * <p>
         * Java Stack: ..., LONG -> ...
         * <p>
         */
/*MAC*/ void do_store_i2() {
            if (TYPEMAP & SQUAWK_64) {
                if (getMutationType() == AddressType_REF) {
                    setLocal(iparm, popAsType(AddressType_REF));
                } else if (getMutationType() == AddressType_UWORD) {
                    setLocal(iparm, popAsType(AddressType_UWORD));
                } else {
                    setLocalLong(iparm, popLong());
                }
            } else {
                setLocalLong(iparm, popLong());
            }
        }

        /**
         * Increment a single word local.
         *
         * <p>
         * Java Stack: ... -> ...
         * <p>
         */
/*MAC*/ void do_inc() {
            setLocal(iparm, getLocal(iparm) + 1);
        }

        /**
         * Decrement a single word local.
         *
         * <p>
         * Java Stack: ... -> ...
         * <p>
         */
/*MAC*/ void do_dec() {
            setLocal(iparm, getLocal(iparm) - 1);
        }


        /*-----------------------------------------------------------------------*\
         *                         Access to parameters                          *
        \*-----------------------------------------------------------------------*/

        /**
         * Pushes a single word parm.
         *
         * <p>
         * Java Stack: ... -> ..., VALUE
         * <p>
         *
         * @param n the index to local
         */
/*MAC*/ void do_loadparm_n(int $n) {
            pushAsType(getParm($n), getMutationType());
        }

        /**
         * Pushes a single word parm.
         *
         * <p>
         * Java Stack: ... -> ..., VALUE
         * <p>
         */
/*MAC*/ void do_loadparm() {
            do_loadparm_n(iparm);
        }

        /**
         * Pops a single word parm.
         *
         * <p>
         * Java Stack: ..., VALUE -> ...
         * <p>
         */
/*MAC*/ void do_storeparm_n(int $n) {
            setParm($n, popAsType(getMutationType()));
        }

        /**
         * Pops a single word parm.
         *
         * <p>
         * Java Stack: ..., VALUE -> ...
         * <p>
         */
/*MAC*/ void do_storeparm() {
            do_storeparm_n(iparm);
        }

        /**
         * Pushes a double word parm.
         *
         * <p>
         * Java Stack: ... -> ..., LONG
         * <p>
         */
/*MAC*/ void do_loadparm_i2() {
            if (TYPEMAP & SQUAWK_64) {
                if (getMutationType() == AddressType_REF) {
                    pushAsType(getParm(iparm), AddressType_REF);
                } else if (getMutationType() == AddressType_UWORD) {
                    pushAsType(getParm(iparm), AddressType_UWORD);
                } else {
                    pushLong(getParmLong(iparm));
                }
            } else {
                pushLong(getParmLong(iparm));
            }
        }

        /**
         * Pops a double word parm.
         *
         * <p>
         * Java Stack: ..., VALUE -> ...
         * <p>
         *
         */
/*MAC*/ void do_storeparm_i2() {
            if (TYPEMAP & SQUAWK_64) {
                if (getMutationType() == AddressType_REF) {
                    setParm(iparm, popAsType(AddressType_REF));
                } else if (getMutationType() == AddressType_UWORD) {
                    setParm(iparm, popAsType(AddressType_UWORD));
                } else {
                    setParmLong(iparm, popLong());
                }
            } else {
                setParmLong(iparm, popLong());
            }
        }

        /**
         * Increment a single word parm.
         *
         * <p>
         * Java Stack: ... -> ...
         * <p>
         */
/*MAC*/ void do_incparm() {
            setParm(iparm, getParm(iparm) + 1);
        }

        /**
         * Decrement a single word parm.
         *
         * <p>
         * Java Stack: ... -> ...
         * <p>
         */
/*MAC*/ void do_decparm() {
            setParm(iparm, getParm(iparm) - 1);
        }


    /*-----------------------------------------------------------------------*\
     *                               Branching                               *
    \*-----------------------------------------------------------------------*/

        /**
         * Modifies the global 'tracing' flag if a user specified backward branch threshold
         * has been met. This function also stops the VM if another user specified
         * threshold has been met.
         */
/*INL*/ void bbtarget_trace() {
#if TRACE
            jlong count;
            int low = (int)((branchCountLow + 1) & 0xFFFFFFFF);
            branchCountLow = low;
            if (low == 0) {
                UWord high = branchCountHigh + 1;
                branchCountHigh = high;
            }
            count = getBranchCount();
            if (statsFrequency != 0 && (count % statsFrequency) == 0) {
                printCacheStats();
            }
            if (count >= getTraceStart()) {
                com_sun_squawk_VM_tracing = true;
            }
            if (count >= getTraceEnd()) {
                fprintf(stderr, format("\n** Reached branch count limit %L **\n"), getBranchCount());
                stopVM(-1);
            }
#endif
        }


        /**
         * Backward branch target in system code.
         *
         * <p>
         * Java Stack:  _  ->  _
         * <p>
         */
/*MAC*/ void do_bbtarget_sys() {
            osbackbranch();
            bbtarget_trace();
            checkReferenceSlots();
        }

        /**
         * Backward branch target in application code.
         *
         * <p>
         * Java Stack:  _  ->  _
         * <p>
         */
/*MAC*/ void do_bbtarget_app() {
            do_bbtarget_sys();
            if (unlikely(bc++ >= 0)) {
                bc = -TIMEQUANTA;
                call(com_sun_squawk_VM_yield);
            }
        }

#ifdef FLASH_MEMORY
        /**
         * Force back branch count to zero so that reschedule will occur.
         * NB. This function is forced into a special section so that it can be put in RAM.
         */
		__attribute__ ((section (".textinram"))) void force_bb_expired() {
            bc = 0;
        }
#endif

        /**
         * Unconditional branch.
         *
         * <p>
         * Java Stack: ... -> ...  (Forward branches);
         * <p>
         * Java Stack:  _  ->  _   (Backward branches);
         * <p>
         */
/*MAC*/ void do_goto() {
            ip += iparm;
        }

        /**
         * Gets the right hand operand for the comparison in an 'if...' instruction.
         *
         * @param zero  specifies if the right hand operand is 0 or is on the stack
         */
/*DEF*/ Address rhs_o(boolean $zero) { return $zero ? 0 : popAddress(); }
/*DEF*/ int     rhs_i(boolean $zero) { return $zero ? 0 : popInt();     }
/*DEF*/ jlong   rhs_l(boolean $zero) { return $zero ? 0 : popLong();    }

        /**
         * Conditional branch based on a comparison between object values.
         *
         * <p>
         * Java Stack: ..., LEFT_VALUE, [RIGHT_VALUE] -> ...  (Forward branches);
         * <p>
         * Java Stack:      LEFT_VALUE, [RIGHT_VALUE] ->  _   (Backward branches);
         * <p>
         *
         * @param zero  if true, then RIGHT_VALUE is given the value 0 (and thus not popped from the stack)
         */
/*MAC*/ void do_if_eq_o(boolean $zero) { Address rhs = rhs_o($zero); if (popAddress() == rhs) do_goto(); }
/*MAC*/ void do_if_ne_o(boolean $zero) { Address rhs = rhs_o($zero); if (popAddress() != rhs) do_goto(); }

        /**
         * Conditional branch based on a comparison between int values.
         *
         * <p>
         * Java Stack: ..., LEFT_VALUE, [RIGHT_VALUE] -> ...  (Forward branches);
         * <p>
         * Java Stack:      LEFT_VALUE, [RIGHT_VALUE] ->  _   (Backward branches);
         * <p>
         *
         * @param zero  if true, then RIGHT_VALUE is given the value 0 (and thus not popped from the stack)
         */
/*MAC*/ void do_if_eq_i(boolean $zero) { int rhs = rhs_i($zero); if (popInt() == rhs) do_goto(); }
/*MAC*/ void do_if_ne_i(boolean $zero) { int rhs = rhs_i($zero); if (popInt() != rhs) do_goto(); }
/*MAC*/ void do_if_lt_i(boolean $zero) { int rhs = rhs_i($zero); if (popInt() <  rhs) do_goto(); }
/*MAC*/ void do_if_le_i(boolean $zero) { int rhs = rhs_i($zero); if (popInt() <= rhs) do_goto(); }
/*MAC*/ void do_if_gt_i(boolean $zero) { int rhs = rhs_i($zero); if (popInt() >  rhs) do_goto(); }
/*MAC*/ void do_if_ge_i(boolean $zero) { int rhs = rhs_i($zero); if (popInt() >= rhs) do_goto(); }

        /**
         * Conditional branch based on a comparison between long values.
         *
         * <p>
         * Java Stack: ..., LEFT_VALUE, [RIGHT_VALUE] -> ...  (Forward branches);
         * <p>
         * Java Stack:      LEFT_VALUE, [RIGHT_VALUE] ->  _   (Backward branches);
         * <p>
         *
         * @param zero  if true, then RIGHT_VALUE is given the value 0 (and thus not popped from the stack)
         */
/*MAC*/ void do_if_eq_l(boolean $zero) { jlong rhs = rhs_l($zero); if (popLong() == rhs) do_goto(); }
/*MAC*/ void do_if_ne_l(boolean $zero) { jlong rhs = rhs_l($zero); if (popLong() != rhs) do_goto(); }
/*MAC*/ void do_if_lt_l(boolean $zero) { jlong rhs = rhs_l($zero); if (popLong() <  rhs) do_goto(); }
/*MAC*/ void do_if_le_l(boolean $zero) { jlong rhs = rhs_l($zero); if (popLong() <= rhs) do_goto(); }
/*MAC*/ void do_if_gt_l(boolean $zero) { jlong rhs = rhs_l($zero); if (popLong() >  rhs) do_goto(); }
/*MAC*/ void do_if_ge_l(boolean $zero) { jlong rhs = rhs_l($zero); if (popLong() >= rhs) do_goto(); }

        /**
         * Gets a table switch parameter.
         */
/*DEF*/ void getSwitchEntry(int $size) {
            if ($size == 2) {
                fetchShort();
            } else {
                fetchInt();
            }
        }

        /**
         * General table switch.
         *
         * <p>
         * Java Stack: KEY ->  _
         * <p>
         *
         * @param  size  the size (in bytes) of an entry in the jump table
         */
/*MAC*/ void do_tableswitch(int $size) {
            int fparm;
            int key;
            int low;
            int high;

            /*
             @TODO: FIX to not use mod (%). Very slow on ARM.
             */
            /*
             * Skip the padding.
             */
            while ((((UWord)ip) % $size) != 0) {
                fetchByte();
            }

            /*
             * Read the low and high bound and the default case.
             */
            getSwitchEntry($size);
            low   = fparm;
            getSwitchEntry($size);
            high  = fparm;
            getSwitchEntry($size);
            iparm = fparm;

            /*
             * Get the key.
             */
            key = popInt();

            /*
             * Calculate the new IP.
             */
            if (key >= low && key <= high) {
                if ($size == 4) {
                    iparm = getIntTyped(ip, key-low, AddressType_ANY);
                } else {
                    iparm = getShortTyped(ip, key-low, AddressType_ANY);
                }
            }

            /*
             * Update the IP.
             */
            do_goto();
        }


        /*-----------------------------------------------------------------------*\
         *                          Static field loads                           *
        \*-----------------------------------------------------------------------*/

        /**
         * Gets the class that a putstatic or getstatic instruction operates on.
         *
         * @param inCP    specifies if the class whose field to be accessed is
         *                the current class or is on the stack
         * @return the class whose static field is being accessed
         */
/*DEF*/ Address getStaticFieldClass(boolean $inCP) {
            return $inCP ? getCP() : popAddress();
        }

        /**
         * Loads a value from a static int field.
         *
         * <p>
         * Java Stack: CLASS -> VALUE
         * <p>
         *
         * @param inCP    specifies if the class whose field to be accessed is
         *                the current class or is on the stack
         */
/*MAC*/ void do_getstatic_i(boolean $inCP) {
            Address klass = getStaticFieldClass($inCP);
            Address state = VM_getClassStateREAL(klass);
            if (state != null) {
                checkReferenceSlots();
                boundsAssume(state, iparm);
                pushInt(getUWord(state, iparm));
            } else {
                pushAddress(klass);
                pushInt(iparm);
                call(com_sun_squawk_VM_getStaticInt);
            }
        }

        /**
         * Loads a value from a static long field.
         *
         * <p>
         * Java Stack: CLASS -> VALUE
         * <p>
         *
         * @param inCP    specifies if the class whose field to be accessed is
         *                the current class or is on the stack
         */
/*MAC*/ void do_getstatic_l(boolean $inCP) {
            Address klass = getStaticFieldClass($inCP);
            Address state = VM_getClassStateREAL(klass);
            if (state != null) {
                checkReferenceSlots();
                boundsAssume(state, iparm);
                pushLong(getLongAtWord(state, iparm));
            } else {
                pushAddress(klass);
                pushInt(iparm);
                call(com_sun_squawk_VM_getStaticLong);
            }
        }

        /**
         * Loads a value from a static object field.
         *
         * <p>
         * Java Stack: CLASS -> VALUE
         * <p>
         *
         * @param inCP    specifies if the class whose field to be accessed is
         *                the current class or is on the stack
         */
/*MAC*/ void do_getstatic_o(boolean $inCP) {
            Address klass = getStaticFieldClass($inCP);
            Address state = VM_getClassStateREAL(klass);
            if (state != null) {
                checkReferenceSlots();
                boundsAssume(state, iparm);
                pushAddress(getObject(state, iparm));
            } else {
                pushAddress(klass);
                pushInt(iparm);
                call(com_sun_squawk_VM_getStaticOop);
            }
        }

/*if[FLOATS]*/
        /**
         * Loads a value from a static float field.
         *
         * <p>
         * Java Stack: CLASS -> VALUE
         * <p>
         *
         * @param inCP    specifies if the class whose field to be accessed is
         *                the current class or is on the stack
         */
/*MAC*/ void do_getstatic_f(boolean $inCP) {
            do_getstatic_i($inCP);
        }

        /**
         * Loads a value from a static double field.
         *
         * <p>
         * Java Stack: CLASS -> VALUE
         * <p>
         *
         * @param inCP    specifies if the class whose field to be accessed is
         *                the current class or is on the stack
         */
/*MAC*/ void do_getstatic_d(boolean $inCP) {
            do_getstatic_l($inCP);
        }
/*end[FLOATS]*/

        /*-----------------------------------------------------------------------*\
         *                          Static field stores                          *
        \*-----------------------------------------------------------------------*/

        /**
         * Stores a value to a static int field.
         *
         * <p>
         * Java Stack: VALUE, CLASS -> _
         * <p>
         *
         * @param inCP    specifies if the class whose field to be accessed is
         *                the current class or is on the stack
         */
/*MAC*/ void do_putstatic_i(boolean $inCP) {
            Address klass = getStaticFieldClass($inCP);
            Address state = VM_getClassStateREAL(klass);
            if (state != null) {
                checkReferenceSlots();
                boundsAssume(state, iparm);
                setUWord(state, iparm, popInt());
            } else {
                pushAddress(klass);
                pushInt(iparm);
                call(com_sun_squawk_VM_putStaticInt);
            }
        }

        /**
         * Stores a value to a static long field.
         *
         * <p>
         * Java Stack: VALUE, CLASS -> _
         * <p>
         *
         * @param inCP    specifies if the class whose field to be accessed is
         *                the current class or is on the stack
         */
/*MAC*/ void do_putstatic_l(boolean $inCP) {
            Address klass = getStaticFieldClass($inCP);
            Address state = VM_getClassStateREAL(klass);
            if (state != null) {
                checkReferenceSlots();
                boundsAssume(state, iparm);
                setLongAtWord(state, iparm, popLong());
            } else {
                pushAddress(klass);
                pushInt(iparm);
                call(com_sun_squawk_VM_putStaticLong);
            }
        }

        /**
         * Stores a value to a static object field.
         *
         * <p>
         * Java Stack: VALUE, CLASS -> _
         * <p>
         *
         * @param inCP    specifies if the class whose field to be accessed is
         *                the current class or is on the stack
         */
/*MAC*/ void do_putstatic_o(boolean $inCP) {
            Address klass = getStaticFieldClass($inCP);
            Address state = VM_getClassStateREAL(klass);
            if (state != null) {
                checkReferenceSlots();
                boundsAssume(state, iparm);
                setObjectAndUpdateWriteBarrier(state, iparm, popAddress());
            } else {
                pushAddress(klass);
                pushInt(iparm);
                call(com_sun_squawk_VM_putStaticOop);
            }
        }

/*if[FLOATS]*/
        /**
         * Stores a value to a static float field.
         *
         * <p>
         * Java Stack: VALUE, CLASS -> _
         * <p>
         *
         * @param inCP    specifies if the class whose field to be accessed is
         *                the current class or is on the stack
         */
/*MAC*/ void do_putstatic_f(boolean $inCP) {
            do_putstatic_i($inCP);
        }

        /**
         * Stores a value to a static double field.
         *
         * <p>
         * Java Stack: VALUE, CLASS -> _
         * <p>
         *
         * @param inCP    specifies if the class whose field to be accessed is
         *                the current class or is on the stack
         */
/*MAC*/ void do_putstatic_d(boolean $inCP) {
            do_putstatic_l($inCP);
        }
/*end[FLOATS]*/

        /*-----------------------------------------------------------------------*\
         *                         Instance field access                         *
        \*-----------------------------------------------------------------------*/

        /**
         * Check for a null pointer.
         *
         * @param oop the pointer
         * @param checkSlots true if slot checking should be performed
         */
/*DEF*/ void nullCheckPrim(Address $oop, boolean $checkSlots) {
            if ($checkSlots) {
                checkReferenceSlots();
            }
            if ($oop == 0) {
/*if[MACROIZE]*/
/*              --- TEST: fatalInterpreterError("NPE, time to freak out!");*/
                goto throw_nullPointerException;
/*else[MACROIZE]*/
//              resetStackPointerIfRevParms();
//              call(com_sun_squawk_VM_nullPointerException);
//              nextbytecode();
/*end[MACROIZE]*/
            }
        }

        /**
         * Check for a null pointer.
         *
         * @param oop the pointer
         */
/*DEF*/ void nullCheck(Address $oop) {
            nullCheckPrim($oop, true);
        }

        /**
         * Check for a null pointer or an array bounds overflow.
         *
         * @param oop the array
         * @param index the index to check
         */
/*DEF*/ void boundsCheck(Address $oop, int $index) {
            int lth;
            nullCheck($oop);
            lth = (int)getArrayLength($oop);
            /* use the unsigned bounds check trick: */
            if ((unsigned int) $index >= (unsigned int)lth) {
                /*  ($index < 0 || $index >= lth) */
/*if[MACROIZE]*/
                com_sun_squawk_VM_reportedIndex = $index;
                com_sun_squawk_VM_reportedArray = $oop;
                goto throw_arrayIndexOutOfBoundsException;
/*else[MACROIZE]*/
//              resetStackPointerIfRevParms();
//              call(com_sun_squawk_VM_arrayIndexOutOfBoundsException);
//              nextbytecode();
/*end[MACROIZE]*/
            }
        }

        /**
         * Gets the object that a putfield or getfield instruction operates on.
         *
         * @param oopIn0  specifies if the object whose field to be accessed is
         *                in parameter 0 or is on the stack
         * @return the object
         */
/*DEF*/ Address getInstanceFieldOop(boolean $oopIn0) {
            return $oopIn0 ? (Address)getParmTyped(0, AddressType_REF) : popAddress();
        }

        /*-----------------------------------------------------------------------*\
         *                         Instance field loads                          *
        \*-----------------------------------------------------------------------*/

        /**
         * Loads a value from an int or long instance field that is being used
         * as an Address, UWord or Offset.
         *
         * @param oop   the object containing the field
         * @param flag  return immediately if false
         */
/*DEF*/ void getfield_ref_or_uword(Address $oop, boolean $flag) {
            if (TYPEMAP && $flag) {
                if (getMutationType() == AddressType_REF) {
                    pushAddress(getObject($oop, iparm));
                    nextbytecode(); /* completes instruction execution */
                }
                if (getMutationType() == AddressType_UWORD) {
                    pushWord(getUWord($oop, iparm));
                    nextbytecode(); /* completes instruction execution */
                }
            }
            /*
             * The field really stores an int or long and so fall back to the
             * properly typed way of loading these values
             */
        }

        /**
         * Loads a value from a byte instance field.
         *
         * <p>
         * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_getfield_b(boolean $oopIn0) {
            Address oop = getInstanceFieldOop($oopIn0);
            nullCheckPrim(oop, true);
            pushInt(getByte(oop, iparm));
        }

        /**
         * Loads a value from a short instance field.
         *
         * <p>
         * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_getfield_s(boolean $oopIn0) {
            Address oop = getInstanceFieldOop($oopIn0);
            nullCheckPrim(oop, true);
            pushInt(getShort(oop, iparm));
        }

        /**
         * Loads a value from a char instance field.
         *
         * <p>
         * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_getfield_c(boolean $oopIn0) {
            Address oop = getInstanceFieldOop($oopIn0);
            nullCheckPrim(oop, true);
            pushInt(getUShort(oop, iparm));
        }

        /**
         * Loads a value from an int instance field.
         *
         * <p>
         * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_getfield_i(boolean $oopIn0) {
            Address oop = getInstanceFieldOop($oopIn0);
            nullCheckPrim(oop, true);
            getfield_ref_or_uword(oop, !SQUAWK_64);
            pushInt(getInt(oop, iparm));
        }

        /**
         * Loads a value from an object instance field.
         *
         * <p>
         * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_getfield_o(boolean $oopIn0) {
            Address oop = getInstanceFieldOop($oopIn0);
            nullCheckPrim(oop, true);
            pushAddress(getObject(oop, iparm));
        }

        /**
         * Loads a value from a long instance field.
         *
         * <p>
         * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_getfield_l(boolean $oopIn0) {
            Address oop = getInstanceFieldOop($oopIn0);
            nullCheckPrim(oop, true);
            getfield_ref_or_uword(oop, SQUAWK_64);
            pushLong(getLongAtWord(oop, iparm));
        }

/*if[FLOATS]*/
        /**
         * Loads a value from a float instance field.
         *
         * <p>
         * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_getfield_f(boolean $oopIn0) {
            Address oop = getInstanceFieldOop($oopIn0);
            nullCheckPrim(oop, true);
            pushInt(getInt(oop, iparm));
        }

        /**
         * Loads a value from a double instance field.
         *
         * <p>
         * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_getfield_d(boolean $oopIn0) {
            Address oop = getInstanceFieldOop($oopIn0);
            nullCheckPrim(oop, true);
            pushLong(getLongAtWord(oop, iparm));
        }
/*end[FLOATS]*/

        /*-----------------------------------------------------------------------*\
         *                         Instance field stores                         *
        \*-----------------------------------------------------------------------*/

        /**
         * Stores a value to an int or long instance field that is being used
         * as an Address, UWord or Offset.
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*DEF*/ void putfield_ref_or_uword(boolean $oopIn0, boolean $flag) {
            if (TYPEMAP && $flag) {
                if (getMutationType() == AddressType_REF) {
                    Address value = popAddress();
                    Address oop = getInstanceFieldOop($oopIn0);
                    nullCheckPrim(oop, !$oopIn0);
                    setObject(oop, iparm, value);
                    nextbytecode();
                } else if (getMutationType() == AddressType_UWORD) {
                    UWord value = popWord();
                    Address oop = getInstanceFieldOop($oopIn0);
                    nullCheckPrim(oop, !$oopIn0);
                    setUWord(oop, iparm, value);
                    nextbytecode();
                }
            }
        }

        /**
         * Stores a value to a byte instance field.
         *
         * <p>
         * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_putfield_b(boolean $oopIn0) {
            int value = popInt();
            Address oop = getInstanceFieldOop($oopIn0);
            nullCheckPrim(oop, !$oopIn0);
            setByte(oop, iparm, value);
        }

        /**
         * Stores a value to a short or char instance field.
         *
         * <p>
         * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_putfield_s(boolean $oopIn0) {
            int value = popInt();
            Address oop = getInstanceFieldOop($oopIn0);
            nullCheckPrim(oop, !$oopIn0);
            setShort(oop, iparm, value);
        }

        /**
         * Stores a value to an int instance field.
         *
         * <p>
         * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_putfield_i(boolean $oopIn0) {
            putfield_ref_or_uword($oopIn0, !SQUAWK_64);
            {
                int value = popInt();
                Address oop = getInstanceFieldOop($oopIn0);
                nullCheckPrim(oop, !$oopIn0);
                setInt(oop, iparm, value);
            }
        }

        /**
         * Stores a value to an object instance field.
         *
         * <p>
         * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_putfield_o(boolean $oopIn0) {
            Address value = popAddress();
            Address oop = getInstanceFieldOop($oopIn0);
            nullCheckPrim(oop, !$oopIn0);
            setObjectAndUpdateWriteBarrier(oop, iparm, value);
        }

        /**
         * Stores a value to a long instance field.
         *
         * <p>
         * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_putfield_l(boolean $oopIn0) {
            putfield_ref_or_uword($oopIn0, SQUAWK_64);
            {
                jlong value = popLong();
                Address oop = getInstanceFieldOop($oopIn0);
                nullCheckPrim(oop, !$oopIn0);
                setLongAtWord(oop, iparm, value);
            }
        }

/*if[FLOATS]*/
        /**
         * Stores a value to a float instance field.
         *
         * <p>
         * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_putfield_f(boolean $oopIn0) {
            int value = popInt();
            Address oop = getInstanceFieldOop($oopIn0);
            nullCheckPrim(oop, !$oopIn0);
            setInt(oop, iparm, value);
        }

        /**
         * Stores a value to a double instance field.
         *
         * <p>
         * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
         * <p>
         * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
         * <p>
         *
         * @param oopIn0  specifies if the object whose field to be loaded is
         *                in parameter 0 or is on the stack
         */
/*MAC*/ void do_putfield_d(boolean $oopIn0) {
            jlong value = popLong();
            Address oop = getInstanceFieldOop($oopIn0);
            nullCheckPrim(oop, !$oopIn0);
            setLongAtWord(oop, iparm, value);
        }
/*end[FLOATS]*/

        /*-----------------------------------------------------------------------*\
         *                           Array loads                                 *
        \*-----------------------------------------------------------------------*/

        /**
         * Loads a value from an int or long array that is being used to store Address,
         * UWord or Offset values.
         *
         * @param index  the index of the element to load
         * @param oop    the address of the array
         * @param flag   return immediately if false
         */
/*DEF*/ void aload_ref_or_uword(int $index, Address $oop, boolean $flag) {
            if (TYPEMAP && $flag) {
                if (getMutationType() == AddressType_REF) {
                    pushAddress(getObject($oop, $index));
                    nextbytecode();
                }
                if (getMutationType() == AddressType_UWORD) {
                    pushWord(getUWord($oop, $index));
                    nextbytecode();
                }
            }
        }

        /**
         * Loads an element from a byte array.
         *
         * <p>
         * Java Stack: ..., OOP, INT -> ..., VALUE
         * <p>
         */
/*MAC*/ void do_aload_b() {
            int index   = popInt();
            Address oop = popAddress();
            boundsCheck(oop, index);
            pushInt(getByte(oop, index));
        }

        /**
         * Loads an element from a short array.
         *
         * <p>
         * Java Stack: ..., OOP, INT -> ..., VALUE
         * <p>
         */
/*MAC*/ void do_aload_s() {
            int index   = popInt();
            Address oop = popAddress();
            boundsCheck(oop, index);
            pushInt(getShort(oop, index));
        }

        /**
         * Loads an element from a char array.
         *
         * <p>
         * Java Stack: ..., OOP, INT -> ..., VALUE
         * <p>
         */
/*MAC*/ void do_aload_c() {
            int index   = popInt();
            Address oop = popAddress();
            boundsCheck(oop, index);
            pushInt(getUShort(oop, index));
        }

        /**
         * Loads an element from an integer array.
         *
         * <p>
         * Java Stack: ..., OOP, INT -> ..., VALUE
         * <p>
         */
/*MAC*/ void do_aload_i() {
            int index   = popInt();
            Address oop = popAddress();
            boundsCheck(oop, index);
            aload_ref_or_uword(index, oop, !SQUAWK_64);
            pushInt(getInt(oop, index));
        }

        /**
         * Loads an element from an object array.
         *
         * <p>
         * Java Stack: ..., OOP, INT -> ..., VALUE
         * <p>
         */
/*MAC*/ void do_aload_o() {
            int index   = popInt();
            Address oop = popAddress();
            boundsCheck(oop, index);
            pushAddress(getObject(oop, index));
        }

        /**
         * Loads an element from a long array.
         *
         * <p>
         * Java Stack: ..., OOP, INT -> ..., VALUE
         * <p>
         */
/*MAC*/ void do_aload_l() {
            int index   = popInt();
            Address oop = popAddress();
            boundsCheck(oop, index);
            aload_ref_or_uword(index, oop, SQUAWK_64);
            pushLong(getLong(oop, index));
        }

/*if[FLOATS]*/
        /**
         * Loads an element from a float array.
         *
         * <p>
         * Java Stack: ..., OOP, INT -> ..., VALUE
         * <p>
         */
/*MAC*/ void do_aload_f() {
            int index   = popInt();
            Address oop = popAddress();
            boundsCheck(oop, index);
            pushInt(getInt(oop, index));
        }

        /**
         * Loads an element from a double array.
         *
         * <p>
         * Java Stack: ..., OOP, INT -> ..., VALUE
         * <p>
         */
/*MAC*/ void do_aload_d() {
            int index   = popInt();
            Address oop = popAddress();
            boundsCheck(oop, index);
            pushLong(getLong(oop, index));
        }
/*end[FLOATS]*/

        /*-----------------------------------------------------------------------*\
         *                           Array stores                                *
        \*-----------------------------------------------------------------------*/

/*DEF*/ void astore_ref_or_word() {
            if (TYPEMAP) {
                if (getMutationType() == AddressType_REF) {
                    Address value = popAddress();
                    int index   = popInt();
                    Address oop = popAddress();
                    boundsCheck(oop, index);
                    setObject(oop, index, value);
                    nextbytecode();
                } else if (getMutationType() == AddressType_UWORD) {
                    UWord value = popWord();
                    int index   = popInt();
                    Address oop = popAddress();
                    boundsCheck(oop, index);
                    setUWord(oop, index, value);
                    nextbytecode();
                }
            }
        }

        /**
         * Stores an element to a byte array.
         *
         * <p>
         * Java Stack: ..., OOP, INT, VALUE -> ...
         * <p>
         */
/*MAC*/ void do_astore_b() {
            int value   = popInt();
            int index   = popInt();
            Address oop = popAddress();
            boundsCheck(oop, index);
            setByte(oop, index, value);
        }

        /**
         * Stores an element to a short array.
         *
         * <p>
         * Java Stack: ..., OOP, INT, VALUE -> ...
         * <p>
         */
/*MAC*/ void do_astore_s() {
            int value   = popInt();
            int index   = popInt();
            Address oop = popAddress();
            boundsCheck(oop, index);
            setShort(oop, index, value);
        }

        /**
         * Stores an element to an int array.
         *
         * <p>
         * Java Stack: ..., OOP, INT, VALUE -> ...
         * <p>
         */
/*MAC*/ void do_astore_i() {
            astore_ref_or_word();
            {
                int value   = popInt();
                int index   = popInt();
                Address oop = popAddress();
                boundsCheck(oop, index);
                setInt(oop, index, value);
            }
        }

        /**
         * Stores an element to a long array.
         *
         * <p>
         * Java Stack: ..., OOP, INT, VALUE -> ...
         * <p>
         */
/*MAC*/ void do_astore_l() {
            astore_ref_or_word();
            {
                jlong value = popLong();
                int index   = popInt();
                Address oop = popAddress();
                boundsCheck(oop, index);
                setLong(oop, index, value);
            }
        }

        /**
         * Stores an element to an object array.
         *
         * <p>
         * Java Stack:      OOP, INT, VALUE -> _
         * <p>
         */
/*MAC*/ void do_astore_o() {
            Address value  = popAddress();
            int index   = popInt();
            Address oop = popAddress();
            boundsCheck(oop, index);
            if ((value != 0) 
                 && (com_sun_squawk_Klass_id(getClass(oop)) != CID_OBJECT_ARRAY)
                 && VM_arrayOopStoreCheck(oop, index, value)) {
                    call(com_sun_squawk_VM_arrayStoreException);
            } else {
                setObjectAndUpdateWriteBarrier(oop, index, value);
            }
        }

/*if[FLOATS]*/
        /**
         * Stores an element to a float array.
         *
         * <p>
         * Java Stack: ..., OOP, INT, VALUE -> ...
         * <p>
         */
/*MAC*/ void do_astore_f() {
            int value   = popInt();
            int index   = popInt();
            Address oop = popAddress();
            boundsCheck(oop, index);
            setInt(oop, index, value);
        }

        /**
         * Stores an element to a double array.
         *
         * <p>
         * Java Stack: ..., OOP, INT, VALUE -> ...
         * <p>
         */
/*MAC*/ void do_astore_d() {
            jlong value = popLong();
            int index   = popInt();
            Address oop = popAddress();
            boundsCheck(oop, index);
            setLong(oop, index, value);
        }
/*end[FLOATS]*/

        /*-----------------------------------------------------------------------*\
         *                           Invoke instructions                         *
        \*-----------------------------------------------------------------------*/

        /**
         * invokestatic.
         *
         * Java Stack: [[... arg2], arg1], CLASS -> [VALUE]
         * <p>
         */
/*MAC*/ void do_invokestatic() {
            Address cls = popAddress();
            call(getStaticMethod(cls, iparm));
        }

        /**
         * invokesuper.
         *
         * Java Stack: [[... arg2], arg1], OOP, CLASS -> [VALUE]
         * <p>
         */
/*MAC*/ void do_invokesuper() {
            Address cls = popAddress();
            Address obj;
            resetStackPointerIfNotRevParms();
            obj = (Address)peek();
            nullCheck(obj);
            callNoReset(getVirtualMethod(cls, iparm));
        }

        /**
         * invokevirtual.
         *
         * Java Stack: [[... arg2], arg1], OOP -> [VALUE]
         * <p>
         */
/*MAC*/ void do_invokevirtual() {
            Address obj;
            Address cls;
            resetStackPointerIfNotRevParms();
            obj = (Address)peek();
            nullCheck(obj);
            assumeInterp(((UWord)getObject(obj, HDR_klass) & HDR_headerTagMask) == 0);
            cls = getClassOrAssociation(obj);
            callNoReset(getVirtualMethod(cls, iparm));
        }
        
        /**
         * findslot.
         *
         * <p>
         * Java Stack: OOP, CLASS -> VSLOT
         * <p>
         */
/*MAC*/ void do_findslot() {
            Address interfaceKlass = popAddress();
            Address oop = popAddress();
            int slot;

            nullCheck(oop);
            slot = VM_findSlot(oop, interfaceKlass, iparm);
            if (likely(slot >= 0)) {
                pushInt(slot);
            } else {
                call(com_sun_squawk_VM_abstractMethodError);
            }
        }

        /**
         * invokeslot.
         *
         * Java Stack: [[... arg2], arg1], OOP, VSLOT -> [VALUE] (Stack grows down)
         */
/*MAC*/ void do_invokeslot() {
            iparm = popInt();
            do_invokevirtual();
        }


/*INL*/ void incExtends(int $slots) {
#if TRACE
            total_extends++;
            total_slots += $slots;
#endif
        }


        /**
         * Extends the call stack if necessary.
         *
         * <p>
         * Java Stack: _ -> _
         * <p>
         */
/*MAC*/ void extendStack(Address $mp, int $slotsToClear) {
            Address mp = $mp;
            int nlocals, nstack;
            assumeInterp(com_sun_squawk_VM_extendsEnabled);
			assumeInterp(inCode(mp));
            downPushAddress(fp);                        /* Save caller's frame pointer. */
            downPushAddress(mp);                        /* Method address.              */
            fp = sp;                                    /* Setup new frame pointer.     */
            assumeInterp(getMP() == mp);
            nlocals = getLocalCount(mp);
            nstack  = getStackCount(mp);
            assumeInterp($slotsToClear < nlocals);
            incExtends($slotsToClear);
            if (likely((fp - nlocals - nstack) > (sl + FP_FIXED_FRAME_SIZE))) {
                UWordAddress oldsp = sp;
                int delta = nlocals;
/*if[REVERSE_PARAMETERS]*/
/*else[REVERSE_PARAMETERS]*/
//              delta += nstack;
/*end[REVERSE_PARAMETERS]*/
                resetStackPointerFromDelta(delta);
                if (CHECK_SLOT_CLEARING) {
                    int slotsToZap = nlocals - 1;
                    UWordAddress oldsp2 = oldsp;
                    while (slotsToZap > 0) {
                        setUWord(--oldsp2, 0, 0xDEAFBEEF);            /* Write a bad value */
                        setType(oldsp2, AddressType_ANY, sizeof(UWord));
                        slotsToZap = slotsToZap - 1;
                    }
                }
                while ($slotsToClear > 0) {
                    setUWord(--oldsp, 0, 0);            /* zero local variables that need clearing */
                    setType(oldsp, AddressType_ANY, sizeof(UWord));
                    $slotsToClear = $slotsToClear - 1;
                }
            } else {
                int overflow = (sl + FP_FIXED_FRAME_SIZE) - (fp - nlocals - nstack);
                assumeInterp(getUWord(ss, SC_guard) == 0);
                if (com_sun_squawk_GC_GC_TRACING_SUPPORTED && com_sun_squawk_GC_traceFlags > 1) {
                    fprintf(stderr, format(
                                            "*** Extending stack *** (stack size=%d, remaining stack=%d, nlocals=%d, nstack=%d, slotsToClear=%d, mp=0x%x)\n"),
                                            getArrayLength(ss),
                                            sp - sl,
                                            nlocals,
                                            nstack,
                                            $slotsToClear,
                                            (int)mp
                                          );
                }
                if (usingServiceStack()) {
                    fatalInterpreterError("cannot extend service stack");
                }
                if (!com_sun_squawk_VM_extendsEnabled) {
                    fatalInterpreterError("trying to extend stack when extension disabled");
                }

                /* Pass the minimum amount (in words) by which the stack must grow. */
                com_sun_squawk_ServiceOperation_i1 = overflow;

                if (TRACE) {
                    printStackTracePrim(-1, ip, fp, "extending stack", null);
                }

                threadSwitchFor(com_sun_squawk_ServiceOperation_EXTEND);
            }
        }

        /**
         * Check that there are no 0xDEAFBEEF words in the local variables.
         */
/*MAC*/ void checkReferenceSlots() {
/*if[CHECK_SLOT_CLEARING]*/
            if (CHECK_SLOT_CLEARING && fp != null) {
                int i;
                Address mp     = getMP();
                int nparms     = getParmCount(mp);
                int nlocals    = getLocalCount(mp);
                int vars       = nlocals + nparms;
                int oopmapLth  = (vars+7)/8;
                int oopMapOff  = getOffsetToLastMinfoByte(mp) - oopmapLth;
                int bitOffset  = (nparms - 1) % 8;
                int byteOffset = (nparms - 1) / 8;
                for (i = 0 ; i < nlocals ; i++) {
                    int bite;
                    boolean isOop;
                    bitOffset++;
                    if (bitOffset == 8) {
                        bitOffset = 0;
                        byteOffset++;
                    }
                    bite  = getByte(mp, oopMapOff + byteOffset);
                    isOop = ((bite >> bitOffset) & 1) != 0;
                    if (isOop) {
                        UWord wd = peekLocal(i);
                        if (wd == (UWord)0xDEAFBEEF) {
                            fatalInterpreterError("0xDEAFBEEF found");
                        }
                    }
                }
            }
/*end[CHECK_SLOT_CLEARING]*/
        }

        /**
         * Extend the activation record.
         *
         * <p>
         * Java Stack: _ -> _
         * <p>
         */
/*MAC*/ void do_extend() {
            Address mp = Address_sub(ip, 2);
            extendStack(mp, iparm);
        }

        /**
         * Extend the activation record.
         *
         * <p>
         * Java Stack: _ -> _
         * <p>
         */
/*MAC*/ void do_extend0() {
            Address mp = Address_sub(ip, 1);
            extendStack(mp, 0);
        }

        /*-----------------------------------------------------------------------*\
         *                               Return                                  *
        \*-----------------------------------------------------------------------*/

        /**
         * Executes a method return where the int or long value being returned is being used
         * as an Address, UWord or Offset.
         *
         * @param flag  return immediately if false
         */
/*DEF*/ void return_ref_or_uword(boolean $flag) {
            if (TYPEMAP && $flag) {
                if (getMutationType() == AddressType_REF) {
                    Address res;
                    ip = (ByteAddress)getObject(fp, FP_returnIP);
                    res = popAddress();
                    fp = (UWordAddress)getObject(fp, FP_returnFP);
                    resetStackPointer();
                    pushAddress(res);
                    nextbytecode();
                }
                if (getMutationType() == AddressType_UWORD) {
                    UWord res;
                    ip = (ByteAddress)getObject(fp, FP_returnIP);
                    res = popWord();
                    fp = (UWordAddress)getObject(fp, FP_returnFP);
                    resetStackPointer();
                    pushWord(res);
                    nextbytecode();
                }
            }
        }

        /**
         * Executes a return from a method that returns an int value.
         *
         * <p>
         * Java Stack: [VALUE] -> [VALUE]
         * <p>
         */
/*MAC*/ void do_return_i() {
            return_ref_or_uword(!SQUAWK_64);
            {
                int res = popInt();
                ip = (ByteAddress)getObject(fp, FP_returnIP);
                fp = (UWordAddress)getObject(fp, FP_returnFP);
                assumeInterp(inCode(ip));
                resetStackPointer();
                pushInt(res);
            }
        }

        /**
         * Executes a return from a method that returns a long value.
         *
         * <p>
         * Java Stack: [VALUE] -> [VALUE]
         * <p>
         */
/*MAC*/ void do_return_l() {
            return_ref_or_uword(SQUAWK_64);
            {
                jlong res = popLong();
                ip = (ByteAddress)getObject(fp, FP_returnIP);
                fp = (UWordAddress)getObject(fp, FP_returnFP);
                assumeInterp(inCode(ip));
                resetStackPointer();
                pushLong(res);
            }
        }

        /**
         * Executes a return from a method that returns an object value.
         *
         * <p>
         * Java Stack: [VALUE] -> [VALUE]
         * <p>
         */
/*MAC*/ void do_return_o() {
            Address res = popAddress();
            ip = (ByteAddress)getObject(fp, FP_returnIP);
            fp = (UWordAddress)getObject(fp, FP_returnFP);
            assumeInterp(inCode(ip));
            resetStackPointer();
            pushAddress(res);
        }

        /**
         * Executes a return from a method that does not return a value.
         *
         * <p>
         * Java Stack: [VALUE] -> _
         * <p>
         */
/*MAC*/ void do_return_v() {
            ip = (ByteAddress)getObject(fp, FP_returnIP);
            fp = (UWordAddress)getObject(fp, FP_returnFP);
            assumeInterp(inCode(ip));
            resetStackPointer();
        }

/*if[FLOATS]*/
        /**
         * Executes a return from a method that returns a float value.
         *
         * <p>
         * Java Stack: [VALUE] -> [VALUE]
         * <p>
         */
/*MAC*/ void do_return_f() {
            do_return_i();
        }

        /**
         * Executes a return from a method that returns a double value.
         *
         * <p>
         * Java Stack: [VALUE] -> [VALUE]
         * <p>
         */
/*MAC*/ void do_return_d() {
            do_return_l();
        }
/*end[FLOATS]*/

        /*-----------------------------------------------------------------------*\
         *                               Pop                                     *
        \*-----------------------------------------------------------------------*/

        /**
         * Pops one word from the Java stack.
         *
         * <p>
         * Java Stack: ..., INT -> ...
         * <p>
         */
/*MAC*/ void do_pop_n(int $n) {
            popAsType(AddressType_ANY);
            if (!SQUAWK_64 && $n == 2) {
                popAsType(AddressType_ANY);
            }
        }

        /*-----------------------------------------------------------------------*\
         *                           Native methods                              *
        \*-----------------------------------------------------------------------*/

/*if[GC2C]*/
        /**
         * These forward declarations have to be here to deal with the
         * different behaviour of GCC on the Mac with respect to forward
         * declarations of static methods.
         */
        static Address copyObjectGraph(Address, Address, Address, Address);
        static int collectGarbage(Address, Address, int);
/*end[GC2C]*/

#if PLATFORM_TYPE_BARE_METAL
#define checkNativeCall(_ptr_) fatalInterpreterError("checkNativeCall")
#define endCheckNativeCall()
#else
#define checkNativeCall(_ptr_) nativeFuncPtr = _ptr_
#define endCheckNativeCall() nativeFuncPtr = NULL
#endif

        /**
         * invokenativemain.
         */
/*MAC*/ void invokenativemain() {
            checkReferenceSlots();
            switch(iparm) {
                case Native_com_sun_squawk_Offset_eq:
                case Native_com_sun_squawk_UWord_eq: {
                    UWord value2 = popWord();
                    UWord value1 = popWord();
                    pushInt(value1 == value2);
                    break;
                }

                case Native_com_sun_squawk_Offset_ne:
                case Native_com_sun_squawk_UWord_ne: {
                    UWord value2 = popWord();
                    UWord value1 = popWord();
                    pushInt(value1 != value2);
                    break;
                }

                case Native_com_sun_squawk_Offset_add: {
                    int delta = popInt();
                    Offset offset = (Offset)popWord();
                    pushWord(offset + delta);
                    break;
                }

                case Native_com_sun_squawk_Offset_sub: {
                    int delta = popInt();
                    Offset offset = (Offset)popWord();
                    pushWord(offset - delta);
                    break;
                }

                case Native_com_sun_squawk_Offset_bytesToWords: {
                    Offset offset = (Offset)popWord();
                    assumeInterp((offset % HDR_BYTES_PER_WORD) == 0);
                    pushWord(offset >> HDR_LOG2_BYTES_PER_WORD);
                    break;
                }

                case Native_com_sun_squawk_Offset_wordsToBytes: {
                    Offset offset = (Offset)popWord();
                    pushWord(offset << HDR_LOG2_BYTES_PER_WORD);
                    break;
                }

                case Native_com_sun_squawk_Address_fromPrimitive: {
                    if (TYPEMAP) {
                        UWord value = SQUAWK_64 ? popLong() : popInt();
                        pushAddress((Address)value);
                    }
                    break;
                }

                case Native_com_sun_squawk_Offset_fromPrimitive:
                case Native_com_sun_squawk_UWord_fromPrimitive: {
                    if (TYPEMAP) {
                        UWord value = SQUAWK_64 ? popLong() : popInt();
                        pushWord(value);
                    }
                    break;
                }

                case Native_com_sun_squawk_Offset_toPrimitive:
                case Native_com_sun_squawk_UWord_toPrimitive: {
                    if (TYPEMAP) {
                        UWord value = popWord();
                        if (SQUAWK_64) {
                            /* this catches a (false) assumption that a given offset won't loose its sign or magnitude when converted to a long */
                            if (ASSUME && (jlong)value != value) {
                                fatalInterpreterError("cast to long changes sign and/or magnitude");
                            }
                            pushLong(value);
                        } else {
                            /* this catches a (false) assumption that a given offset won't loose its sign or magnitude when converted to an int */
                            if (ASSUME && (int)value != value) {
                                fatalInterpreterError("cast to int changes sign and/or magnitude");
                            }
                            pushInt(value);
                        }
                    }
                    break;
                }

                case Native_com_sun_squawk_Offset_toInt:
                case Native_com_sun_squawk_UWord_toInt: {
                    if (TYPEMAP || SQUAWK_64 || ASSUME) {
                        UWord value = popWord();
                        /* this catches a (false) assumption that a given offset won't loose its sign or magnitude when converted to an int */
                        if (ASSUME && (int)value != value) {
                            fatalInterpreterError("cast to int changes sign and/or magnitude");
                        }
                        pushInt((int)value);
                    }
                    break;
                }

                case Native_com_sun_squawk_UWord_toOffset:
                case Native_com_sun_squawk_Offset_toUWord: {
                    break;
                }

                case Native_com_sun_squawk_UWord_max: {
                    pushWord(WORD_MAX);
                    break;
                }

                case Native_com_sun_squawk_Offset_zero:
                case Native_com_sun_squawk_UWord_zero: {
                    pushWord(0);
                    break;
                }

                case Native_com_sun_squawk_UWord_and: {
                    UWord value2 = popWord();
                    UWord value1 = popWord();
                    pushWord(value1 & value2);
                    break;
                }

                case Native_com_sun_squawk_UWord_or: {
                    UWord value2 = popWord();
                    UWord value1 = popWord();
                    pushWord(value1 | value2);
                    break;
                }

                case Native_com_sun_squawk_UWord_loeq: {
                    UWord value2 = popWord();
                    UWord value1 = popWord();
                    pushInt(loeq(value1, value2));
                    break;
                }

                case Native_com_sun_squawk_UWord_hieq: {
                    UWord value2 = popWord();
                    UWord value1 = popWord();
                    pushInt(hieq(value1, value2));
                    break;
                }

                case Native_com_sun_squawk_UWord_hi: {
                    UWord value2 = popWord();
                    UWord value1 = popWord();
                    pushInt(hi(value1, value2));
                    break;
                }

                case Native_com_sun_squawk_UWord_lo: {
                    UWord value2 = popWord();
                    UWord value1 = popWord();
                    pushInt(lo(value1, value2));
                    break;
                }

                case Native_com_sun_squawk_Offset_le: {
                    UWord value2 = popWord();
                    UWord value1 = popWord();
                    pushInt(le(value1, value2));
                    break;
                }

                case Native_com_sun_squawk_Offset_ge: {
                    UWord value2 = popWord();
                    UWord value1 = popWord();
                    pushInt(ge(value1, value2));
                    break;
                }

                case Native_com_sun_squawk_Offset_gt: {
                    UWord value2 = popWord();
                    UWord value1 = popWord();
                    pushInt(gt(value1, value2));
                    break;
                }

                case Native_com_sun_squawk_Offset_lt: {
                    UWord value2 = popWord();
                    UWord value1 = popWord();
                    pushInt(lt(value1, value2));
                    break;
                }

                case Native_com_sun_squawk_Offset_isZero:
                case Native_com_sun_squawk_UWord_isZero: {
                    UWord value = popWord();
                    pushInt(value == 0);
                    break;
                }

                case Native_com_sun_squawk_UWord_isMax: {
                    UWord value = popWord();
                    pushInt(value == WORD_MAX);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_getAsByte:
                    if (TYPEMAP) {
                        int     off = popInt();
                        Address base = popAddress();
                        pushInt(getByteTyped(base, off, AddressType_ANY));
                        break;
                    } else {
                        /* fall-through... */
                    }
                case Native_com_sun_squawk_NativeUnsafe_getByte: {
                    int     off = popInt();
                    Address base = popAddress();
                    pushInt(getByte(base, off));
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_setByte: {
                    int     val = popInt();
                    int     off = popInt();
                    Address base = popAddress();
                    setByte(base, off, val);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_getAsShort:
                    if (TYPEMAP) {
                        int     off = popInt();
                        Address base = popAddress();
                        pushInt(getShortTyped(base, off, AddressType_ANY));
                        break;
                    } else {
                         /* fall-through... */
                    }
                case Native_com_sun_squawk_NativeUnsafe_getShort: {
                    int     off = popInt();
                    Address base = popAddress();
                    pushInt(getShort(base, off));
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_getChar: {
                    int     off = popInt();
                    Address base = popAddress();
                    pushInt(getUShort(base, off));
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_charAt: {
                    int     off = popInt();
                    Address str = popAddress();
                    Address cls = getClass(str);
                    boundsAssume(str, off);
                    if (com_sun_squawk_Klass_id(cls) == com_sun_squawk_StringOfBytes) {
                        pushInt(getUByte(str, off));
                    } else {
                        pushInt(getUShort(str, off));
                    }
                    break;
                }
                
                case Native_com_sun_squawk_NativeUnsafe_setShort:
                case Native_com_sun_squawk_NativeUnsafe_setChar: {
                    int     val = popInt();
                    int     off = popInt();
                    Address base = popAddress();
                    setShort(base,  off, val);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_getAddress:
                case Native_com_sun_squawk_NativeUnsafe_getObject: {
                    int     off = popInt();
                    Address base = popAddress();
                    pushAddress(getObject(base, off));
                    break;
                }

               case Native_com_sun_squawk_NativeUnsafe_getAsUWord:
                    if (TYPEMAP) {
                        int     off = popInt();
                        Address base = popAddress();
                        pushWord(getUWordTyped(base, off, AddressType_ANY));
                        break;
                    } else {
                         /* fall-through... */
                    }
               case Native_com_sun_squawk_NativeUnsafe_getUWord: {
                    int     off = popInt();
                    Address base = popAddress();
                    pushWord(getUWord(base, off));
                    break;
                }

               case Native_com_sun_squawk_NativeUnsafe_getAsInt:
                    if (TYPEMAP) {
                        int     off = popInt();
                        Address base = popAddress();
                        pushInt(getIntTyped(base, off, AddressType_ANY));
                        break;
                    } else {
                         /* fall-through... */
                    }
                case Native_com_sun_squawk_NativeUnsafe_getInt: {
                    int     off = popInt();
                    Address base = popAddress();
                    pushInt(getInt(base, off));
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_getUnalignedInt: {
                    int     byte_off = popInt();
                    Address base = popAddress();
                    pushInt(getUnalignedInt(base, byte_off));
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_getUnalignedLong: {
                    int     byte_off = popInt();
                    Address base = popAddress();
                    pushLong(getUnalignedLong(base, byte_off));
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_getUnalignedShort: {
                    int     byte_off = popInt();
                    Address base = popAddress();
                    pushInt(getUnalignedShort(base, byte_off));
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_malloc: {
                    int     size = popWord();
                    pushAddress(malloc(size));
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_free: {
                    Address base = popAddress();
                    free(base);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_setAddress: {
                    Address val = popAddress();
                    int     off = popInt();
                    Address base = popAddress();
                    setObject(base,  off, val);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_setObject: {
                    Address val = popAddress();
                    int     off = popInt();
                    Address base = popAddress();
                    setObjectAndUpdateWriteBarrier(base,  off, val);
                    break;
                }
                
                case Native_com_sun_squawk_NativeUnsafe_setInt: {
                    int     val = popInt();
                    int     off = popInt();
                    Address base = popAddress();
                    setInt(base,  off, val);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_setUWord: {
                    UWord    val = popWord();
                    int     off = popInt();
                    Address base = popAddress();
                    setUWord(base,  off, val);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_getLong: {
                    int     off = popInt();
                    Address base = popAddress();
                    pushLong(getLong(base, off));
                    break;
                }
               
                case Native_com_sun_squawk_NativeUnsafe_setLong: {
                    jlong   val = popLong();
                    int     off = popInt();
                    Address base = popAddress();
                    setLong(base,  off, val);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_getLongAtWord: {
                    int     off = popInt();
                    Address base = popAddress();
                    pushLong(getLongAtWord(base, off));
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_setLongAtWord: {
                    jlong   val = popLong();
                    int     off = popInt();
                    Address base = popAddress();
                    setLongAtWord(base,  off, val);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_setUnalignedShort: {
                    int     val = popInt();
                    int     byte_off = popInt();
                    Address base = popAddress();
                    setUnalignedShort(base, byte_off, val);
                    break;
                }
                
                case Native_com_sun_squawk_NativeUnsafe_setUnalignedInt: {
                    int     val = popInt();
                    int     byte_off = popInt();
                    Address base = popAddress();
                    setUnalignedInt(base, byte_off, val);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_setUnalignedLong: {
                    jlong   val = popLong();
                    int     byte_off = popInt();
                    Address base = popAddress();
                    setUnalignedLong(base, byte_off, val);
                    break;
                }
               
                case Native_com_sun_squawk_NativeUnsafe_swap: {
                    int dataSize = popInt();
                    Address address = popAddress();
                    swap(address, dataSize);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_swap2: {
                    Address address = popAddress();
                    swap2(address);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_swap4: {
                    Address address = popAddress();
                    swap4(address);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_swap8: {
                    Address address = popAddress();
                    swap8(address);
                    break;
                }

/* DO WE WANT TO SUPPORT NATIVEUNSAFE_CALLS IN BARE_METAL SYSTEMS???? */
                case Native_com_sun_squawk_NativeUnsafe_call0: {
                    Address address = popAddress();
                    funcPtr0 fptr = (funcPtr0)address;
                    int result;
                    checkNativeCall(fptr);
                    result = (*fptr)();
                    set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
                    endCheckNativeCall();
                    pushInt(result);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_call1: {
                    int i1 = popInt();
                    Address address = popAddress();
                    funcPtr1 fptr = (funcPtr1)address;
                    int result;
                    checkNativeCall(fptr);
                    result = (*fptr)(i1);
                    set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
                    endCheckNativeCall();
                    pushInt(result);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_call2: {
                    int i2 = popInt();
                    int i1 = popInt();
                    Address address = popAddress();
                    funcPtr2 fptr = (funcPtr2)address;
                    int result;
                    checkNativeCall(fptr);
                    result = (*fptr)(i1, i2);
                    set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
                    endCheckNativeCall();
                    pushInt(result);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_call3: {
                    int i3 = popInt();
                    int i2 = popInt();
                    int i1 = popInt();
                    Address address = popAddress();
                    funcPtr3 fptr = (funcPtr3)address;
                    int result;
                    checkNativeCall(fptr);
                    result = (*fptr)(i1, i2, i3);
                    set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
                    endCheckNativeCall();
                    pushInt(result);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_call4: {
                    int i4 = popInt();
                    int i3 = popInt();
                    int i2 = popInt();
                    int i1 = popInt();
                    Address address = popAddress();
                    funcPtr4 fptr = (funcPtr4)address;
                    int result;
                    checkNativeCall(fptr);
                    result = (*fptr)(i1, i2, i3, i4);
                    set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
                    endCheckNativeCall();
                    pushInt(result);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_call5: {
                    int i5 = popInt();
                    int i4 = popInt();
                    int i3 = popInt();
                    int i2 = popInt();
                    int i1 = popInt();
                    Address address = popAddress();
                    funcPtr5 fptr = (funcPtr5)address;
                    int result;
                    checkNativeCall(fptr);
                    result = (*fptr)(i1, i2, i3, i4, i5);
                    set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
                    endCheckNativeCall();
                    pushInt(result);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_call6: {
                    int i6 = popInt();
                    int i5 = popInt();
                    int i4 = popInt();
                    int i3 = popInt();
                    int i2 = popInt();
                    int i1 = popInt();
                    Address address = popAddress();
                    funcPtr6 fptr = (funcPtr6)address;
                    int result;
                    checkNativeCall(fptr);
                    result = (*fptr)(i1, i2, i3, i4, i5, i6);
                    set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
                    endCheckNativeCall();
                    pushInt(result);
                    break;
                }

                /* yes, jump straight to 10... */
                case Native_com_sun_squawk_NativeUnsafe_call10: {
                    int i10 = popInt();
                    int i9 = popInt();
                    int i8 = popInt();
                    int i7 = popInt();
                    int i6 = popInt();
                    int i5 = popInt();
                    int i4 = popInt();
                    int i3 = popInt();
                    int i2 = popInt();
                    int i1 = popInt();
                    Address address = popAddress();
                    funcPtr10 fptr = (funcPtr10)address;
                    int result;
                    checkNativeCall(fptr);
                    result = (*fptr)(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
                    set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
                    endCheckNativeCall();
                    pushInt(result);
                    break;
                }

                /* BARE_METAL platforms don't support native threads, so can't support TaskExecutors */
/*if[!PLATFORM_TYPE_BARE_METAL]*/
                case Native_com_sun_squawk_NativeUnsafe_createTaskExecutor: {
                    int stacksize = popInt();
                    int priority = popInt();
                    Address nameAddr = popAddress();
                    char* name = (char*)nameAddr;
                    Address result;
                    result = createTaskExecutor(name, priority, stacksize);
                    pushAddress(result);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_cancelTaskExecutor: {
                    TaskExecutor* te = (TaskExecutor*)popAddress();
                    cancelTaskExecutor(te);
                    pushInt(0);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_deleteTaskExecutor: {
                    TaskExecutor* te = (TaskExecutor*)popAddress();
                    pushInt(deleteTaskExecutor(te));
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_deleteNativeTask: {
                    NativeTask* ntask = (NativeTask*)popAddress();
                    deleteNativeTask(ntask);
                    pushInt(0);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_runBlockingFunctionOn: {
                    int i10 = popInt();
                    int i9 = popInt();
                    int i8 = popInt();
                    int i7 = popInt();
                    int i6 = popInt();
                    int i5 = popInt();
                    int i4 = popInt();
                    int i3 = popInt();
                    int i2 = popInt();
                    int i1 = popInt();
                    Address address = popAddress();
                    funcPtr10 fptr = (funcPtr10)address;
                    Address te = popAddress();
                    Address result;
                    result = runBlockingFunctionOn(te, fptr, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
                    pushAddress(result);
                    break;
                }
/*end[PLATFORM_TYPE_BARE_METAL]*/
                
                case Native_com_sun_squawk_Address_add: {
                    int offset = popInt();
                    Address addr = popAddress();
                    pushAddress(Address_add(addr, offset));
                    break;
                }

                case Native_com_sun_squawk_Address_addOffset: {
                    Offset offset = popWord();
                    Address addr = popAddress();
                    pushAddress(Address_add(addr, offset));
                    break;
                }

                case Native_com_sun_squawk_Address_sub: {
                    int offset = popInt();
                    Address addr = popAddress();
                    pushAddress(Address_sub(addr, offset));
                    break;
                }

                case Native_com_sun_squawk_Address_subOffset: {
                    Offset offset = popWord();
                    Address addr = popAddress();
                    pushAddress(Address_sub(addr, offset));
                    break;
                }

                case Native_com_sun_squawk_Address_and: {
                    UWord word = popWord();
                    UWord addr = (UWord)popAddress();
                    pushAddress((Address)(addr & word));
                    break;
                }

                case Native_com_sun_squawk_Address_or: {
                    UWord word = popWord();
                    UWord addr = (UWord)popAddress();
                    pushAddress((Address)(addr | word));
                    break;
                }

                case Native_com_sun_squawk_Address_diff: {
                    Address addr2 = popAddress();
                    Address addr1 = popAddress();
                    pushWord(Address_diff(addr1, addr2));
                    break;
                }

                case Native_com_sun_squawk_Address_roundUp: {
                    int alignment = popInt();
                    UWord addr = (UWord)popAddress();
                    pushAddress((Address)roundUp(addr, alignment));
                    break;
                }

                case Native_com_sun_squawk_Address_roundUpToWord: {
                    UWord addr = (UWord)popAddress();
                    pushAddress((Address)roundUpToWord(addr));
                    break;
                }

                case Native_com_sun_squawk_Address_roundDown: {
                    int alignment = popInt();
                    UWord addr = (UWord)popAddress();
                    pushAddress((Address)roundDown(addr, alignment));
                    break;
                }

                case Native_com_sun_squawk_Address_roundDownToWord: {
                    UWord addr = (UWord)popAddress();
                    pushAddress((Address)roundDownToWord(addr));
                    break;
                }

                case Native_com_sun_squawk_Address_isZero: {
                    Address addr = popAddress();
                    pushInt(addr == 0);
                    break;
                }

                case Native_com_sun_squawk_Address_isMax: {
                    Address addr = popAddress();
                    pushInt(addr == ADDRESS_MAX);
                    break;
                }

                case Native_com_sun_squawk_Address_zero: {
                    pushAddress(0);
                    break;
                }

                case Native_com_sun_squawk_Address_max: {
                    pushAddress(ADDRESS_MAX);
                    break;
                }

                case Native_com_sun_squawk_Address_toUWord: {
                    if (TYPEMAP) {
                        Address value = popAddress();
                        pushWord((UWord)value);
                    }
                    break;
                }

                case Native_com_sun_squawk_Address_toObject:
                case Native_com_sun_squawk_Address_fromObject: {
                    break;
                }

                case Native_com_sun_squawk_Address_eq: {
                    Address addr2 = popAddress();
                    Address addr1 = popAddress();
                    pushInt(addr1 == addr2);
                    break;
                }

                case Native_com_sun_squawk_Address_ne: {
                    Address addr2 = popAddress();
                    Address addr1 = popAddress();
                    pushInt(addr1 != addr2);
                    break;
                }

                case Native_com_sun_squawk_Address_lo: {
                    Address addr2 = popAddress();
                    Address addr1 = popAddress();
                    pushInt(lo(addr1, addr2));
                    break;
                }

                case Native_com_sun_squawk_Address_loeq: {
                    Address addr2 = popAddress();
                    Address addr1 = popAddress();
                    pushInt(loeq(addr1, addr2));
                    break;
                }

                case Native_com_sun_squawk_Address_hi: {
                    Address addr2 = popAddress();
                    Address addr1 = popAddress();
                    pushInt(hi(addr1, addr2));
                    break;
                }

                case Native_com_sun_squawk_Address_hieq: {
                    Address addr2 = popAddress();
                    Address addr1 = popAddress();
                    pushInt(hieq(addr1, addr2));
                    break;
                }

/*if[TYPEMAP]*/
                case Native_com_sun_squawk_NativeUnsafe_setType: {
                    int size = popInt();
                    char type = (char)popInt();
                    Address ea = popAddress();
                    setType(ea, type, size);
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_setArrayTypes: {
                    int length = popInt();
                    int componentSize = popInt();
                    char componentType = (char)popInt();
                    Address ea = popAddress();
                    while (length-- != 0) {
                        setType(ea, componentType, componentSize);
                        ea = Address_add(ea, componentSize);
                    }
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_getType: {
                    Address ea = popAddress();
                    pushInt(getType(ea));
                    break;
                }

                case Native_com_sun_squawk_NativeUnsafe_copyTypes: {
                    int length = popInt();
                    Address dst = popAddress();
                    Address src = popAddress();
                    copyTypes(src, dst, length);
                    break;
                }
/*end[TYPEMAP]*/

                case Native_com_sun_squawk_VM_allocate: {
                    int     alth   = popInt();
                    Address klass  = popAddress();
                    int     size   = popInt();
                    Address res    = allocate(size, klass, alth);
                    pushAddress(res);
                    break;
                }

				/* static void copyBytes(Object src, int srcPos, Object dst, int dstPos, int length, boolean nvmDst);*/
                case Native_com_sun_squawk_VM_copyBytes: {
                    int     nvmDst   = popInt();
                    int     length   = popInt();
                    int     dstPos   = popInt();
                    Address dst      = popAddress();
                    int     srcPos   = popInt();
                    Address src      = popAddress();
                    assumeInterp(src != NULL);
                    assumeInterp(dst != NULL);
                    assumeInterp(srcPos >= 0);
                    assumeInterp(dstPos >= 0);
                    assumeInterp(length >= 0);
                    copyBytes(src, srcPos, dst, dstPos, length, nvmDst);
                    break;
                }

				/* static void setBytes(Address src, byte value, int length); */
                case Native_com_sun_squawk_VM_setBytes: {
                    int     length   = popInt();
                    int     value    = popInt();
                    Address dst      = popAddress();
                    assumeInterp(dst != NULL);
                    assumeInterp(length >= 0);
                    memset(dst, value, length);
                    break;
                }

                case Native_com_sun_squawk_VM_zeroWords: {
                    UWordAddress end   = (UWordAddress)popAddress();
                    UWordAddress start = (UWordAddress)popAddress();
                    zeroWords(start, end);
                    break;
                }

                case Native_com_sun_squawk_VM_deadbeef: {
                    UWordAddress end   = (UWordAddress)popAddress();
                    UWordAddress start = (UWordAddress)popAddress();
                    if (ASSUME || TYPEMAP) {
                        while (start < end) {
                            if (ASSUME) {
                                *start = DEADBEEF;
                            }
                            setType(start, AddressType_UNDEFINED, HDR_BYTES_PER_WORD);
                            start++;
                        }
                    }
                    break;
                }

                case Native_com_sun_squawk_VM_getFP: {
                    pushAddress(fp);
                    break;
                }

                case Native_com_sun_squawk_VM_getMP: {
                    Address afp = popAddress();
                    pushAddress(getObject(afp, FP_method));
                    break;
                }

                case Native_com_sun_squawk_VM_getPreviousFP: {
                    Address afp = popAddress();
                    pushAddress(getObject(afp, FP_returnFP));
                    break;
                }

                case Native_com_sun_squawk_VM_getPreviousIP: {
                    Address afp = popAddress();
                    pushAddress(getObject(afp, FP_returnIP));
                    break;
                }

                case Native_com_sun_squawk_VM_setPreviousFP: {
                    Address pfp = popAddress();
                    Address afp = popAddress();
                    setObject(afp, FP_returnFP, pfp);
                    break;
                }

                case Native_com_sun_squawk_VM_setPreviousIP: {
                    Address pip = popAddress();
                    Address afp = popAddress();
                    assumeInterp(inCode(ip));
                    setObject(afp, FP_returnIP, pip);
                    break;
                }

                case Native_com_sun_squawk_VM_getGlobalOopCount: {
                    pushInt(GLOBAL_OOP_COUNT);
                    break;
                }

                case Native_com_sun_squawk_VM_getGlobalInt: {
                    int index = popInt();
                    assumeInterp(index < GLOBAL_INT_COUNT);
                    pushInt(Ints[index]);
                    break;
                }

                case Native_com_sun_squawk_VM_getGlobalAddr: {
                    int index = popInt();
                    assumeInterp(index < GLOBAL_ADDR_COUNT);
                    pushAddress(Addrs[index]);
                    break;
                }

                case Native_com_sun_squawk_VM_getGlobalOop: {
                    int index = popInt();
                    assumeInterp(index < GLOBAL_OOP_COUNT);
                    pushAddress(Oops[index]);
                    break;
                }

                case Native_com_sun_squawk_VM_getGlobalOopTable: {
                    pushAddress(Oops);
                    break;
                }

                case Native_com_sun_squawk_VM_setGlobalInt: {
                    int index  = popInt();
                    int value = popInt();
                    assumeInterp(index < GLOBAL_INT_COUNT);
                    Ints[index] = (int)value;
                    break;
                }

                case Native_com_sun_squawk_VM_setGlobalAddr: {
                    int index  = popInt();
                    Address value = popAddress();
                    assumeInterp(index < GLOBAL_ADDR_COUNT);
                    Addrs[index] = value;
                    break;
                }

                case Native_com_sun_squawk_VM_setGlobalOop: {
                    int index  = popInt();
                    Address value = popAddress();
                    assumeInterp(index < GLOBAL_OOP_COUNT);
                    Oops[index] = value;
                    break;
                }

                case Native_com_sun_squawk_VM_lcmp: {
                    call(com_sun_squawk_VM__lcmp);
                    break;
                }

                case Native_com_sun_squawk_VM_callStaticNoParm: {
                    int     slot = popInt();
                    Address cls  = popAddress();
                    call(getStaticMethod(cls, slot));
                    break;
                }

                case Native_com_sun_squawk_VM_callStaticOneParm: {
                    Address parm = popAddress();
                    int     slot = popInt();
                    Address cls  = popAddress();
                    pushAddress(parm);
                    call(getStaticMethod(cls, slot));
                    break;
                }

/*if[TYPEMAP]*/
                case Native_com_sun_squawk_VM_hashcode: {
                    pushInt((int)popAddress());
                    break;
                }
                case Native_com_sun_squawk_VM_asKlass: {
                    break;
                }
/*else[TYPEMAP]*/
//                case Native_com_sun_squawk_VM_hashcode:
//                case Native_com_sun_squawk_VM_asKlass: {
//                    break;
//                }
/*end[TYPEMAP]*/

                case Native_com_sun_squawk_VM_fatalVMError: {
                    fatalInterpreterError("VM.fatalVMError");
                    break;
                }

                case Native_com_sun_squawk_VM_getBranchCount: {
                    pushLong(getBranchCount());
                    break;
                }

/*if[FINALIZATION]*/
               case Native_com_sun_squawk_VM_finalize: {
                    iparm = MethodOffsets_virtual_java_lang_Object_finalize;
                    do_invokevirtual();
                    break;
                }
/*end[FINALIZATION]*/

/*if[KERNEL_SQUAWK]*/
                case Native_com_sun_squawk_VM_isInKernel: {
                    pushInt(inKernelMode());
                    break;
                }
/*end[KERNEL_SQUAWK]*/

                case Native_com_sun_squawk_VM_threadSwitch: {
                    if (com_sun_squawk_VMThread_currentThread !=
                        com_sun_squawk_VMThread_otherThread) { /* this actually happens in tight producer/consumer loops */
                        threadSwitch(com_sun_squawk_ServiceOperation_NONE);
                    }
                    break;
                }

                case Native_com_sun_squawk_VM_executeCIO: {
                    Address o2  = popAddress();
                    Address o1  = popAddress();
                    int i6      = popInt();
                    int i5      = popInt();
                    int i4      = popInt();
                    int i3      = popInt();
                    int i2      = popInt();
                    int i1      = popInt();
                    int channel = popInt();
                    int op      = popInt();
                    int context = popInt();
                    executeCIO(context, op, channel, i1, i2, i3, i4, i5, i6, o1, o2);
                    break;
                }

				case Native_com_sun_squawk_VM_jnaPrint: {
                	Address fn  = popAddress();
                	void jnaPrint(Address fn);
                	jnaPrint(fn);
                	break;
                }
                
                
                
                
                
               
                
               
                
                
                
                
                
                case Native_com_sun_squawk_VM_jnaSendAckByte: {
					char data = (char) popInt();
                	void jnaSendAckByte(char data);
                	jnaSendAckByte(data);
                	break;
                }
                
               
                
                case Native_com_sun_squawk_VM_jnaSendSpeedPwmData: {
                	int speed = popInt();
                	void jnaSendSpeedPwmData(int speed);
                	jnaSendSpeedPwmData(speed);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaSendSteerPwmData: {
                	int servo  = popInt();
                	void jnaSendSteerPwmData(int servo);
                	jnaSendSteerPwmData(servo);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaFetchAdcData: {
                	long jnaFetchAdcData();
                	jlong res = jnaFetchAdcData();
					pushLong(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaFetchFrontWheelSpeed: {
                	int jnaFetchFrontWheelSpeed();
                	int res = jnaFetchFrontWheelSpeed();
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaFetchBackWheelSpeed: {
                	int jnaFetchBackWheelSpeed();
                	int res = jnaFetchBackWheelSpeed();
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaSendPackageData: {
                	Address data  = popAddress();
                	int size = popInt();
                	void jnaSendPackageData(int size, Address data);
                	jnaSendPackageData(size, data);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaFetchNewData: {
                	int rearSign = popInt();
                	int startSign = popInt();
                	Address jnaFetchNewData(int startSign, int rearSign);
                	Address res = jnaFetchNewData(startSign, rearSign);
                	pushAddress(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaCheckIfNewPackage: {
                	int jnaCheckIfNewPackage();
                	int res = jnaCheckIfNewPackage();
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaGetLengthPackage: {
                	int jnaGetLengthPackage();
                	int res = jnaGetLengthPackage();
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaGetReadStartIndex: {
                	int jnaGetReadStartIndex();
                	int res = jnaGetReadStartIndex();
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaGetReadRearIndex: {
                	int jnaGetReadRearIndex();
                	int res = jnaGetReadRearIndex();
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaFetchByte: {
                	int rearIndex = popInt();
                	char jnaFetchByte(int rearIndex);
                	char res = jnaFetchByte(rearIndex);
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaReadPosition: {
                	jlong jnaReadPosition();
                	jlong res = jnaReadPosition();
                	pushLong(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaReadUltrasonicData: {
                	int jnaReadUltrasonicData();
                	int res = jnaReadUltrasonicData();
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaWritePluginData2VCU: {
                	Address data  = popAddress();
                	int size = popInt();
                	void jnaWritePluginData2VCU(int size, Address data);
                	jnaWritePluginData2VCU(size, data);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaReadPluginDataSizeFromSCU: {
                	int jnaReadPluginDataSizeFromSCU();
                	int res = jnaReadPluginDataSizeFromSCU();
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaReadPluginDataByteFromSCU: {
                	int index = popInt();
                	char jnaReadPluginDataByteFromSCU(int index);
                	char res = jnaReadPluginDataByteFromSCU(index);
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaResetPluginDataSizeFromSCU: {
                	void jnaResetPluginDataSizeFromSCU();
                	jnaResetPluginDataSizeFromSCU();
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaReadIMUPart1: {
                	jlong jnaReadIMUPart1();
                	jlong res = jnaReadIMUPart1();
                	pushLong(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaReadIMUPart2: {
                	jlong jnaReadIMUPart2();
                	jlong res = jnaReadIMUPart2();
                	pushLong(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaSetLED: {
                	int val = popInt();
                	int pin = popInt();
                	void jnaSetLED(int pin, int val);
                	jnaSetLED(pin, val);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaFetchSpeedFromPirte: {
                	int jnaFetchSpeedFromPirte();
                	int res = jnaFetchSpeedFromPirte();
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaFetchSteerFromPirte: {
                	int jnaFetchSteerFromPirte();
                	int res = jnaFetchSteerFromPirte();
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaReadPluginDataSizeFromTCU: {
                	int jnaReadPluginDataSizeFromTCU();
                	int res = jnaReadPluginDataSizeFromTCU();
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaReadPluginDataByteFromTCU: {
                	int index = popInt();
                	char jnaReadPluginDataByteFromTCU(int index);
                	char res = jnaReadPluginDataByteFromTCU(index);
                	pushInt(res);
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaResetPluginDataSizeFromTCU: {
                	void jnaResetPluginDataSizeFromTCU();
                	jnaResetPluginDataSizeFromTCU();
                	break;
                }
                
                case Native_com_sun_squawk_VM_jnaSetSelect: {
                	int selector = popInt();
                	void jnaSetSelect(int selector);
                	jnaSetSelect(selector);
                	break;
                }
                
/*if[ENABLE_ISOLATE_MIGRATION]*/
                case Native_com_sun_squawk_VM_executeCOG: {
                    Address o2  = popAddress();
                    Address o1  = popAddress();
                    com_sun_squawk_ServiceOperation_o1 = o1;
                    com_sun_squawk_ServiceOperation_o2 = o2;
 if (TRACE) {
                    printStackTracePrim(-1, ip, fp, "COPY_OBJECT_GRAPH", null);
                }
                    threadSwitchFor(com_sun_squawk_ServiceOperation_COPY_OBJECT_GRAPH);
                    break;
                }
/*end[ENABLE_ISOLATE_MIGRATION]*/

                case Native_com_sun_squawk_VM_executeGC: {
                    boolean forceFullGC = popInt();
                    com_sun_squawk_ServiceOperation_i1 = forceFullGC;
 if (TRACE) {
                    printStackTracePrim(-1, ip, fp, "GARBAGE_COLLECT", null);
                }
                    threadSwitchFor(com_sun_squawk_ServiceOperation_GARBAGE_COLLECT);
                    break;
                }

                case Native_com_sun_squawk_VM_serviceResult: {
                    int res = com_sun_squawk_ServiceOperation_result;
                    com_sun_squawk_ServiceOperation_result = 0xDEADBEEF;
                    pushInt(res);
                    break;
                }

                case Native_com_sun_squawk_VM_addressResult: {
                    Address res = com_sun_squawk_ServiceOperation_addressResult;
                    com_sun_squawk_ServiceOperation_addressResult = null;
                    pushAddress(res);
                    break;
                }

                case Native_com_sun_squawk_ServiceOperation_cioExecute: {
                    void cioExecute(void);
                    cioExecute();
                    break;
                }

                case Native_com_sun_squawk_VM_isBigEndian: {
                    pushInt(PLATFORM_BIG_ENDIAN);
                    break;
                }

/*if[GC_com.sun.squawk.CheneyCollector]*/
                case Native_com_sun_squawk_CheneyCollector_memoryProtect: {
                    cheneyEndMemoryProtect   = popAddress();
                    cheneyStartMemoryProtect = popAddress();
/*fprintf(stderr, "*** cheneyStartMemoryProtect=%d, cheneyEndMemoryProtect=%d\n", cheneyStartMemoryProtect, cheneyEndMemoryProtect);*/
                    break;
                }
/*end[GC_com.sun.squawk.CheneyCollector]*/

                case Native_com_sun_squawk_VM_addToClassStateCache: {
                    Address state = popAddress();
                    Address klass = popAddress();
                    addClassState(klass, state);
                    break;
                }

                case Native_com_sun_squawk_VM_invalidateClassStateCache: {
                    pushInt(invalidateClassStateCache());
                    break;
                }

                case Native_com_sun_squawk_VM_removeVirtualMonitorObject: {
                    Address res = null;
		    
                    if (pendingMonitorStackPointer > 0) {
                        res = pendingMonitors[--pendingMonitorStackPointer];
                        pendingMonitors[pendingMonitorStackPointer] = null;
                    }
                    pushAddress(res);
                    break;
                }

                case Native_com_sun_squawk_VM_hasVirtualMonitorObject: {
                    Address obj = popAddress();
                    boolean res = false;
                    int i;
                    for (i = 0 ; i < pendingMonitorStackPointer ; i++) {
                        if (pendingMonitors[i] == obj) {
                            res = true;
                            break;
                        }
                    }
                    pushInt(res);
                    break;
                }

/*if[FLOATS]*/
                case Native_com_sun_squawk_VM_doubleToLongBits:
                case Native_com_sun_squawk_VM_floatToIntBits:
                case Native_com_sun_squawk_VM_longBitsToDouble:
                case Native_com_sun_squawk_VM_intBitsToFloat: {
                    /* simply leave bits on the stack: */
                    break;
                }

                case Native_com_sun_squawk_VM_math: {
                    jlong value2 = popLong();
                    jlong value1 = popLong();
                    int op = popInt();
                    jlong res = math(op, value1, value2);
                    pushLong(res);
                    break;
                }
/*end[FLOATS]*/

/*if[GC2C]*/
                case Native_com_sun_squawk_GarbageCollector_hasNativeImplementation: {
                    pushInt(true);
                    break;
                }

                case Native_com_sun_squawk_GarbageCollector_collectGarbageInC: {
                    int forceFullGC = popInt();
                    Address allocTop = popAddress();
                    Address collector = popAddress();
                    pushInt(collectGarbage(collector, allocTop, forceFullGC));
                    break;
                }

/*else[GC2C]*/
//              case Native_com_sun_squawk_GarbageCollector_hasNativeImplementation: {
//                  pushInt(false);
//                  break;
//              }
/*end[GC2C]*/

/*if[GC2C]*/
/*if[ENABLE_ISOLATE_MIGRATION]*/
                case Native_com_sun_squawk_GarbageCollector_copyObjectGraphInC: {
                    Address allocTop = popAddress();
                    Address cb = popAddress();
                    Address object = popAddress();
                    Address collector = popAddress();
                    pushAddress(copyObjectGraph(collector, object, cb, allocTop));
                    break;
                }
/*end[ENABLE_ISOLATE_MIGRATION]*/
/*end[GC2C]*/

/*if[LISP2_BITMAP]*/
                case Native_com_sun_squawk_Lisp2Bitmap_clearBitFor: {
                    Address ea = popAddress();
                    clearBitFor(ea);
                    break;
                }

                case Native_com_sun_squawk_Lisp2Bitmap_setBitsFor: {
                    Address end = popAddress();
                    Address start = popAddress();
                    setBitsFor(start, end);
                    break;
                }

                case Native_com_sun_squawk_Lisp2Bitmap_clearBitsFor: {
                    Address end = popAddress();
                    Address start = popAddress();
                    clearBitsFor(start, end);
                    break;
                }

                case Native_com_sun_squawk_Lisp2Bitmap_getAddressForBitmapWord: {
                    Address bitmapWordAddress = popAddress();
                    pushAddress(getAddressForBitmapWord(bitmapWordAddress));
                    break;
                }

                case Native_com_sun_squawk_Lisp2Bitmap_getAddressOfBitmapWordFor: {
                    Address ea = popAddress();
                    pushAddress(getAddressOfBitmapWordFor(ea));
                    break;
                }

                case Native_com_sun_squawk_Lisp2Bitmap_setBitFor: {
                    Address ea = popAddress();
                    setBitFor(ea);
                    break;
                }

                case Native_com_sun_squawk_Lisp2Bitmap_testAndSetBitFor: {
                    Address ea = popAddress();
                    pushInt(testAndSetBitFor(ea));
                    break;
                }

                case Native_com_sun_squawk_Lisp2Bitmap_testBitFor: {
                    Address ea = popAddress();
                    pushInt(testBitFor(ea));
                    break;
                }

                case Native_com_sun_squawk_Lisp2Bitmap_initialize: {
                    Address objectMemoryStart = popAddress();
                    int size = popInt();
                    Address start = popAddress();
                    bitmapInitialize(start, size, objectMemoryStart);
                    break;
                }

                case Native_com_sun_squawk_Lisp2Bitmap_iterate: {
                    pushAddress(bitmapIterate());
                    break;
                }

/*end[LISP2_BITMAP]*/

/*if[KERNEL_SQUAWK]*/
                case Native_com_sun_squawk_VM_sendInterrupt: {
                    int interrupt = popInt();
                    void os_sendInterrupt(int);
                    os_sendInterrupt(interrupt);
                    break;
                }

                case Native_com_sun_squawk_VM_setupInterrupt: {
                    Address handler = popAddress();
                    int interrupt = popInt();
                    void os_setupInterrupt(int, Address);
                    os_setupInterrupt(interrupt, handler);
                    break;
                }

                case Native_com_sun_squawk_VM_setupAlarmInterval: {
                    int period = popInt();
                    int start = popInt();
                    void os_setupAlarmInterval(int, int);
                    os_setupAlarmInterval(start, period);
                    break;
                }

                case Native_com_sun_squawk_VM_getInterruptStatus: {
                    int id = popInt();
                    int interrupt = popInt();
                    jlong os_getInterruptStatus(int, int);
                    pushLong(os_getInterruptStatus(interrupt, id));
                    break;
                }
/*end[KERNEL_SQUAWK]*/

                default: {
                    /*fprintf(stderr, "*** Undefined native method: *** %d\n", iparm);*/
                    pushInt(iparm);
                    call(com_sun_squawk_VM_undefinedNativeMethod);
                    break;
                }
            }
        }

        /**
         * invokenative.
         *
         * Java Stack: [[... arg2], arg1] -> [VALUE]
         * <p>
         */
/*MAC*/ void do_invokenative() {
/*if[MACROIZE]*/
            goto invokenativestart;
/*else[MACROIZE]*/
//          invokenativemain();
/*end[MACROIZE]*/
        }

        /*-----------------------------------------------------------------------*\
         *                             ALU instructions                          *
        \*-----------------------------------------------------------------------*/

        /**
         * Adds two integer values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1+VALUE2
         * <p>
         */
/*MAC*/ void do_add_i() {
            if (NOSILLYADDBUG) {
                int r = popInt();
                int l = popInt();
                pushInt(l+r);
            }
        }

        /**
         * Adds long integer values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1+VALUE2
         * <p>
         */
/*MAC*/ void do_add_l() {
            jlong r = popLong();
            jlong l = popLong();
            pushLong(l+r);
        }

/*if[FLOATS]*/
        /**
         * Adds two float values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1+VALUE2
         * <p>
         */
/*MAC*/ void do_add_f() {
            int r = popInt();
            int l = popInt();
            pushInt(addf(l, r));
        }

        /**
         * Adds two double values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1+VALUE2
         * <p>
         */
/*MAC*/ void do_add_d() {
            jlong r = popLong();
            jlong l = popLong();
            pushLong(addd(l, r));
        }
/*end[FLOATS]*/

        /**
         * Subtracts two integer values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1-VALUE2
         * <p>
         */
/*MAC*/ void do_sub_i() {
            int r = popInt();
            int l = popInt();
            pushInt(l-r);
        }

        /**
         * Subtracts two long values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1-VALUE2
         * <p>
         */
/*MAC*/ void do_sub_l() {
            jlong r = popLong();
            jlong l = popLong();
            pushLong(l-r);
        }

/*if[FLOATS]*/
        /**
         * Subtracts two floats values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1-VALUE2
         * <p>
         */
/*MAC*/ void do_sub_f() {
            int r = popInt();
            int l = popInt();
            pushInt(subf(l, r));
        }

        /**
         * Subtracts two double values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1-VALUE2
         * <p>
         */
/*MAC*/ void do_sub_d() {
            jlong r = popLong();
            jlong l = popLong();
            pushLong(subd(l, r));
        }
/*end[FLOATS]*/

        /**
         * Logically ANDs two integer values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1&VALUE2
         * <p>
         */
/*MAC*/ void do_and_i() {
            int r = popInt();
            int l = popInt();
            pushInt(l&r);
        }

        /**
         * Logically ANDs two long values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1&VALUE2
         * <p>
         */
/*MAC*/ void do_and_l() {
            jlong r = popLong();
            jlong l = popLong();
            pushLong(l&r);
        }

        /**
         * Logically ORs two integer values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1|VALUE2
         * <p>
         */
/*MAC*/ void do_or_i() {
            int r = popInt();
            int l = popInt();
            pushInt(l|r);
        }

        /**
         * Logically ORs two long values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1|VALUE2
         * <p>
         */
/*MAC*/ void do_or_l() {
            jlong r = popLong();
            jlong l = popLong();
            pushLong(l|r);
        }

        /**
         * Logically XORs two integer values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1^VALUE2
         * <p>
         */
/*MAC*/ void do_xor_i() {
            int r = popInt();
            int l = popInt();
            pushInt(l^r);
        }

        /**
         * Logically XORs two long values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1^VALUE2
         * <p>
         */
/*MAC*/ void do_xor_l() {
            jlong r = popLong();
            jlong l = popLong();
            pushLong(l^r);
        }

        /**
         * Signed left shifts an integer value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1<<(VALUE2&1f)
         * <p>
         */
/*MAC*/ void do_shl_i() {
            int r = popInt();
            int l = popInt();
            pushInt(sll(l, r));
        }

        /**
         * Signed left shifts a long value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1<<(VALUE2&1f)
         * <p>
         */
/*MAC*/ void do_shl_l() {
            int   r = popInt();
            jlong l = popLong();
            pushLong(slll(l, r));
        }

        /**
         * Right shifts an integer value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1>>(VALUE2&1f)
         * <p>
         */
/*MAC*/ void do_shr_i() {
            int r = popInt();
            int l = popInt();
            pushInt(sra(l, r));
        }

        /**
         * Right shifts a long value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1>>(VALUE2&1f)
         * <p>
         */
/*MAC*/ void do_shr_l() {
            int   r = popInt();
            jlong l = popLong();
            pushLong(sral(l, r));
        }

        /**
         * Unsigned right shifts an integer value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1>>>(VALUE2&1f)
         * <p>
         */
/*MAC*/ void do_ushr_i() {
            int r = popInt();
            int l = popInt();
            pushInt(srl(l, r));
        }

        /**
         * Unsigned right shifts a long value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1>>>(VALUE2&1f)
         * <p>
         */
/*MAC*/ void do_ushr_l() {
            int r = popInt();
            jlong l = popLong();
            pushLong(srll(l, r));
        }

        /**
         * Multiplies two values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1*VALUE2
         * <p>
         */
/*MAC*/ void do_mul_i() {
            int r = popInt();
            int l = popInt();
/*
if (l != 0 && r > (java_lang_Integer_MAX_VALUE/l)) {
    fatalInterpreterError("int mult overflow");
}
*/
            pushInt(l*r);
        }

        /**
         * Multiplies two values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1*VALUE2
         * <p>
         */
/*MAC*/ void do_mul_l() {
            jlong r = popLong();
            jlong l = popLong();
/*
if (l != 0 && r > (java_lang_Long_MAX_VALUE/l)) {
    fatalInterpreterError("int mult overflow");
}
*/
            pushLong(l*r);
        }

/*if[FLOATS]*/
        /**
         * Multiplies two values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1*VALUE2
         * <p>
         */
/*MAC*/ void do_mul_f() {
            int r = popInt();
            int l = popInt();
            pushInt(mulf(l, r));
        }

        /**
         * Multiplies two values.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1*VALUE2
         * <p>
         */
/*MAC*/ void do_mul_d() {
            jlong r = popLong();
            jlong l = popLong();
            pushLong(muld(l, r));
        }
/*end[FLOATS]*/

        /**
         * Divides a value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1/VALUE2
         * <p>
         */
/*MAC*/ void do_div_i() {
            int r = popInt();
            int l = popInt();
            checkReferenceSlots();
            if (r == 0) {
                resetStackPointerIfRevParms();
                call(com_sun_squawk_VM_arithmeticException);
            } else if (l == 0x80000000 && r == -1) {
                pushInt(l);
            } else {
                pushInt(l / r);
            }
        }

        /**
         * Divides a value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1/VALUE2
         * <p>
         */
/*MAC*/ void do_div_l() {
            jlong r = popLong();
            jlong l = popLong();
            checkReferenceSlots();
            if (r == 0) {
                resetStackPointerIfRevParms();
                call(com_sun_squawk_VM_arithmeticException);
/*if[SQUAWK_64]*/
            } else if (r == -1L && l == 0x8000000000000000L) {
                /*
                 * On the AMD64/gcc platform, a SIGFPE is generated when the dividend is
                 * the negative value of largest possible magnitude for the 'long' type
                 * and the divisor is -1. This in turn causes the following TCK test to fail:
                 *
                 *   javasoft/sqe/tests/vm/instr/ldiv/ldiv002/ldiv00201m1/ldiv00201m1
                 *
                 * The VM spec states (6.4 ldiv) that in this special case, the dividend is returned.
                 */
                pushLong(l);
/*end[SQUAWK_64]*/
            } else {
                pushLong(l / r);
            }
        }

/*if[FLOATS]*/
        /**
         * Divides a value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1/VALUE2
         * <p>
         */
/*MAC*/ void do_div_f() {
            int r = popInt();
            int l = popInt();
            pushInt(divf(l, r));
        }

        /**
         * Divides a value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1/VALUE2
         * <p>
         */
/*MAC*/ void do_div_d() {
            jlong r = popLong();
            jlong l = popLong();
            pushLong(divd(l, r));
        }
/*end[FLOATS]*/

        /**
         * Rem a value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1%VALUE2
         * <p>
         */
/*MAC*/ void do_rem_i() {
            int r = popInt();
            int l = popInt();
            checkReferenceSlots();
            if (r == 0) {
                resetStackPointerIfRevParms();
                call(com_sun_squawk_VM_arithmeticException);
            } else if (l == 0x80000000 && r == -1) {
                pushInt(l % 1);
            } else {
                pushInt(l % r);
            }
        }

        /**
         * Rem a value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1%VALUE2
         * <p>
         */
/*MAC*/ void do_rem_l() {
            jlong r = popLong();
            jlong l = popLong();
            checkReferenceSlots();
            if (r == 0) {
                resetStackPointerIfRevParms();
                call(com_sun_squawk_VM_arithmeticException);
/*if[SQUAWK_64]*/
            } else if (r == -1L && l == 0x8000000000000000L) {
                /*
                 * On the AMD64/gcc platform, a SIGFPE is generated when the dividend is
                 * the negative value of largest possible magnitude for the 'long' type
                 * and the divisor is -1. This in turns causes the following TCK test to fail:
                 *
                 *   javasoft/sqe/tests/vm/instr/lrem/lrem001/lrem00101m1
                 *
                 * The VM spec states (6.4 ldiv) that in this special case, 0 is returned.
                 */
                pushLong(0);
/*end[SQUAWK_64]*/
            } else {
                pushLong(l % r);
            }
        }

/*if[FLOATS]*/
        /**
         * Rem a value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1%VALUE2
         * <p>
         */
/*MAC*/ void do_rem_f() {
            int r = popInt();
            int l = popInt();
            pushInt(remf(l, r));
        }

        /**
         * Rem a value.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1%VALUE2
         * <p>
         */
/*MAC*/ void do_rem_d() {
            jlong r = popLong();
            jlong l = popLong();
            pushLong(remd(l, r));
        }
/*end[FLOATS]*/

        /**
         * Negates a value.
         *
         * <p>
         * Java Stack: ..., VALUE -> ..., -VALUE1
         * <p>
         */
/*MAC*/ void do_neg_i() {
            /*
             * Note: Due to a bug in the Solaris cc compiler when both
             *       -o3 and -mac are enabled, this was changed from:
             *
             *     int r = popInt();
             *     pushInt(0 - r);
             */
            int r = 0 - popInt();
            pushInt(r);
        }

        /**
         * Negates a value.
         *
         * <p>
         * Java Stack: ..., VALUE -> ..., -VALUE1
         * <p>
         */
/*MAC*/ void do_neg_l() {
            jlong r = 0 - popLong();
            pushLong(r);
        }

/*if[FLOATS]*/
        /**
         * Negates a value.
         *
         * <p>
         * Java Stack: ..., VALUE -> ..., -VALUE1
         * <p>
         */
/*MAC*/ void do_neg_f() {
            int r = popInt();
            pushInt(negf(r));
        }

        /**
         * Negates a value.
         *
         * <p>
         * Java Stack: ..., VALUE -> ..., -VALUE1
         * <p>
         */
/*MAC*/ void do_neg_d() {
            jlong r = popLong();
            pushLong(negd(r));
        }

       /**
         * Compare two floats.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., int
         * <p>
         */
/*MAC*/ void do_fcmpl() {
            float r = ib2f(popInt());
            float l = ib2f(popInt());
            int result = -1;

            if (l >  r) {
                result = 1;
            } else if (l == r) {
                result = 0;
            }

            pushInt(result);
        }

       /**
         * Compare two floats.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., int
         * <p>
         */
/*MAC*/ void do_fcmpg() {
            float r = ib2f(popInt());
            float l = ib2f(popInt());
            int result = 1;

            if (l <  r) {
                result = -1;
            } else if (l == r) {
                result = 0;
            }

            pushInt(result);
        }

       /**
         * Compare two doubles.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., int
         * <p>
         */
/*MAC*/ void do_dcmpl() {
            double r = lb2d(popLong());
            double l = lb2d(popLong());
            int result = -1;

            if (l > r) {
                result = 1;
             } else if (l == r) {
                result = 0;
            }

            pushInt(result);
        }

       /**
         * Compare two doubles.
         *
         * <p>
         * Java Stack: ..., VALUE1, VALUE2 -> ..., int
         * <p>
         */
/*MAC*/ void do_dcmpg() {
            double r = lb2d(popLong());
            double l = lb2d(popLong());
            int result = 1;

            if (l < r) {
                result = -1;
            } else if (l == r) {
                result = 0;
            }

            pushInt(result);
        }

/*end[FLOATS]*/


        /*-----------------------------------------------------------------------*\
         *                              Convertions                              *
        \*-----------------------------------------------------------------------*/

        /**
         * Convert int to byte.
         *
         * <p>
         * Java Stack: ..., INT -> ..., INT
         * <p>
         */
/*MAC*/ void do_i2b() {
            int r = popInt();
            pushInt((byte)r);
        }

        /**
         * Convert int to short.
         *
         * <p>
         * Java Stack: ..., INT -> ..., INT
         * <p>
         */
/*MAC*/ void do_i2s() {
            int r = popInt();
            pushInt((short)r);
        }

        /**
         * Convert int to char.
         *
         * <p>
         * Java Stack: ..., INT -> ..., INT
         * <p>
         */
/*MAC*/ void do_i2c() {
            int r = popInt();
            pushInt((unsigned short)r);
        }

        /**
         * Convert long to int.
         *
         * <p>
         * Java Stack: ..., LONG -> ..., INT
         * <p>
         */
/*MAC*/ void do_l2i() {
            jlong r = popLong();
            pushInt((int)r);
        }

        /**
         * Convert int to long.
         *
         * <p>
         * Java Stack: ..., INT -> ..., LONG
         * <p>
         */
/*MAC*/ void do_i2l() {
            int r = popInt();
            pushLong(r);
        }
/*if[FLOATS]*/
        /**
         * Convert int to float.
         *
         * <p>
         * Java Stack: ..., INT -> ..., FLOAT
         * <p>
         */
/*MAC*/ void do_i2f() {
            int r = popInt();
            pushInt(i2f(r));
        }

        /**
         * Convert long to float.
         *
         * <p>
         * Java Stack: ..., LONG -> ..., FLOAT
         * <p>
         */
/*MAC*/ void do_l2f() {
            jlong r = popLong();
            pushInt(l2f(r));
        }

        /**
         * Convert float to int.
         *
         * <p>
         * Java Stack: ..., FLOAT -> ..., INT
         * <p>
         */
/*MAC*/ void do_f2i() {
            int r = popInt();
            pushInt(f2i(r));
        }

        /**
         * Convert float to long.
         *
         * <p>
         * Java Stack: ..., FLOAT -> ..., LONG
         * <p>
         */
/*MAC*/ void do_f2l() {
            int r = popInt();
            pushLong(f2l(r));
        }

        /**
         * Convert int to double.
         *
         * <p>
         * Java Stack: ..., INT -> ..., DOUBLE
         * <p>
         */
/*MAC*/ void do_i2d() {
            int r = popInt();
            pushLong(i2d(r));
        }

        /**
         * Convert long to double.
         *
         * <p>
         * Java Stack: ..., LONG -> ..., DOUBLE
         * <p>
         */
/*MAC*/ void do_l2d() {
            jlong r = popLong();
            pushLong(l2d(r));
        }

        /**
         * Convert float to double.
         *
         * <p>
         * Java Stack: ..., FLOAT -> ..., DOUBLE
         * <p>
         */
/*MAC*/ void do_f2d() {
            int r = popInt();
            pushLong(f2d(r));
        }

        /**
         * Convert double to int.
         *
         * <p>
         * Java Stack: ..., DOUBLE -> ..., INT
         * <p>
         */
/*MAC*/ void do_d2i() {
            jlong r = popLong();
            pushInt(d2i(r));
        }

        /**
         * Convert double to long.
         *
         * <p>
         * Java Stack: ..., DOUBLE -> ..., LONG
         * <p>
         */
/*MAC*/ void do_d2l() {
            jlong r = popLong();
            pushLong(d2l(r));
        }

        /**
         * Convert double to float.
         *
         * <p>
         * Java Stack: ..., DOUBLE -> ..., FLOAT
         * <p>
         */
/*MAC*/ void do_d2f() {
            jlong r = popLong();
            pushInt(d2f(r));
        }
/*end[FLOATS]*/


        /*-----------------------------------------------------------------------*\
         *        Complex instructions implemented with external functions       *
        \*-----------------------------------------------------------------------*/

#if TRACE
/*DEF*/ void PRINTSTACK() {
            Address cls = getClass(exception);
            Address name = com_sun_squawk_Klass_name(cls);
            char buf[1000];
            int pos = getArrayLength(name);
            if (pos >= 991) {
                pos = 990;
            }
            memmove(buf, name, pos);
            buf[pos++] = ':';
            buf[pos++] = ' ';
            pos += printJavaStringBuf(java_lang_Throwable_detailMessage(exception), buf + pos, 999 - pos);
            buf[pos] = 0;
            printStackTracePrim(-1, ip, fp, buf, null);
        }
#else
#define PRINTSTACK() /**/
#endif


        /**
         * Throw an exception.
         *
         * <p>
         * Java Stack: OOP -> _
         * <p>
         */
/*MAC*/ void do_throw() {
            if (usingServiceStack()) {
                Address exception = popAddress();
                fprintf(stderr, "do_throw on service stack. current code=%d:\n", com_sun_squawk_ServiceOperation_code);
                assumeInterp(exception == null || ((UWord)getObject(exception, HDR_klass) & HDR_headerTagMask) == 0);
                if (exception != NULL && getClass(exception) != NULL) {
                    printJavaStrSafely(com_sun_squawk_Klass_name(getClass(exception)), "class");
                    printJavaStrSafely(java_lang_Throwable_detailMessage(exception), "detail message");
                }
                fatalInterpreterError("");
            } else {
                UWord oldip = (UWord)ip;
                Address exception = popAddress();
                nullCheck((Address)exception);
                PRINTSTACK();
                if (com_sun_squawk_ServiceOperation_pendingException != 0) {
                    fatalInterpreterError("do_throw with pending exception");
                }
                com_sun_squawk_ServiceOperation_pendingException = exception;
                threadSwitchFor(com_sun_squawk_ServiceOperation_THROW);
            }
        }

        /**
         * Start an exception handler.
         *
         * <p>
         * Compiler Stack: _ -> OOP
         * <p>
         */
/*MAC*/ void do_catch() {
            Address exception = (Address)com_sun_squawk_ServiceOperation_pendingException;
            assumeInterp(exception != null);
            com_sun_squawk_ServiceOperation_pendingException = 0;
            pushAddress(exception);
        }

        /**
         * Execute a monitor enter.
         *
         * <p>
         * Java Stack: OOP -> _
         * <p>
         */
/*MAC*/ void do_monitorenter() {
            Address obj = popAddress();
            Address assn;

            nullCheck(obj);
            assumeInterp(((UWord)getObject(obj, HDR_klass) & HDR_headerTagMask) == 0);
            assn = getClassOrAssociation(obj);
            if (unlikely(MONITOR_CACHE_SIZE == 0 || associationToKlass(assn) != assn || pendingMonitorStackPointer == MONITOR_CACHE_SIZE ||
						 !(hi(obj, com_sun_squawk_GC_ramStart) && loeq(obj, com_sun_squawk_GC_ramEnd)))) {
                pushAddress(obj);
                call(com_sun_squawk_VM_monitorenter);
            } else {
                pendingMonitors[pendingMonitorStackPointer++] = obj;
            }
        }

#ifdef INTERPRETER_STATS
#define updatePendingMonitorAccesses() pendingMonitorAccesses++
#define updatePendingMonitorHits() pendingMonitorHits++
#else
#define updatePendingMonitorAccesses()
#define updatePendingMonitorHits()
#endif /* INTERPRETER_STATS */

        /**
         * Execute a monitor exit.
         *
         * <p>
         * Java Stack: OOP -> _
         * <p>
         */
/*MAC*/ void do_monitorexit() {
            Address obj = popAddress();
            Address assn;

            nullCheck(obj);
            assumeInterp(((UWord)getObject(obj, HDR_klass) & HDR_headerTagMask) == 0);
            assn = getClassOrAssociation(obj);
            updatePendingMonitorAccesses();
            if (unlikely(MONITOR_CACHE_SIZE == 0 || associationToKlass(assn) != assn || pendingMonitorStackPointer == 0 ||
						 !(hi(obj, com_sun_squawk_GC_ramStart) && loeq(obj, com_sun_squawk_GC_ramEnd)))) {
                pushAddress(obj);
                call(com_sun_squawk_VM_monitorexit);
            } else {
                Address obj2 = pendingMonitors[--pendingMonitorStackPointer];
                assumeInterp(obj == obj2);
                pendingMonitors[pendingMonitorStackPointer] = null;
                updatePendingMonitorHits();
            }
        }

        /**
         * Execute a monitor enter.
         *
         * <p>
         * Java Stack: _ -> _
         * <p>
         */
/*MAC*/ void do_class_monitorenter() {
            pushAddress(getCP());
            do_monitorenter();
        }

        /**
         * Execute a monitor exit.
         *
         * <p>
         * Java Stack: _ -> _
         * <p>
         */
/*MAC*/ void do_class_monitorexit() {
            pushAddress(getCP());
            do_monitorexit();
        }

        /**
         * Initialize class if needed.
         *
         * <p>
         * Java Stack: _ -> _
         * <p>
         */
/*MAC*/ void do_class_clinit() {
            checkReferenceSlots();
            if (unlikely(needsInitializing(getCP()))) {
                pushAddress(getCP());
                call(com_sun_squawk_VM_class_clinit);
            }
        }

        /**
         * Get the length of an array.
         *
         * <p>
         * Java Stack: ..., OOP -> ..., INT
         * <p>
         */
/*MAC*/ void do_arraylength() {
            Address oop = popAddress();
            nullCheck(oop);
            pushInt(getArrayLength(oop));
        }

#ifdef INTERPRETER_STATS
#define updateNewHits() com_sun_squawk_GC_newHits++
#else
#define updateNewHits()
#endif /* INTERPRETER_STATS */

        /**
         * Allocate an object.
         *
         * <p>
         * Java Stack: ..., CLASS -> ..., OOP
         * <p>
         */
/*MAC*/ void do_new() {
            checkReferenceSlots();
            if (FASTALLOC) {
                Address klass = popAddress();
                if (likely(!needsInitializing(klass))) {
                    boolean hasFinalizer = false;
/*if[FINALIZATION]*/
                    hasFinalizer = (com_sun_squawk_Klass_modifiers(klass) & com_sun_squawk_Modifier_HASFINALIZER) != 0;
/*end[FINALIZATION]*/
                    if (!hasFinalizer) {
                        int allocSize    = roundUpToWord(com_sun_squawk_Klass_instanceSizeBytes(klass)) + HDR_basicHeaderSize;
                        Address oop      = allocateFast(allocSize, klass, -1);
                        if (oop != null) {
                            pushAddress(oop);
                            updateNewHits();
                            nextbytecode();
                        }
                    }
                }
                pushAddress(klass);
            }
            call(com_sun_squawk_VM__new);
        }

        /**
         * Allocate a new array.
         *
         * <p>
         * Java Stack: SIZE, CLASS -> ..., OOP
         * <p>
         */
/*MAC*/ void do_newarray() {
            checkReferenceSlots();
            if (FASTALLOC) {
                Address klass = popAddress();
                int length    = popInt();
                if (likely(length >= 0)) {
                    Address ctype = com_sun_squawk_Klass_componentType(klass);
                    int dataSize = getDataSize(ctype);
                    int bodySize = length * dataSize;
                    if (likely(bodySize >= 0)) {
                        int allocSize = roundUpToWord(HDR_arrayHeaderSize + bodySize);
                        Address oop   = allocateFast(allocSize, klass, length);
                        if (oop != null) {
                            pushAddress(oop);
                            updateNewHits();
                            nextbytecode();
                        }
                    }
                }
                pushInt(length);
                pushAddress(klass);
            }
            call(com_sun_squawk_VM_newarray);
        }

        /**
         * Allocate a new array dimension.
         *
         * <p>
         * Java Stack: OOP, SIZE -> ..., OOP
         * <p>
         */
/*MAC*/ void do_newdimension() {
            call(com_sun_squawk_VM_newdimension);
        }

        /**
         * Instanceof.
         *
         * <p>
         * Java Stack: ..., OOP, CLASS -> ..., INT
         * <p>
         */
/*MAC*/ void do_instanceof() {
            Address klass = popAddress();
            Address obj   = popAddress();
            checkReferenceSlots();
            if (obj == null || klass == null) {
                pushInt(false);
            } else {
                pushInt(VM_instanceof(obj, klass));
            }
        }

        /**
         * Checkcast.
         *
         * <p>
         * Java Stack: ..., OOP, CLASS -> ..., OOP
         * <p>
         */
/*MAC*/ void do_checkcast() {
            Address klass = popAddress();
            Address obj   = popAddress();
            checkReferenceSlots();
            if (obj != null && !VM_instanceof(obj, klass)) {
                pushAddress(obj);
                pushAddress(klass);
                call(com_sun_squawk_VM_checkcastException);
            } else {
                pushAddress(obj);
            }
        }

        /**
         * Lookup.
         *
         * <p>
         * Java Stack: KEY, ARRAY -> VALUE
         * <p>
         */
/*MAC*/ void do_lookup_b() {
            Address barray = popAddress();
            int  key = popInt();
            pushInt(VM_lookup_b(key, barray));
        }
/*MAC*/ void do_lookup_s() {
            Address sarray = popAddress();
            int  key = popInt();
            pushInt(VM_lookup_s(key, sarray));
        }
/*MAC*/ void do_lookup_i() {
            Address iarray = popAddress();
            int  key = popInt();
            pushInt(VM_lookup_i(key, iarray));
        }

        /**
         * Reserved.
         *
         * <p>
         * Compiler Stack: ... -> ...
         * <p>
         *
         * @param n ignored parameter
         */
/*MAC*/ void do_res(int $n) {
            shouldNotReachHere();
        }
        
