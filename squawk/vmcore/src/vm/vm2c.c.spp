/*
 * Copyright 2004-2010 Sun Microsystems, Inc. All Rights Reserved.
 * Copyright 2011 Oracle Corporation. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Oracle Corporation, 500 Oracle Parkway, Redwood
 * Shores, CA 94065 or visit www.oracle.com if you need additional
 * information or have any questions.
 */

/* **** GENERATED FILE -- DO NOT EDIT ****
 *      generated by com.sun.squawk.vm2c.Converter
 */

/* Forward declarations. */
static void            Assert_that_Z(boolean);
static boolean         collectGarbage(Address, Address, boolean);
static Address         copyObjectGraph(Address, Address, Address, Address);
static int             MethodHeader_minfoValue1_L(Address);
static Offset          Address_diff_A(Address, Address);
static Address         Address_zero();
static int             MethodHeader_minfoValue2_L(Address);
static int             NativeUnsafe_getByte_LI(Address, int);
static Address         Address_add_I(Address, int);
static boolean         Address_lo_A(Address, Address);
static jlong           CheneyCollector_freeMemory_A(Address, Address);
static jlong           CheneyCollector_totalMemory(Address);
static Address         GC_getKlass_L(Address);
static int             GC_getTotalCount();
static boolean         GC_isTracing_I(int);
static jlong           GarbageCollector_now(Address);
static void            CheneyCollector_memoryProtect_AA(Address, Address);
static void            CheneyCollector_toggleSpaces(Address);
static void            CheneyCollector_traceHeap_LA(Address, Address, Address);
static void            CheneyCollector_traceVariables(Address);
static boolean         CheneyCollector_tracing(Address);
static Address         GC_blockToOop_A(Address);
static int             GC_decodeLengthWord_U(UWord);
static int             GC_getArrayLengthNoCheck_L(Address);
static int             GC_getBodySize_LA(Address, Address);
static int             GC_roundUpToWord_I(int);
static void            GarbageCollector_traceHeapEnd(Address);
static void            GarbageCollector_traceHeapObject_AALI(Address, Address, Address, Address, int);
static void            GarbageCollector_traceHeapSegment_LAA(Address, Address, Address, Address);
static void            GarbageCollector_traceHeapSegment_LAI(Address, Address, Address, int);
static void            GarbageCollector_traceHeapStart_LJJ(Address, Address, jlong, jlong);
static void            GarbageCollector_traceVariable_LA(Address, Address, Address);
static void            GarbageCollector_traceVariable_LI(Address, Address, int);
static Address         Klass_getComponentType_L(Address);
static int             Klass_getDataSize_L(Address);
static int             Klass_getInstanceSize_L(Address);
static Address         Klass_getInternalName_L(Address);
static int             Klass_getSquawkArrayComponentDataSize_L(Address);
static int             Klass_getSystemID_L(Address);
static boolean         Klass_isSquawkArray_L(Address);
static Address         Address_addOffset_O(Address, Offset);
static Address         Address_and_U(Address, UWord);
static boolean         Address_eq_A(Address, Address);
static Address         Address_fromObject_L(Address);
static boolean         Address_hi_A(Address, Address);
static boolean         Address_hieq_A(Address, Address);
static boolean         Address_isZero(Address);
static boolean         Address_loeq_A(Address, Address);
static boolean         Address_ne_A(Address, Address);
static Address         Address_or_U(Address, UWord);
static Address         Address_roundUpToWord(Address);
static Address         Address_sub_I(Address, int);
static Address         Address_toObject(Address);
static UWord           Address_toUWord(Address);
static void            Assert_always_ZLI(boolean, Address, int);
static void            Assert_that_ZL(boolean, Address);
static void            BitSet_ensureCapacity_I(Address, int);
static void            BitSet_grow_II(Address, int, int);
static void            BitSet_set_I(Address, int);
static void            BitSet_validateIndex_I(Address, int);
static void            CheneyCollector_checkActivationForAddresses_AZ(Address, Address, boolean);
static void            CheneyCollector_clearFromSpace(Address);
static Address         CheneyCollector_copyNonRootObjects_A(Address, Address);
static Address         CheneyCollector_copyObject_A(Address, Address);
static void            CheneyCollector_copyRootObjects(Address);
static int             CheneyCollector_countObjects_AA(Address, Address, Address);
static Address         CheneyCollector_getForwardedObject_A(Address);
static Address         CheneyCollector_getKlass_A(Address, Address);
static Address         CheneyCollector_getPossiblyForwardedObject_A(Address, Address);
static Address         CheneyCollector_getPossiblyForwardedObject_L(Address, Address);
static boolean         CheneyCollector_initializeForwardingRepairMap_AAA(Address, Address, Address, Address);
static boolean         CheneyCollector_isForwarded_A(Address, Address);
static boolean         CheneyCollector_isInFromSpace_A(Address, Address);
static boolean         CheneyCollector_isInToSpace_A(Address, Address);
static void            CheneyCollector_processWeakReferenceQueue(Address);
static void            CheneyCollector_recordPointer_A(Address, Address);
static void            CheneyCollector_repairForwardedObjects(Address);
static void            CheneyCollector_setForwardPointer_AA(Address, Address, Address);
static void            CheneyCollector_updateActivation_AZ(Address, Address, boolean);
static void            CheneyCollector_updateOops_A(Address, Address);
static Address         CheneyCollector_updateReference_AI(Address, Address, int);
static void            CheneyCollector_updateStackChunkInternalPointers_AA(Address, Address, Address);
static void            CheneyCollector_updateStackChunk_A(Address, Address);
static void            GC_encodeLengthWordError();
static UWord           GC_encodeLengthWord_I(int);
static int             GC_getArrayLength_L(Address);
static boolean         GC_inRamHosted_L(Address);
static boolean         GC_inRam_L(Address);
static Address         GC_oopToBlock_LA(Address, Address);
static void            GC_setAllocationParameters_AAAA(Address, Address, Address, Address);
static void            GC_setHeaderClass_AL(Address, Address);
static void            GC_setHeaderLength_AI(Address, int);
static void            GarbageCollector_addWeakReference_L(Address, Address);
static int             GeneralDecoder_nextByte(Address);
static int             GeneralDecoder_readUnsignedInt(Address);
static Address         Isolate_getBootstrapSuite(Address);
static Address         Isolate_getClassStateForInterpreter_L(Address, Address);
static int             Klass_findSlot_LI(Address, Address, int);
static Address         Klass_getComponentType(Address);
static Address         Klass_getInternalName(Address);
static int             Klass_getModifiers(Address);
static int             Klass_getRefStaticFieldsSize_L(Address);
static int             Klass_getState(Address);
static boolean         Klass_isAbstract(Address);
static boolean         Klass_isArray(Address);
static boolean         Klass_isAssignableFrom0_L(Address, Address);
static boolean         Klass_isAssignableFrom_L(Address, Address);
static boolean         Klass_isImplementorOf_L(Address, Address);
static boolean         Klass_isInstanceWordReference_LI(Address, int);
static boolean         Klass_isInterface(Address);
static boolean         Klass_isSubtypeOf_L(Address, Address);
static boolean         Klass_isSubtypeOf_LL(Address, Address);
static int             MethodHeader_decodeExceptionTableSize_L(Address);
static int             MethodHeader_decodeLocalCount_L(Address);
static int             MethodHeader_decodeOopmapOffset_L(Address);
static int             MethodHeader_decodeParameterCount_L(Address);
static int             MethodHeader_decodeTypeTableOffset_L(Address);
static int             MethodHeader_decodeTypeTableSize_L(Address);
static int             MethodHeader_getOffsetToLastMinfoByte0_LII(Address, int, int);
static int             MethodHeader_getOffsetToLastMinfoByte_L(Address);
static int             MethodHeader_minfoValue3_L(Address);
static int             MethodHeader_minfoValue4_L(Address);
static int             MethodHeader_minfoValue_LI(Address, int);
static Address         MethodHeader_oopToBlock_A(Address);
static boolean         Modifier_isAbstract_I(int);
static boolean         Modifier_isArray_I(int);
static boolean         Modifier_isInterface_I(int);
static boolean         Modifier_isSquawkArray_I(int);
static boolean         Modifier_isSynthetic_I(int);
static unsigned short  NativeUnsafe_charAt_LI(Address, int);
static Address         NativeUnsafe_getAddress_LI(Address, int);
static UWord           NativeUnsafe_getAsUWord_LI(Address, int);
static Address         NativeUnsafe_getObject_LI(Address, int);
static int             NativeUnsafe_getUByte_LI(Address, int);
static UWord           NativeUnsafe_getUWord_LI(Address, int);
static void            NativeUnsafe_setAddress_LIL(Address, int, Address);
static void            NativeUnsafe_setObject_LIL(Address, int, Address);
static void            NativeUnsafe_setUWord_LIU(Address, int, UWord);
static Offset          Offset_add_I(Offset, int);
static Offset          Offset_fromPrimitive_I(int);
static boolean         Offset_ge_O(Offset, Offset);
static int             Offset_toInt(Offset);
static int             Offset_toPrimitive(Offset);
static Offset          Offset_wordsToBytes(Offset);
static int             String_compareTo_L(Address, Address);
static int             String_length(Address);
static Address         Suite_getKlass_I(Address, int);
static boolean         Suite_isBootstrap(Address);
static Address         Suite_lookup_L(Address, Address);
static UWord           UWord_and_U(UWord, UWord);
static boolean         UWord_eq_U(UWord, UWord);
static UWord           UWord_fromPrimitive_I(int);
static boolean         UWord_ne_U(UWord, UWord);
static int             UWord_toInt(UWord);
static int             UWord_toPrimitive(UWord);
static UWord           UWord_zero();
static int             VMBufferDecoder_getOffset(Address);
static int             VMBufferDecoder_nextByte(Address);
static void            VMBufferDecoder_reset_LI(Address, Address, int);
static boolean         VM_instanceof(Address, Address);
static void            VM_addToClassStateCache_LL(Address, Address);
static int             VM_arrayOopStoreCheck(Address, int, Address);
static Address         VM_asKlass_A(Address);
static Address         VM_asKlass_L(Address);
static jlong           VM_branchCount();
static void            VM_copyBytes_AIAIIZ(Address, int, Address, int, int, boolean);
static void            VM_deadbeef_AA(Address, Address);
static void            VM_fatalVMError();
static int             VM_findSlot(Address, Address, int);
static jlong           VM_getBranchCount();
static Address         VM_getClassState(Address);
static Address         VM_getCurrentIsolate();
static int             VM_getGlobalOopCount();
static Address         VM_getGlobalOop_I(int);
static Address         VM_getOutOfMemoryError();
static Address         VM_getPreviousFP_A(Address);
static Address         VM_getPreviousIP_A(Address);
static jlong           VM_getTimeMicros();
static jlong           VM_getTimeMillis();
static boolean         VM_inRam(Address);
static boolean         VM_isHosted();
static boolean         VM_isVerbose();
static int             VM_lookup_b(int, Address);
static int             VM_lookup_i(int, Address);
static int             VM_lookup_s(int, Address);
static void            VM_printAddress_A(Address);
static void            VM_printAddress_L(Address);
static void            VM_printOffset_O(Offset);
static void            VM_printUWord_U(UWord);
static void            VM_print_I(int);
static void            VM_print_J(jlong);
static void            VM_print_L(Address);
static void            VM_println();
static void            VM_println_L(Address);
static void            VM_setGlobalOop_LI(Address, int);
static void            VM_setPreviousIP_AA(Address, Address);
static int             VM_setStream0_I(int);
static int             VM_setStream_I(int);
Address getObjectForCStringLiteral(int key, int klassIndex, const char *cstr);

INLINE int div_i(int lhs, int rhs) {
    if (unlikely(rhs == 0)) {
        fatalVMError("divide by zero");
    }
    if (unlikely(lhs == 0x80000000 && rhs == -1)) {
        return lhs;
    }
    return lhs / rhs;
}

INLINE long div_l(jlong lhs, jlong rhs) {
    if (unlikely(rhs == 0)) {
        fatalVMError("divide by zero");
    }
/*if[SQUAWK_64]*/
    if (unlikely(rhs == -1L && lhs == 0x8000000000000000L)) {
        return lhs;
    }
/*end[SQUAWK_64]*/
    return lhs / rhs;
}

INLINE int rem_i(int lhs, int rhs) {
    if (unlikely(rhs == 0)) {
        fatalVMError("divide by zero");
    }
    if (unlikely(lhs == 0x80000000 && rhs == -1)) {
        return 0;
    }
    return lhs % rhs;
}

INLINE long rem_l(jlong lhs, jlong rhs) {
    if (unlikely(rhs == 0)) {
        fatalVMError("divide by zero");
    }
/*if[SQUAWK_64]*/
    if (unlikely(rhs == -1L && lhs == 0x8000000000000000L)) {
        return 0;
    }
/*end[SQUAWK_64]*/
    return lhs % rhs;
}

INLINE UWord Array_length(Address oop) {
    return (getUWord(oop, HDR_length) >> 2);
}

INLINE Address nullPointerCheck(Address oop) {
    if (unlikely(oop == null)) {
        fatalVMError("null pointer exception");
    }
    return oop;
}

INLINE void arrayBoundsCheck(Address oop, int index) {
    UWord length;
    nullPointerCheck(oop);
    length = Array_length(oop);
    if (unlikely(((UWord)index) >= length)) {
        fatalVMError("array index out of bounds exception");
    }
}

int aload_b(Address oop, int index) {
    arrayBoundsCheck(oop, index);
    return getByte(oop, index);
}

int aload_s(Address oop, int index) {
    arrayBoundsCheck(oop, index);
    return getShort(oop, index);
}

int aload_c(Address oop, int index) {
    arrayBoundsCheck(oop, index);
    return getUShort(oop, index);
}

int aload_i(Address oop, int index) {
    arrayBoundsCheck(oop, index);
    return getInt(oop, index);
}

jlong aload_l(Address oop, int index) {
    arrayBoundsCheck(oop, index);
    return getLong(oop, index);
}

Address aload_o(Address oop, int index) {
    arrayBoundsCheck(oop, index);
    return getObject(oop, index);
}

void astore_b(Address oop, int index, int value) {
    arrayBoundsCheck(oop, index);
    setByte(oop, index, value);
}

void astore_s(Address oop, int index, int value) {
    arrayBoundsCheck(oop, index);
    setShort(oop, index, value);
}

void astore_i(Address oop, int index, int value) {
    arrayBoundsCheck(oop, index);
    setInt(oop, index, value);
}

void astore_l(Address oop, int index, jlong value) {
    arrayBoundsCheck(oop, index);
    setLong(oop, index, value);
}


#define  Assert_that_Z( cond) if (!(cond)) { fprintf(stderr, "Assertion failed: %s, at %s:%d\n", #cond, __FILE__, __LINE__); fatalVMError(""); }


INLINE int NativeUnsafe_getUByte_LI(Address base, int offset) {
    return getUByte(base, offset);
}


NOINLINE int MethodHeader_minfoValue1_L(Address oop) {
    int p;
    int val;
    p = -13 - 1;
    
    
    val = NativeUnsafe_getUByte_LI(oop, p--);
    if (val > 127) {
        val = val & 127;
        val = sll(val, 8);
        val = val | (NativeUnsafe_getUByte_LI(oop, p));
    }
    
    return val;
}

INLINE int NativeUnsafe_getByte_LI(Address base, int offset) {
    return getByte(base, offset);
}


NOINLINE int MethodHeader_minfoValue2_L(Address oop) {
    int p;
    int val;
    p = -13 - 1;
    
    
    if (NativeUnsafe_getByte_LI(oop, p--) < 0) {
        p--;
    }
    val = NativeUnsafe_getUByte_LI(oop, p--);
    if (val > 127) {
        val = val & 127;
        val = sll(val, 8);
        val = val | NativeUnsafe_getUByte_LI(oop, p);
    }
    
    return val;
}

INLINE Offset Address_diff_A(Address this, Address address2) {
    return Address_diff(this, address2);
}


INLINE int Offset_toPrimitive(Offset this) {
    return this;
}


INLINE Address Address_zero() {
    return (Address)0;
}


INLINE jlong VM_getTimeMicros() {
    return sysTimeMicros();
}


INLINE jlong VM_getTimeMillis() {
    return sysTimeMillis();
}


static jlong GarbageCollector_now(Address this) {
    return com_sun_squawk_GarbageCollector_useMicrosecondTimer(this) ? VM_getTimeMicros() : VM_getTimeMillis();
}

static int GC_getTotalCount() {
    return com_sun_squawk_GC_fullCollectionCount + com_sun_squawk_GC_partialCollectionCount;
}

static boolean GC_isTracing_I(int option) {
    if ((com_sun_squawk_GC_traceFlags & option & 1) != 0) {
        return 1;
    } else if ((false || false) && (com_sun_squawk_GC_traceFlags & option) != 0) {
        if ((com_sun_squawk_GC_traceFlags & option & 2) != 0) {
            return 1;
        } else {
            return (com_sun_squawk_GC_collector == null || GC_getTotalCount() >= com_sun_squawk_GC_traceThreshold);
        }
    } else {
        return 0;
    }
}

INLINE boolean Address_lo_A(Address this, Address address2) {
    return this < address2;
}


INLINE Address GC_getKlass_L(Address object) {
    return getClass(object);
}


INLINE Address Address_add_I(Address this, int offset) {
    return Address_add(this, offset);
}


static void VM_print_L(Address x) {
    printJavaString(x, streams[currentStream]);
}


static void VM_print_J(jlong x) {
    fprintf(streams[currentStream], format("%L"), x); fflush(streams[currentStream]);
}


INLINE jlong VM_getBranchCount() {
    return getBranchCount();
}


static jlong VM_branchCount() {
    return VM_getBranchCount();
}

NOINLINE void VM_println() {
    VM_print_L(getObjectForCStringLiteral(0, com_sun_squawk_VM, "\r\n"));
}

NOINLINE void VM_println_L(Address x) {
    VM_print_L(x);
    VM_println();
}

static void GarbageCollector_traceHeapStart_LJJ(Address this, Address description, jlong freeMemory, jlong totalMemory) {
    VM_print_L(getObjectForCStringLiteral(65536, com_sun_squawk_GarbageCollector, "*HEAP*:start:"));
    VM_print_J(VM_branchCount());
    VM_print_L(getObjectForCStringLiteral(65537, com_sun_squawk_GarbageCollector, ":"));
    VM_print_J(freeMemory);
    VM_print_L(getObjectForCStringLiteral(65537, com_sun_squawk_GarbageCollector, ":"));
    VM_print_J(totalMemory);
    VM_print_L(getObjectForCStringLiteral(65537, com_sun_squawk_GarbageCollector, ":"));
    VM_println_L(description);
}

static jlong CheneyCollector_freeMemory_A(Address this, Address allocationPointer) {
    return Offset_toPrimitive(Address_diff_A(com_sun_squawk_CheneyCollector_toSpaceEndPointer(this), allocationPointer));
}

static jlong CheneyCollector_totalMemory(Address this) {
    return Offset_toPrimitive(Address_diff_A(com_sun_squawk_CheneyCollector_toSpaceEndPointer(this), com_sun_squawk_CheneyCollector_toSpaceStartPointer(this)));
}

INLINE int Offset_toInt(Offset this) {
    assume((int)this == this); return (int)this;
}


static void VM_printAddress_A(Address val) {
    jnaPrint(val);
}


static void GarbageCollector_traceHeapSegment_LAI(Address this, Address label, Address start, int size) {
    if (size > 0) {
        VM_print_L(getObjectForCStringLiteral(65538, com_sun_squawk_GarbageCollector, "*HEAP*:segment:"));
        VM_printAddress_A(start);
        VM_print_L(getObjectForCStringLiteral(65537, com_sun_squawk_GarbageCollector, ":"));
        VM_printAddress_A(Address_add_I(start, size));
        VM_print_L(getObjectForCStringLiteral(65537, com_sun_squawk_GarbageCollector, ":"));
        VM_println_L(label);
    }
}

static void GarbageCollector_traceHeapSegment_LAA(Address this, Address label, Address start, Address end) {
    GarbageCollector_traceHeapSegment_LAI(this, label, start, Offset_toInt(Address_diff_A(end, start)));
}

INLINE UWord NativeUnsafe_getAsUWord_LI(Address base, int offset) {
    return getUWordTyped(base, offset, AddressType_ANY);
}


INLINE UWord UWord_and_U(UWord this, UWord word) {
    return this & word;
}


INLINE UWord UWord_fromPrimitive_I(int value) {
    return (UWord)value;
}


INLINE int UWord_toInt(UWord this) {
    assume((int)this == this); return (int)this;
}


INLINE int UWord_toPrimitive(UWord this) {
    return (Offset)this;
}


INLINE int GC_decodeLengthWord_U(UWord word) {
    return srl((int)UWord_toPrimitive(word), 2);
}

static void VM_fatalVMError() {
    fatalVMError("");
}


static Address GC_blockToOop_A(Address block) {
    UWord taggedWord;
    taggedWord = NativeUnsafe_getAsUWord_LI(block, 0);
    switch (UWord_toInt(UWord_and_U(taggedWord, UWord_fromPrimitive_I(3)))) {
    case 0: 
        return Address_add_I(block, 4);
    
    case 1: 
        return Address_add_I(block, 8);
    
    case 3: 
        return Address_add_I(block, GC_decodeLengthWord_U(taggedWord) * 4);
    
    default: 
        VM_fatalVMError();
    
    }
    return null;
}

INLINE boolean Modifier_isSquawkArray_I(int mod) {
    return (mod & 4194304) != 0;
}

INLINE boolean Klass_isSquawkArray_L(Address klass) {
    return Modifier_isSquawkArray_I(com_sun_squawk_Klass_modifiers(klass));
}

INLINE UWord NativeUnsafe_getUWord_LI(Address base, int offset) {
    return getUWord(base, offset);
}


INLINE int GC_getArrayLengthNoCheck_L(Address array) {
    return GC_decodeLengthWord_U(NativeUnsafe_getUWord_LI(array, -2));
}

INLINE int GC_roundUpToWord_I(int value) {
    return (value + (4 - 1)) & ~(4 - 1);
}

INLINE boolean Modifier_isArray_I(int mod) {
    return (mod & 2097152) != 0;
}

INLINE int Klass_getInstanceSize_L(Address klass) {
    
    
    
    return div_i((com_sun_squawk_Klass_instanceSizeBytes(klass) + (4 - 1)), 4);
}

static boolean Modifier_isInterface_I(int mod) {
    return (mod & 512) != 0;
}

static boolean Modifier_isSynthetic_I(int mod) {
    return (mod & 524288) != 0;
}

INLINE Address Klass_getComponentType_L(Address klass) {
    return com_sun_squawk_Klass_componentType(nullPointerCheck(klass));
}

INLINE int Klass_getSystemID_L(Address klass) {
    return com_sun_squawk_Klass_id(klass);
}

static int Klass_getDataSize_L(Address klass) {
    switch (Klass_getSystemID_L(klass)) {
    case 6: 
    
    case 32: 
    
    case 7: 
        {
            return 1;
        }
    
    case 8: 
    
    case 9: 
        {
            return 2;
        }
    
    case 14: 
    
    case 11: 
        {
            return 8;
        }
    
    case 13: 
    
    case 10: 
        {
            return 4;
        }
    
    default: 
        {
            return 4;
        }
    
    }
}

static int Klass_getSquawkArrayComponentDataSize_L(Address klass) {
    
    if (com_sun_squawk_Klass_id(klass) == 26) {
        return 1;
    } else if (com_sun_squawk_Klass_id(klass) == 2) {
        return 2;
    } else {
        return Klass_getDataSize_L(Klass_getComponentType_L(klass));
    }
}

static int GC_getBodySize_LA(Address klass, Address object) {
    if (Klass_isSquawkArray_L(klass)) {
        int length;
        int elementSize;
        length = GC_getArrayLengthNoCheck_L(object);
        elementSize = Klass_getSquawkArrayComponentDataSize_L(klass);
        return GC_roundUpToWord_I(length * elementSize);
    } else {
        return Klass_getInstanceSize_L(klass) * 4;
    }
}

INLINE boolean UWord_eq_U(UWord this, UWord word2) {
    return this == word2;
}


static void VM_printUWord_U(UWord val) {
    fprintf(streams[currentStream], format("%A"), val); fflush(streams[currentStream]);
}


static void VM_print_I(int x) {
    fprintf(streams[currentStream], "%i", x); fflush(streams[currentStream]);
}


static Address Klass_getInternalName_L(Address klass) {
    return com_sun_squawk_Klass_name(nullPointerCheck(klass));
}

static void GarbageCollector_traceHeapObject_AALI(Address this, Address start, Address oop, Address klass, int size) {
    VM_print_L(getObjectForCStringLiteral(65539, com_sun_squawk_GarbageCollector, "*HEAP*:"));
    VM_printAddress_A(start);
    VM_print_L(getObjectForCStringLiteral(65537, com_sun_squawk_GarbageCollector, ":"));
    while (Address_lo_A(start, oop)) {
        VM_printUWord_U(NativeUnsafe_getAsUWord_LI(start, 0));
        VM_print_L(getObjectForCStringLiteral(65537, com_sun_squawk_GarbageCollector, ":"));
        start = Address_add_I(start, 4);
    }
    VM_print_L(getObjectForCStringLiteral(65540, com_sun_squawk_GarbageCollector, "oop:"));
    if (size != 0) {
        UWord last;
        int repeats;
        int i;
        last = NativeUnsafe_getAsUWord_LI(oop, 0);
        VM_printUWord_U(last);
        VM_print_L(getObjectForCStringLiteral(65537, com_sun_squawk_GarbageCollector, ":"));
        repeats = 0;
        for (i = 1; i != size; ++i) {
            UWord word;
            word = NativeUnsafe_getAsUWord_LI(oop, i);
            if (UWord_eq_U(word, last)) {
                ++repeats;
            } else {
                if (repeats != 0) {
                    VM_print_L(getObjectForCStringLiteral(65541, com_sun_squawk_GarbageCollector, "*"));
                    VM_print_I(repeats);
                    VM_print_L(getObjectForCStringLiteral(65537, com_sun_squawk_GarbageCollector, ":"));
                    repeats = 0;
                }
                VM_printUWord_U(word);
                VM_print_L(getObjectForCStringLiteral(65537, com_sun_squawk_GarbageCollector, ":"));
                last = word;
            }
        }
        if (repeats != 0) {
            VM_print_L(getObjectForCStringLiteral(65541, com_sun_squawk_GarbageCollector, "*"));
            VM_print_I(repeats);
            VM_print_L(getObjectForCStringLiteral(65537, com_sun_squawk_GarbageCollector, ":"));
        }
    }
    VM_println_L(Klass_getInternalName_L(klass));
}

static void GarbageCollector_traceHeapEnd(Address this) {
    VM_println_L(getObjectForCStringLiteral(65542, com_sun_squawk_GarbageCollector, "*HEAP*:end"));
}

static void CheneyCollector_traceHeap_LA(Address this, Address description, Address allocationPointer) {
    GarbageCollector_traceHeapStart_LJJ(this, description, CheneyCollector_freeMemory_A(this, allocationPointer), CheneyCollector_totalMemory(this));
    GarbageCollector_traceHeapSegment_LAA(this, getObjectForCStringLiteral(131072, com_sun_squawk_CheneyCollector, "fromSpace"), com_sun_squawk_CheneyCollector_fromSpaceStartPointer(this), com_sun_squawk_CheneyCollector_fromSpaceEndPointer(this));
    GarbageCollector_traceHeapSegment_LAA(this, getObjectForCStringLiteral(131073, com_sun_squawk_CheneyCollector, "toSpace{used}"), com_sun_squawk_CheneyCollector_toSpaceStartPointer(this), allocationPointer);
    GarbageCollector_traceHeapSegment_LAA(this, getObjectForCStringLiteral(131074, com_sun_squawk_CheneyCollector, "toSpace{free}"), allocationPointer, com_sun_squawk_CheneyCollector_toSpaceEndPointer(this));
    if (GC_isTracing_I(64)) {
        Address block;
        for (block = com_sun_squawk_CheneyCollector_toSpaceStartPointer(this); Address_lo_A(block, allocationPointer); ) {
            Address object;
            Address klass;
            int size;
            object = GC_blockToOop_A(block);
            klass = GC_getKlass_L(object);
            size = GC_getBodySize_LA(klass, object);
            GarbageCollector_traceHeapObject_AALI(this, block, object, klass, div_i(size, 4));
            block = Address_add_I(object, size);
        }
    }
    GarbageCollector_traceHeapEnd(this);
}

static boolean CheneyCollector_tracing(Address this) {
    
    return 0;
}

static void GarbageCollector_traceVariable_LA(Address this, Address name, Address value) {
    VM_print_L(getObjectForCStringLiteral(65543, com_sun_squawk_GarbageCollector, "    "));
    VM_print_L(name);
    VM_print_L(getObjectForCStringLiteral(65544, com_sun_squawk_GarbageCollector, " = "));
    VM_printAddress_A(value);
    VM_println();
}

static void GarbageCollector_traceVariable_LI(Address this, Address name, int value) {
    VM_print_L(getObjectForCStringLiteral(65543, com_sun_squawk_GarbageCollector, "    "));
    VM_print_L(name);
    VM_print_L(getObjectForCStringLiteral(65544, com_sun_squawk_GarbageCollector, " = "));
    VM_print_I(value);
    if (value > (1024 * 1024)) {
        int rem;
        VM_print_L(getObjectForCStringLiteral(65545, com_sun_squawk_GarbageCollector, " ["));
        VM_print_I(div_i(value, (1024 * 1024)));
        VM_print_L(getObjectForCStringLiteral(65546, com_sun_squawk_GarbageCollector, "."));
        rem = div_i((rem_i(value, (1024 * 1024))), (div_i((1024 * 1024), 10)));
        VM_print_I(rem);
        VM_print_L(getObjectForCStringLiteral(65547, com_sun_squawk_GarbageCollector, "M]"));
    } else if (value > 1024) {
        int rem;
        VM_print_L(getObjectForCStringLiteral(65545, com_sun_squawk_GarbageCollector, " ["));
        VM_print_I(div_i(value, (1024)));
        VM_print_L(getObjectForCStringLiteral(65546, com_sun_squawk_GarbageCollector, "."));
        rem = div_i((rem_i(value, (1024))), (div_i((1024), 10)));
        VM_print_I(rem);
        VM_print_L(getObjectForCStringLiteral(65548, com_sun_squawk_GarbageCollector, "K]"));
    }
    VM_println();
}

static void CheneyCollector_traceVariables(Address this) {
    VM_println_L(getObjectForCStringLiteral(131075, com_sun_squawk_CheneyCollector, "CheneyCollector variables"));
    GarbageCollector_traceVariable_LA(this, getObjectForCStringLiteral(131076, com_sun_squawk_CheneyCollector, "fromSpaceStartPointer"), com_sun_squawk_CheneyCollector_fromSpaceStartPointer(this));
    GarbageCollector_traceVariable_LA(this, getObjectForCStringLiteral(131077, com_sun_squawk_CheneyCollector, "fromSpaceEndPointer"), com_sun_squawk_CheneyCollector_fromSpaceEndPointer(this));
    GarbageCollector_traceVariable_LI(this, getObjectForCStringLiteral(131078, com_sun_squawk_CheneyCollector, "fromSpaceSize"), Offset_toInt(Address_diff_A(com_sun_squawk_CheneyCollector_fromSpaceEndPointer(this), com_sun_squawk_CheneyCollector_fromSpaceStartPointer(this))));
    GarbageCollector_traceVariable_LA(this, getObjectForCStringLiteral(131079, com_sun_squawk_CheneyCollector, "toSpaceStartPointer"), com_sun_squawk_CheneyCollector_toSpaceStartPointer(this));
    GarbageCollector_traceVariable_LA(this, getObjectForCStringLiteral(131080, com_sun_squawk_CheneyCollector, "toSpaceEndPointer"), com_sun_squawk_CheneyCollector_toSpaceEndPointer(this));
    GarbageCollector_traceVariable_LI(this, getObjectForCStringLiteral(131081, com_sun_squawk_CheneyCollector, "toSpaceSize"), Offset_toInt(Address_diff_A(com_sun_squawk_CheneyCollector_toSpaceEndPointer(this), com_sun_squawk_CheneyCollector_toSpaceStartPointer(this))));
    GarbageCollector_traceVariable_LA(this, getObjectForCStringLiteral(131082, com_sun_squawk_CheneyCollector, "toSpaceAllocationPointer"), com_sun_squawk_CheneyCollector_toSpaceAllocationPointer(this));
}

static void CheneyCollector_toggleSpaces(Address this) {
    Address newStartPointer;
    Address newEndPointer;
    newStartPointer = com_sun_squawk_CheneyCollector_fromSpaceStartPointer(this);
    newEndPointer = com_sun_squawk_CheneyCollector_fromSpaceEndPointer(this);
    set_com_sun_squawk_CheneyCollector_fromSpaceStartPointer(this, com_sun_squawk_CheneyCollector_toSpaceStartPointer(this));
    set_com_sun_squawk_CheneyCollector_fromSpaceEndPointer(this, com_sun_squawk_CheneyCollector_toSpaceEndPointer(this));
    set_com_sun_squawk_CheneyCollector_toSpaceStartPointer(this, newStartPointer);
    set_com_sun_squawk_CheneyCollector_toSpaceEndPointer(this, newEndPointer);
    set_com_sun_squawk_CheneyCollector_toSpaceAllocationPointer(this, com_sun_squawk_CheneyCollector_toSpaceStartPointer(this));
    if (false && CheneyCollector_tracing(this)) {
        VM_println_L(getObjectForCStringLiteral(131083, com_sun_squawk_CheneyCollector, "CheneyCollector::toggleSpaces"));
        CheneyCollector_traceVariables(this);
    }
}

static void CheneyCollector_memoryProtect_AA(Address start, Address end) {
    cheneyEndMemoryProtect = end; cheneyStartMemoryProtect = start;
}


#define  VM_getGlobalOopCount() GLOBAL_OOP_COUNT


INLINE Address Address_fromObject_L(Address object) {
    return (Address)object;
}


#define  VM_getGlobalOop_I( index) Oops[index]


INLINE boolean Address_ne_A(Address this, Address address2) {
    return this != address2;
}


INLINE Address Address_toObject(Address this) {
    return this;
}

#define  Assert_that_ZL( cond,  msg) if (!(cond)) { fprintf(stderr, "Assertion failed: %s, at %s:%d\n", (char*)msg, __FILE__, __LINE__); fatalVMError(""); }


INLINE Address Address_roundUpToWord(Address this) {
    return (Address)roundUpToWord((UWord)this);
}


INLINE boolean Address_eq_A(Address this, Address address2) {
    return this == address2;
}


INLINE boolean Address_isZero(Address this) {
    return this == 0;
}


INLINE void VM_copyBytes_AIAIIZ(Address src, int srcPos, Address dst, int dstPos, int length, boolean nvmDst) {
    copyBytes(src, srcPos, dst, dstPos, length, nvmDst);
}


INLINE boolean Address_loeq_A(Address this, Address address2) {
    return this <= address2;
}


static boolean CheneyCollector_isInFromSpace_A(Address this, Address pointer) {
    return Address_loeq_A(com_sun_squawk_CheneyCollector_fromSpaceStartPointer(this), pointer) && Address_lo_A(pointer, com_sun_squawk_CheneyCollector_fromSpaceEndPointer(this));
}

INLINE Address NativeUnsafe_getObject_LI(Address base, int offset) {
    return getObject(base, offset);
}


INLINE Address NativeUnsafe_getAddress_LI(Address base, int offset) {
    return getObject(base, offset);
}


#define  VM_asKlass_A( object) (object)


INLINE UWord Address_toUWord(Address this) {
    return (UWord)this;
}


INLINE boolean UWord_ne_U(UWord this, UWord word2) {
    return this != word2;
}


INLINE UWord UWord_zero() {
    return 0;
}


static boolean CheneyCollector_isForwarded_A(Address this, Address object) {
    UWord classWord;
    classWord = Address_toUWord(NativeUnsafe_getAddress_LI(object, -1));
    return UWord_ne_U(UWord_and_U(classWord, UWord_fromPrimitive_I(2)), UWord_zero());
}

INLINE Address Address_and_U(Address this, UWord word) {
    return (Address)((UWord)this & word);
}


static Address CheneyCollector_getForwardedObject_A(Address object) {
    Address classWord;
    classWord = NativeUnsafe_getAddress_LI(object, -1);
    
    return Address_and_U(classWord, UWord_fromPrimitive_I(~3));
}

static Address CheneyCollector_getPossiblyForwardedObject_A(Address this, Address object) {
    if (CheneyCollector_isForwarded_A(this, object)) {
        return CheneyCollector_getForwardedObject_A(object);
    } else {
        return object;
    }
}

static Address CheneyCollector_getPossiblyForwardedObject_L(Address this, Address object) {
    return CheneyCollector_getPossiblyForwardedObject_A(this, Address_fromObject_L(object));
}

static Address CheneyCollector_getKlass_A(Address this, Address object) {
    Address classWord;
    Address something;
    Address klass;
    object = CheneyCollector_getPossiblyForwardedObject_A(this, object);
    classWord = NativeUnsafe_getObject_LI(object, -1);
    something = CheneyCollector_getPossiblyForwardedObject_L(this, classWord);
    klass = NativeUnsafe_getAddress_LI(something, (int)JLONG_CONSTANT(4294967296));
    return VM_asKlass_A(CheneyCollector_getPossiblyForwardedObject_A(this, klass));
}

static Address Klass_getInternalName(Address this) {
    return Klass_getInternalName_L(this);
}

INLINE Address Address_sub_I(Address this, int offset) {
    return Address_sub(this, offset);
}


INLINE int MethodHeader_decodeLocalCount_L(Address oop) {
    int b0;
    b0 = NativeUnsafe_getUByte_LI(oop, -13);
    if (b0 < 128) {
        int b1;
        b1 = NativeUnsafe_getUByte_LI(oop, -13 - 1);
        return (sra(((sll(b0, 8)) | b1), 5)) & 31;
    } else {
        return MethodHeader_minfoValue2_L(oop);
    }
}

INLINE int MethodHeader_decodeParameterCount_L(Address oop) {
    int b0;
    b0 = NativeUnsafe_getUByte_LI(oop, -13);
    if (b0 < 128) {
        return sra(b0, 2);
    } else {
        return MethodHeader_minfoValue3_L(oop);
    }
}

NOINLINE int MethodHeader_minfoValue3_L(Address oop) {
    int p;
    int val;
    p = -13 - 1;
    
    
    if (NativeUnsafe_getByte_LI(oop, p--) < 0) {
        p--;
    }
    if (NativeUnsafe_getByte_LI(oop, p--) < 0) {
        p--;
    }
    val = NativeUnsafe_getUByte_LI(oop, p--);
    if (val > 127) {
        val = val & 127;
        val = sll(val, 8);
        val = val | NativeUnsafe_getUByte_LI(oop, p);
    }
    
    return val;
}

INLINE int MethodHeader_decodeExceptionTableSize_L(Address oop) {
    int b0;
    b0 = NativeUnsafe_getUByte_LI(oop, -13);
    if (b0 < 128 || ((b0 & 1) == 0)) {
        return 0;
    }
    return MethodHeader_minfoValue4_L(oop);
}

NOINLINE int MethodHeader_minfoValue4_L(Address oop) {
    int p;
    int val;
    p = -13 - 1;
    
    
    if (NativeUnsafe_getByte_LI(oop, p--) < 0) {
        p--;
    }
    if (NativeUnsafe_getByte_LI(oop, p--) < 0) {
        p--;
    }
    if (NativeUnsafe_getByte_LI(oop, p--) < 0) {
        p--;
    }
    val = NativeUnsafe_getUByte_LI(oop, p--);
    if (val > 127) {
        val = val & 127;
        val = sll(val, 8);
        val = val | NativeUnsafe_getUByte_LI(oop, p);
    }
    
    return val;
}

INLINE int MethodHeader_decodeTypeTableSize_L(Address oop) {
    {
        return 0;
    }
}

NOINLINE int MethodHeader_minfoValue_LI(Address oop, int offset) {
    int p;
    int val;
    p = -13 - 1;
    val = -1;
    
    while (offset-- > 0) {
        val = NativeUnsafe_getUByte_LI(oop, p--);
        if (val > 127) {
            p--;
        }
    }
    if (val > 127) {
        val = val & 127;
        val = sll(val, 8);
        val = val | (NativeUnsafe_getUByte_LI(oop, p - 1));
    }
    
    return val;
}

NOINLINE int MethodHeader_getOffsetToLastMinfoByte0_LII(Address oop, int p, int b0) {
    int offset;
    offset = 3;
    if ((b0 & 1) != 0) {
        offset++;
    }
    if (false && (b0 & 2) != 0) {
        offset++;
    }
    while (offset-- > 0) {
        int val;
        val = NativeUnsafe_getUByte_LI(oop, p--);
        if (val > 127) {
            p--;
        }
    }
    return p + 1;
}

static int MethodHeader_getOffsetToLastMinfoByte_L(Address oop) {
    int p;
    int b0;
    p = -13;
    b0 = NativeUnsafe_getUByte_LI(oop, p--);
    if (b0 < 128) {
        return p;
    } else {
        return MethodHeader_getOffsetToLastMinfoByte0_LII(oop, p, b0);
    }
}

static int MethodHeader_decodeTypeTableOffset_L(Address oop) {
    int vars;
    int oopmapLth;
    vars = MethodHeader_decodeLocalCount_L(oop) + MethodHeader_decodeParameterCount_L(oop);
    oopmapLth = div_i((vars + 7), 8);
    return MethodHeader_getOffsetToLastMinfoByte_L(oop) - oopmapLth - MethodHeader_decodeExceptionTableSize_L(oop) - MethodHeader_decodeTypeTableSize_L(oop);
}

NOINLINE Address MethodHeader_oopToBlock_A(Address oop) {
    int offset;
    offset = MethodHeader_decodeTypeTableOffset_L(Address_toObject(oop));
    while ((rem_i(offset, 4)) != 0) {
        --offset;
    }
    offset = (offset - 4);
    return Address_add_I(oop, offset);
}

static Address GC_oopToBlock_LA(Address klass, Address object) {
    if (Klass_isSquawkArray_L(klass)) {
        if (Klass_getSystemID_L(klass) == 33) {
            return MethodHeader_oopToBlock_A(object);
        } else {
            return Address_sub_I(object, 8);
        }
    } else {
        return Address_sub_I(object, 4);
    }
}

INLINE boolean Offset_ge_O(Offset this, Offset offset2) {
    return this >= offset2;
}


INLINE Offset Offset_fromPrimitive_I(int value) {
    return (Offset)value;
}


INLINE void NativeUnsafe_setAddress_LIL(Address base, int offset, Address value) {
    setObject(base, offset, value);
}


INLINE void NativeUnsafe_setUWord_LIU(Address base, int offset, UWord value) {
    setUWord(base, offset, value);
}


INLINE Address Address_or_U(Address this, UWord word) {
    return (Address)((UWord)this | word);
}


static void CheneyCollector_setForwardPointer_AA(Address this, Address object, Address forwardPointer) {
    if (com_sun_squawk_CheneyCollector_copyingObjectGraph(this)) {
        UWord classWord;
        
        classWord = Address_toUWord(NativeUnsafe_getAddress_LI(object, -1));
        NativeUnsafe_setAddress_LIL(com_sun_squawk_CheneyCollector_forwardingRepairMapTop(this), 0, object);
        NativeUnsafe_setUWord_LIU(com_sun_squawk_CheneyCollector_forwardingRepairMapTop(this), 1, classWord);
        set_com_sun_squawk_CheneyCollector_forwardingRepairMapTop(this, Address_add_I(com_sun_squawk_CheneyCollector_forwardingRepairMapTop(this), 4 * 2));
        NativeUnsafe_setAddress_LIL(object, -1, Address_or_U(forwardPointer, UWord_fromPrimitive_I(2)));
    } else {
        CheneyCollector_memoryProtect_AA(Address_zero(), Address_zero());
        NativeUnsafe_setAddress_LIL(object, -1, Address_or_U(forwardPointer, UWord_fromPrimitive_I(2)));
        CheneyCollector_memoryProtect_AA(com_sun_squawk_CheneyCollector_fromSpaceStartPointer(this), com_sun_squawk_CheneyCollector_fromSpaceEndPointer(this));
    }
}

INLINE Offset Offset_wordsToBytes(Offset this) {
    return this << HDR_LOG2_BYTES_PER_WORD;
}


INLINE Address Address_addOffset_O(Address this, Offset offset) {
    return Address_add(this, offset);
}


INLINE Offset Offset_add_I(Offset this, int delta) {
    return this + delta;
}


static boolean CheneyCollector_isInToSpace_A(Address this, Address pointer) {
    return Address_loeq_A(com_sun_squawk_CheneyCollector_toSpaceStartPointer(this), pointer) && Address_lo_A(pointer, com_sun_squawk_CheneyCollector_toSpaceEndPointer(this));
}

static void BitSet_validateIndex_I(Address this, int bitIndex) {
    if (bitIndex < 0) {
        fatalVMError("java.lang.IndexOutOfBoundsException");
    }
}

static void BitSet_grow_II(Address this, int bitIndex, int bytesRequired) {
    fatalVMError("cannot grow bit set");
}


static void BitSet_ensureCapacity_I(Address this, int bitIndex) {
    int bytesRequired;
    bytesRequired = (div_i(bitIndex, 8)) + 1;
    if (Array_length(com_sun_squawk_util_BitSet_bits(this)) < bytesRequired) {
        BitSet_grow_II(this, bitIndex, bytesRequired);
    }
}

static void BitSet_set_I(Address this, int bitIndex) {
    int byteIndex;
    signed char bit;
    BitSet_validateIndex_I(this, bitIndex);
    byteIndex = div_i(bitIndex, 8);
    BitSet_ensureCapacity_I(this, bitIndex);
    if (byteIndex >= com_sun_squawk_util_BitSet_bytesInUse(this)) {
        set_com_sun_squawk_util_BitSet_bytesInUse(this, byteIndex + 1);
    }
    bit = (signed char)(sll(1, (rem_i(bitIndex, 8))));
    astore_b(com_sun_squawk_util_BitSet_bits(this), byteIndex, (aload_b(com_sun_squawk_util_BitSet_bits(this), byteIndex) | bit));
}

static void CheneyCollector_recordPointer_A(Address this, Address pointerAddress) {
    if (CheneyCollector_isInToSpace_A(this, pointerAddress)) {
        int word;
        word = (div_i(Offset_toInt(Address_diff_A(pointerAddress, com_sun_squawk_CheneyCollector_toSpaceStartPointer(this))), 4));
        BitSet_set_I(nullPointerCheck(com_sun_squawk_CheneyCollector_oopMap(this)), word);
        if (false && CheneyCollector_tracing(this)) {
            VM_print_L(getObjectForCStringLiteral(131084, com_sun_squawk_CheneyCollector, "CheneyCollector::recordPointer - set bit in oop map for pointer at "));
            VM_printAddress_A(pointerAddress);
            VM_println();
        }
    }
}

static void VM_printOffset_O(Offset val) {
    fprintf(streams[currentStream], format("%O"), val); fflush(streams[currentStream]);
}


static void CheneyCollector_updateStackChunkInternalPointers_AA(Address this, Address oldChunk, Address newChunk) {
    Offset offsetToPointer;
    Address oldFP;
    if (false && CheneyCollector_tracing(this)) {
        VM_println_L(getObjectForCStringLiteral(131085, com_sun_squawk_CheneyCollector, "CheneyCollector::updateStackChunkInternalPointers"));
    }
    offsetToPointer = Offset_wordsToBytes(Offset_fromPrimitive_I(2));
    oldFP = NativeUnsafe_getAddress_LI(Address_addOffset_O(oldChunk, offsetToPointer), 0);
    while (!Address_isZero(oldFP)) {
        Address newPointerAddress;
        Offset delta;
        Address newFP;
        newPointerAddress = Address_addOffset_O(newChunk, offsetToPointer);
        delta = Address_diff_A(oldFP, oldChunk);
        newFP = Address_addOffset_O(newChunk, delta);
        NativeUnsafe_setAddress_LIL(newPointerAddress, 0, newFP);
        if (com_sun_squawk_CheneyCollector_copyingObjectGraph(this)) {
            CheneyCollector_recordPointer_A(this, newPointerAddress);
        }
        if (false && CheneyCollector_tracing(this)) {
            VM_print_L(getObjectForCStringLiteral(131086, com_sun_squawk_CheneyCollector, "CheneyCollector::updateStackChunkInternalPointers offset = "));
            VM_printOffset_O(offsetToPointer);
            VM_print_L(getObjectForCStringLiteral(131087, com_sun_squawk_CheneyCollector, " oldFP = "));
            VM_printAddress_A(oldFP);
            VM_print_L(getObjectForCStringLiteral(131088, com_sun_squawk_CheneyCollector, " newFP = "));
            VM_printAddress_A(newFP);
            VM_println();
        }
        offsetToPointer = Offset_add_I(delta, 1 * 4);
        oldFP = NativeUnsafe_getAddress_LI(Address_addOffset_O(oldChunk, offsetToPointer), 0);
    }
}

static boolean VM_isVerbose() {
    return com_sun_squawk_VM_verboseLevel > 0;
}

#define  Assert_always_ZLI( cond,  filename,  lineno) if (!(cond)) { fprintf(stderr, "Assertion failed: %s, at %s:%d\n", #cond, __FILE__, __LINE__); fatalVMError(""); }


INLINE int VM_setStream0_I(int stream) {
    return setStream(stream);
}


static int VM_setStream_I(int stream) {
    Assert_always_ZLI(stream >= 0 && stream <= 2, getObjectForCStringLiteral(1, com_sun_squawk_VM, "VM.java"), 1743);
    return VM_setStream0_I(stream);
}

static Address CheneyCollector_copyObject_A(Address this, Address object) {
    Address block;
    int headerSize;
    int blockSize;
    Address copiedObject;
    Address klass;
    
    if (false && CheneyCollector_tracing(this)) {
        VM_print_L(getObjectForCStringLiteral(131089, com_sun_squawk_CheneyCollector, "CheneyCollector::copyObject - object = "));
        VM_printAddress_A(object);
    }
    if (Address_isZero(object)) {
        if (false && CheneyCollector_tracing(this)) {
            VM_println_L(getObjectForCStringLiteral(131090, com_sun_squawk_CheneyCollector, " is null"));
        }
        return null;
    }
    if (!CheneyCollector_isInFromSpace_A(this, object)) {
        if (false && CheneyCollector_tracing(this)) {
            VM_print_L(getObjectForCStringLiteral(131091, com_sun_squawk_CheneyCollector, " klass = "));
            VM_print_L(Klass_getInternalName(nullPointerCheck(CheneyCollector_getKlass_A(this, object))));
            VM_println_L(getObjectForCStringLiteral(131092, com_sun_squawk_CheneyCollector, " Not in from space "));
        }
        return object;
    }
    
    if (CheneyCollector_isForwarded_A(this, object)) {
        Address forwardPointer;
        forwardPointer = CheneyCollector_getForwardedObject_A(object);
        if (false && CheneyCollector_tracing(this)) {
            VM_print_L(getObjectForCStringLiteral(131091, com_sun_squawk_CheneyCollector, " klass = "));
            VM_print_L(Klass_getInternalName(nullPointerCheck(CheneyCollector_getKlass_A(this, forwardPointer))));
            VM_print_L(getObjectForCStringLiteral(131093, com_sun_squawk_CheneyCollector, " already forwarded to "));
            VM_printAddress_A(forwardPointer);
            VM_println();
        }
        
        return forwardPointer;
    }
    block = GC_oopToBlock_LA(CheneyCollector_getKlass_A(this, object), object);
    headerSize = Offset_toInt(Address_diff_A(object, block));
    blockSize = headerSize + GC_getBodySize_LA(CheneyCollector_getKlass_A(this, object), object);
    
    VM_copyBytes_AIAIIZ(block, 0, com_sun_squawk_CheneyCollector_toSpaceAllocationPointer(this), 0, blockSize, 0);
    copiedObject = Address_add_I(com_sun_squawk_CheneyCollector_toSpaceAllocationPointer(this), headerSize);
    
    set_com_sun_squawk_CheneyCollector_toSpaceAllocationPointer(this, Address_add_I(com_sun_squawk_CheneyCollector_toSpaceAllocationPointer(this), blockSize));
    CheneyCollector_setForwardPointer_AA(this, object, copiedObject);
    klass = CheneyCollector_getKlass_A(this, copiedObject);
    if (false && CheneyCollector_tracing(this)) {
        VM_print_L(getObjectForCStringLiteral(131094, com_sun_squawk_CheneyCollector, " blockSize = "));
        VM_print_I(blockSize);
        VM_print_L(getObjectForCStringLiteral(131091, com_sun_squawk_CheneyCollector, " klass = "));
        VM_print_L(Klass_getInternalName_L(klass));
        VM_print_L(getObjectForCStringLiteral(131095, com_sun_squawk_CheneyCollector, " copied to "));
        VM_printAddress_A(copiedObject);
        VM_println();
    }
    if (Klass_getSystemID_L(klass) == 29) {
        CheneyCollector_updateStackChunkInternalPointers_AA(this, object, copiedObject);
    }
    if (VM_isVerbose() && Klass_getSystemID_L(klass) == 33) {
        int old;
        old = VM_setStream_I(2);
        if (!com_sun_squawk_CheneyCollector_copyingObjectGraph(this)) {
            VM_print_L(getObjectForCStringLiteral(131096, com_sun_squawk_CheneyCollector, "METHOD."));
            VM_printAddress_A(copiedObject);
            VM_print_L(getObjectForCStringLiteral(131097, com_sun_squawk_CheneyCollector, ".MOVED_FROM="));
            VM_printAddress_A(object);
            VM_println();
        } else {
            VM_print_L(getObjectForCStringLiteral(131098, com_sun_squawk_CheneyCollector, "SAVED_METHOD."));
            VM_printOffset_O(Address_diff_A(copiedObject, com_sun_squawk_CheneyCollector_toSpaceStartPointer(this)));
            VM_print_L(getObjectForCStringLiteral(131099, com_sun_squawk_CheneyCollector, ".COPIED_FROM="));
            VM_printAddress_A(object);
            VM_println();
        }
        VM_setStream_I(old);
    }
    return copiedObject;
}

static void VM_setGlobalOop_LI(Address value, int index) {
    Oops[index] = value;
}


static void CheneyCollector_copyRootObjects(Address this) {
    int i;
    if (false && CheneyCollector_tracing(this)) {
        VM_println_L(getObjectForCStringLiteral(131100, com_sun_squawk_CheneyCollector, "CheneyCollector::copyRootObjects --------------- Start"));
    }
    for (i = 0; i < VM_getGlobalOopCount(); i++) {
        Address oldObject;
        Address newObject;
        oldObject = Address_fromObject_L(VM_getGlobalOop_I(i));
        if (false && CheneyCollector_tracing(this)) {
            VM_print_L(getObjectForCStringLiteral(131101, com_sun_squawk_CheneyCollector, "CheneyCollector::copyRootObjects index = "));
            VM_print_I(i);
            VM_print_L(getObjectForCStringLiteral(131102, com_sun_squawk_CheneyCollector, " object = "));
            VM_printAddress_A(oldObject);
            VM_println();
        }
        newObject = CheneyCollector_copyObject_A(this, oldObject);
        if (Address_ne_A(newObject, oldObject)) {
            VM_setGlobalOop_LI(Address_toObject(newObject), i);
        }
    }
    if (false && CheneyCollector_tracing(this)) {
        VM_println_L(getObjectForCStringLiteral(131103, com_sun_squawk_CheneyCollector, "CheneyCollector::copyRootObjects --------------- End"));
    }
}

#define  VM_asKlass_L( object) ((Address)object)


INLINE int GC_getArrayLength_L(Address array) {
    
    return GC_getArrayLengthNoCheck_L(array);
}

static Address CheneyCollector_updateReference_AI(Address this, Address base, int offset) {
    Address oldObject;
    Address newObject;
    
    oldObject = NativeUnsafe_getAddress_LI(base, offset);
    if (false && CheneyCollector_tracing(this)) {
        VM_print_L(getObjectForCStringLiteral(131104, com_sun_squawk_CheneyCollector, "CheneyCollector::updateReference - ["));
        VM_printAddress_A(base);
        VM_print_L(getObjectForCStringLiteral(131105, com_sun_squawk_CheneyCollector, "%"));
        VM_print_I(offset);
        VM_print_L(getObjectForCStringLiteral(131106, com_sun_squawk_CheneyCollector, "] = "));
        VM_printAddress_A(oldObject);
        VM_println();
    }
    newObject = CheneyCollector_copyObject_A(this, oldObject);
    if (Address_ne_A(newObject, oldObject)) {
        NativeUnsafe_setAddress_LIL(base, offset, newObject);
    }
    if (com_sun_squawk_CheneyCollector_copyingObjectGraph(this)) {
        Address pointerAddress;
        pointerAddress = Address_add_I(base, offset * 4);
        CheneyCollector_recordPointer_A(this, pointerAddress);
    }
    return newObject;
}

static int Klass_getRefStaticFieldsSize_L(Address klass) {
    return com_sun_squawk_Klass_refStaticFieldsSize(klass);
}

INLINE Address VM_getPreviousFP_A(Address _fp) {
    return getObject(_fp, FP_returnFP);
}


INLINE Address VM_getPreviousIP_A(Address _fp) {
    return getObject(_fp, FP_returnIP);
}


static void VM_setPreviousIP_AA(Address _fp, Address pip) {
    setObject(_fp, FP_returnIP, pip);
}


static int MethodHeader_decodeOopmapOffset_L(Address oop) {
    int vars;
    int oopmapLth;
    vars = MethodHeader_decodeLocalCount_L(oop) + MethodHeader_decodeParameterCount_L(oop);
    oopmapLth = div_i((vars + 7), 8);
    return MethodHeader_getOffsetToLastMinfoByte_L(oop) - oopmapLth;
}

static void CheneyCollector_updateActivation_AZ(Address this, Address _fp, boolean isInnerMostActivation) {
    Address mp;
    Address previousFP;
    Address previousIP;
    int localCount;
    int parameterCount;
    int mapOffset;
    int bitOffset;
    int byteOffset;
    int varOffset;
    mp = NativeUnsafe_getAddress_LI(_fp, 0);
    previousFP = VM_getPreviousFP_A(_fp);
    previousIP = VM_getPreviousIP_A(_fp);
    if (false && CheneyCollector_tracing(this)) {
        VM_print_L(getObjectForCStringLiteral(131107, com_sun_squawk_CheneyCollector, "CheneyCollector::updateActivation fp = "));
        VM_printAddress_A(_fp);
        VM_print_L(getObjectForCStringLiteral(131108, com_sun_squawk_CheneyCollector, " mp = "));
        VM_printAddress_A(mp);
        VM_println();
    }
    if (!Address_isZero(previousIP)) {
        Address oldPreviousMP;
        Address newPreviousMP;
        Offset delta;
        if (false && CheneyCollector_tracing(this)) {
            VM_println_L(getObjectForCStringLiteral(131109, com_sun_squawk_CheneyCollector, "CheneyCollector::updateActivation -- change previous MP"));
        }
        
        oldPreviousMP = NativeUnsafe_getAddress_LI(previousFP, 0);
        
        newPreviousMP = CheneyCollector_updateReference_AI(this, previousFP, 0);
        delta = Address_diff_A(newPreviousMP, oldPreviousMP);
        if (false && CheneyCollector_tracing(this)) {
            VM_println_L(getObjectForCStringLiteral(131110, com_sun_squawk_CheneyCollector, "CheneyCollector::updateActivation -- change previous IP"));
            VM_print_L(getObjectForCStringLiteral(131111, com_sun_squawk_CheneyCollector, "        oldPreviousMP = "));
            VM_printAddress_A(oldPreviousMP);
            VM_print_L(getObjectForCStringLiteral(131112, com_sun_squawk_CheneyCollector, " oldPreviousIP = "));
            VM_printAddress_A(previousIP);
            VM_print_L(getObjectForCStringLiteral(131113, com_sun_squawk_CheneyCollector, " newPreviousMP = "));
            VM_printAddress_A(newPreviousMP);
            VM_print_L(getObjectForCStringLiteral(131114, com_sun_squawk_CheneyCollector, " delta = "));
            VM_printOffset_O(delta);
            VM_print_L(getObjectForCStringLiteral(131115, com_sun_squawk_CheneyCollector, " newPreviousIP = "));
            VM_printAddress_A(Address_addOffset_O(previousIP, delta));
            VM_println_L(getObjectForCStringLiteral(131116, com_sun_squawk_CheneyCollector, ""));
        }
        previousIP = Address_addOffset_O(previousIP, delta);
        VM_setPreviousIP_AA(_fp, previousIP);
        if (com_sun_squawk_CheneyCollector_copyingObjectGraph(this)) {
            Address pointerAddress;
            pointerAddress = Address_add_I(_fp, 2 * 4);
            CheneyCollector_recordPointer_A(this, pointerAddress);
        }
    } else {
        
    }
    localCount = isInnerMostActivation ? 1 : MethodHeader_decodeLocalCount_L(Address_toObject(mp));
    parameterCount = MethodHeader_decodeParameterCount_L(Address_toObject(mp));
    mapOffset = MethodHeader_decodeOopmapOffset_L(Address_toObject(mp));
    bitOffset = -1;
    byteOffset = 0;
    varOffset = 3;
    while (parameterCount-- > 0) {
        int bite;
        boolean isOop;
        bitOffset++;
        if (bitOffset == 8) {
            bitOffset = 0;
            byteOffset++;
        }
        bite = NativeUnsafe_getByte_LI(mp, mapOffset + byteOffset);
        isOop = ((sra(bite, bitOffset)) & 1) != 0;
        if (isOop) {
            if (false && CheneyCollector_tracing(this)) {
                VM_print_L(getObjectForCStringLiteral(131117, com_sun_squawk_CheneyCollector, "CheneyCollector::updateActivation -- update parm at offset "));
                VM_print_I(varOffset);
                VM_println();
            }
            CheneyCollector_updateReference_AI(this, _fp, varOffset);
        }
        varOffset++;
    }
    varOffset = 0;
    while (localCount-- > 0) {
        int bite;
        boolean isOop;
        bitOffset++;
        if (bitOffset == 8) {
            bitOffset = 0;
            byteOffset++;
        }
        bite = NativeUnsafe_getByte_LI(mp, mapOffset + byteOffset);
        isOop = ((sra(bite, bitOffset)) & 1) != 0;
        if (isOop) {
            if (false && CheneyCollector_tracing(this)) {
                VM_print_L(getObjectForCStringLiteral(131118, com_sun_squawk_CheneyCollector, "CheneyCollector::updateActivation -- update local at offset "));
                VM_print_I(varOffset);
                VM_println();
            }
            CheneyCollector_updateReference_AI(this, _fp, varOffset);
        }
        varOffset--;
    }
}

INLINE boolean Address_hieq_A(Address this, Address address2) {
    return this >= address2;
}


static void VMBufferDecoder_reset_LI(Address this, Address oop, int offset) {
    set_com_sun_squawk_VMBufferDecoder_oop(nullPointerCheck(this), oop);
    set_com_sun_squawk_VMBufferDecoder_offset(this, offset);
}

static int VMBufferDecoder_getOffset(Address this) {
    return com_sun_squawk_VMBufferDecoder_offset(this);
}

static int GeneralDecoder_nextByte(Address this) {
    Address klass = getClass(this);
    int id = com_sun_squawk_Klass_id(klass);
    int suiteID = id >= 0 ? id : -(id + 1);
    switch (suiteID) {
        case com_sun_squawk_VMBufferDecoder: return VMBufferDecoder_nextByte(this);
        default: fatalVMError("bad abstract method dispatch"); 
    }
}


static int GeneralDecoder_readUnsignedInt(Address this) {
    int lo;
    int mid;
    int hi;
    int last;
    lo = GeneralDecoder_nextByte(this) & 255;
    if (lo < 128) {
        return lo;
    }
    lo = (lo & 127);
    mid = GeneralDecoder_nextByte(this) & 255;
    if (mid < 128) {
        return ((sll(mid, 7)) + lo);
    }
    mid = (mid & 127);
    hi = GeneralDecoder_nextByte(this) & 255;
    if (hi < 128) {
        return ((sll(hi, 14)) + (sll(mid, 7)) + lo);
    }
    hi = (hi & 127);
    last = GeneralDecoder_nextByte(this) & 255;
    if (last < 128) {
        return ((sll(last, 21)) + (sll(hi, 14)) + (sll(mid, 7)) + lo);
    }
    fatalVMError("java.lang.Error");
}

static void CheneyCollector_checkActivationForAddresses_AZ(Address this, Address _fp, boolean isInnerMostActivation) {
    Address mp;
    int localCount;
    int parameterCount;
    int typeTableSize;
    int typeTableOffset;
    mp = NativeUnsafe_getAddress_LI(_fp, 0);
    if (false && CheneyCollector_tracing(this)) {
        VM_print_L(getObjectForCStringLiteral(131119, com_sun_squawk_CheneyCollector, "CheneyCollector::checkActivationForAddresses fp = "));
        VM_printAddress_A(_fp);
        VM_print_L(getObjectForCStringLiteral(131108, com_sun_squawk_CheneyCollector, " mp = "));
        VM_printAddress_A(mp);
        VM_println();
    }
    localCount = isInnerMostActivation ? 0 : MethodHeader_decodeLocalCount_L(Address_toObject(mp));
    parameterCount = MethodHeader_decodeParameterCount_L(Address_toObject(mp));
    typeTableSize = MethodHeader_decodeTypeTableSize_L(Address_toObject(mp));
    typeTableOffset = MethodHeader_decodeTypeTableOffset_L(Address_toObject(mp));
    if (typeTableSize > 0) {
        int typeTableEndOffset;
        VMBufferDecoder_reset_LI(nullPointerCheck(com_sun_squawk_CheneyCollector_decoder(this)), Address_toObject(mp), typeTableOffset);
        typeTableEndOffset = typeTableOffset + typeTableSize;
        while (VMBufferDecoder_getOffset(nullPointerCheck(com_sun_squawk_CheneyCollector_decoder(this))) < typeTableEndOffset) {
            int cid;
            int slot;
            cid = GeneralDecoder_readUnsignedInt(nullPointerCheck(com_sun_squawk_CheneyCollector_decoder(this)));
            slot = GeneralDecoder_readUnsignedInt(nullPointerCheck(com_sun_squawk_CheneyCollector_decoder(this)));
            if (cid == 34) {
                if (slot < parameterCount) {
                    int varOffset;
                    Address value;
                    varOffset = 3 + slot;
                    value = NativeUnsafe_getAddress_LI(_fp, varOffset);
                    if (Address_hieq_A(value, com_sun_squawk_CheneyCollector_fromSpaceStartPointer(this)) && Address_loeq_A(value, com_sun_squawk_CheneyCollector_fromSpaceEndPointer(this))) {
                        VM_print_L(getObjectForCStringLiteral(131120, com_sun_squawk_CheneyCollector, "**WARNING**: parameter "));
                        VM_print_I(slot);
                        VM_print_L(getObjectForCStringLiteral(131121, com_sun_squawk_CheneyCollector, " of type Address points into the heap: mp = "));
                        VM_printAddress_A(mp);
                        VM_println();
                    }
                } else {
                    int local;
                    local = slot - parameterCount;
                    if (local < localCount) {
                        int varOffset;
                        Address value;
                        varOffset = 0 - local;
                        value = NativeUnsafe_getAddress_LI(_fp, varOffset);
                        if (Address_hieq_A(value, com_sun_squawk_CheneyCollector_fromSpaceStartPointer(this)) && Address_loeq_A(value, com_sun_squawk_CheneyCollector_fromSpaceEndPointer(this))) {
                            VM_print_L(getObjectForCStringLiteral(131122, com_sun_squawk_CheneyCollector, "**WARNING**: local "));
                            VM_print_I(local);
                            VM_print_L(getObjectForCStringLiteral(131121, com_sun_squawk_CheneyCollector, " of type Address points into the heap: mp = "));
                            VM_printAddress_A(mp);
                            VM_println();
                        }
                    }
                }
            }
        }
    }
}

static void CheneyCollector_updateStackChunk_A(Address this, Address chunk) {
    Address _fp;
    boolean isInnerMostActivation;
    _fp = NativeUnsafe_getAddress_LI(chunk, 2);
    if (false && CheneyCollector_tracing(this)) {
        VM_println();
        VM_print_L(getObjectForCStringLiteral(131123, com_sun_squawk_CheneyCollector, "CheneyCollector::updateStackChunk chunk = "));
        VM_printAddress_A(chunk);
        VM_println();
    }
    Assert_always_ZLI(Address_isZero(NativeUnsafe_getAddress_LI(chunk, 0)), getObjectForCStringLiteral(131124, com_sun_squawk_CheneyCollector, "CheneyCollector.java"), 855);
    CheneyCollector_updateReference_AI(this, chunk, 1);
    isInnerMostActivation = 1;
    while (!Address_isZero(_fp)) {
        CheneyCollector_updateActivation_AZ(this, _fp, isInnerMostActivation);
        
        _fp = VM_getPreviousFP_A(_fp);
        isInnerMostActivation = 0;
    }
}

static boolean Klass_isSubtypeOf_LL(Address thisClass, Address klass) {
    while (thisClass != null) {
        if (thisClass == klass) {
            return 1;
        }
        thisClass = com_sun_squawk_Klass_superType(nullPointerCheck(thisClass));
    }
    return 0;
}

static boolean Klass_isInstanceWordReference_LI(Address klass, int wordIndex) {
    UWord word;
    UWord bit;
    
    
    if (Klass_getInstanceSize_L(klass) > 32) {
        word = aload_i(com_sun_squawk_Klass_oopMap(nullPointerCheck(klass)), div_i(wordIndex, 32));
    } else {
        
        word = com_sun_squawk_Klass_oopMapWord(klass);
    }
    bit = UWord_fromPrimitive_I(sll(1, (rem_i(wordIndex, 32))));
    return UWord_ne_U(UWord_and_U(word, bit), UWord_zero());
}

static void CheneyCollector_updateOops_A(Address this, Address object) {
    Address associationOrKlass;
    Address klass;
    associationOrKlass = CheneyCollector_updateReference_AI(this, object, -1);
    klass = VM_asKlass_A(CheneyCollector_updateReference_AI(this, associationOrKlass, (int)JLONG_CONSTANT(4294967296)));
    if (false && CheneyCollector_tracing(this)) {
        VM_print_L(getObjectForCStringLiteral(131125, com_sun_squawk_CheneyCollector, "CheneyCollector::updateOops object = "));
        VM_printAddress_A(object);
        VM_print_L(getObjectForCStringLiteral(131091, com_sun_squawk_CheneyCollector, " klass = "));
        VM_println_L(Klass_getInternalName_L(klass));
    }
    if (Klass_isSquawkArray_L(klass)) {
        switch (Klass_getSystemID_L(klass)) {
        case 18: 
        
        case 19: 
        
        case 20: 
        
        case 25: 
        
        case 24: 
        
        case 22: 
        
        case 23: 
        
        case 21: 
        
        case 37: 
        
        case 35: 
        
        case 2: 
        
        case 26: 
            {
                break;
            }
        
        case 33: 
            {
                CheneyCollector_updateReference_AI(this, object, -3);
                break;
            }
        
        case 30: 
            {
                Address gaklass;
                gaklass = VM_asKlass_L(NativeUnsafe_getObject_LI(object, 0));
                if (gaklass == null) {
                    
                    if (false && CheneyCollector_tracing(this)) {
                        VM_println_L(getObjectForCStringLiteral(131126, com_sun_squawk_CheneyCollector, "CheneyCollector::updateOops GLOBAL_ARRAY with null CS.klass not scanned"));
                    }
                } else {
                    int end;
                    int i;
                    if (false && CheneyCollector_tracing(this)) {
                        VM_print_L(getObjectForCStringLiteral(131127, com_sun_squawk_CheneyCollector, "CheneyCollector::updateOops globals for "));
                        VM_println_L(Klass_getInternalName_L(gaklass));
                    }
                    end = 2 + Klass_getRefStaticFieldsSize_L(gaklass);
                    for (i = 0; i < end; i++) {
                        
                        CheneyCollector_updateReference_AI(this, object, i);
                    }
                }
                break;
            }
        
        case 29: 
            {
                CheneyCollector_updateStackChunk_A(this, object);
                break;
            }
        
        default: 
            {
                int length;
                int i;
                length = GC_getArrayLength_L(object);
                for (i = 0; i < length; i++) {
                    CheneyCollector_updateReference_AI(this, object, i);
                }
                break;
            }
        
        }
    } else {
        int nWords;
        int i;
        if (com_sun_squawk_CheneyCollector_copyingObjectGraph(this) && Klass_isSubtypeOf_LL(klass, com_sun_squawk_CheneyCollector_HashTableKlass(this))) {
            NativeUnsafe_setAddress_LIL(object, (int)JLONG_CONSTANT(4294967296), Address_zero());
        }
        nWords = Klass_getInstanceSize_L(klass);
        for (i = 0; i < nWords; i++) {
            if (Klass_isInstanceWordReference_LI(klass, i)) {
                CheneyCollector_updateReference_AI(this, object, i);
            }
        }
    }
}

static Address CheneyCollector_copyNonRootObjects_A(Address this, Address toSpaceUpdatePointer) {
    if (false && CheneyCollector_tracing(this)) {
        VM_println_L(getObjectForCStringLiteral(131128, com_sun_squawk_CheneyCollector, "CheneyCollector::copyNonRootObjects --------------- Start"));
    }
    while (Address_lo_A(toSpaceUpdatePointer, com_sun_squawk_CheneyCollector_toSpaceAllocationPointer(this))) {
        Address object;
        Address klass;
        object = GC_blockToOop_A(toSpaceUpdatePointer);
        if (false && CheneyCollector_tracing(this)) {
            VM_println();
            VM_print_L(getObjectForCStringLiteral(131129, com_sun_squawk_CheneyCollector, "CheneyCollector::copyNonRootObjects block = "));
            VM_printAddress_A(toSpaceUpdatePointer);
            VM_print_L(getObjectForCStringLiteral(131102, com_sun_squawk_CheneyCollector, " object = "));
            VM_printAddress_A(object);
            VM_print_L(getObjectForCStringLiteral(131091, com_sun_squawk_CheneyCollector, " klass = "));
            VM_println_L(Klass_getInternalName_L(CheneyCollector_getKlass_A(this, object)));
        }
        klass = CheneyCollector_getKlass_A(this, object);
        
        CheneyCollector_updateOops_A(this, object);
        toSpaceUpdatePointer = Address_add_I(object, GC_getBodySize_LA(klass, object));
    }
    if (false && CheneyCollector_tracing(this)) {
        VM_println_L(getObjectForCStringLiteral(131130, com_sun_squawk_CheneyCollector, "CheneyCollector::copyNonRootObjects --------------- End"));
    }
    return toSpaceUpdatePointer;
}

static void VM_printAddress_L(Address val) {
    jnaPrint(val);
}


static void GarbageCollector_addWeakReference_L(Address this, Address reference) {
    set_com_sun_squawk_Ref_next(nullPointerCheck(reference), com_sun_squawk_GarbageCollector_references(this));
    set_com_sun_squawk_GarbageCollector_references(this, reference);
}

static void CheneyCollector_processWeakReferenceQueue(Address this) {
    Address ref;
    ref = com_sun_squawk_GarbageCollector_references(this);
    set_com_sun_squawk_GarbageCollector_references(this, null);
    if (false && CheneyCollector_tracing(this)) {
        VM_println_L(getObjectForCStringLiteral(131131, com_sun_squawk_CheneyCollector, "CheneyCollector::processWeakReferenceQueue -- start "));
    }
    while (ref != null) {
        Address refAddress;
        Address next;
        if (false && CheneyCollector_tracing(this)) {
            VM_print_L(getObjectForCStringLiteral(131132, com_sun_squawk_CheneyCollector, "CheneyCollector::processWeakReferenceQueue -- processing weak reference @ "));
            VM_printAddress_L(ref);
            VM_print_L(getObjectForCStringLiteral(131133, com_sun_squawk_CheneyCollector, " to "));
            VM_printAddress_A(com_sun_squawk_Ref_referent(ref));
            VM_println();
        }
        refAddress = Address_fromObject_L(ref);
        
        next = com_sun_squawk_Ref_next(nullPointerCheck(ref));
        CheneyCollector_memoryProtect_AA(Address_zero(), Address_zero());
        if (CheneyCollector_isForwarded_A(this, refAddress)) {
            Address referent;
            refAddress = CheneyCollector_getForwardedObject_A(refAddress);
            ref = (Address)Address_toObject(refAddress);
            referent = com_sun_squawk_Ref_referent(ref);
            if (!Address_isZero(referent)) {
                referent = CheneyCollector_getPossiblyForwardedObject_A(this, referent);
                if (!CheneyCollector_isInFromSpace_A(this, referent)) {
                    set_com_sun_squawk_Ref_referent(ref, referent);
                    GarbageCollector_addWeakReference_L(this, ref);
                    if (false && CheneyCollector_tracing(this)) {
                        VM_print_L(getObjectForCStringLiteral(131134, com_sun_squawk_CheneyCollector, "CheneyCollector::processWeakReferenceQueue -- kept weak reference and updated referent to "));
                        VM_printAddress_A(referent);
                        VM_println();
                    }
                } else {
                    set_com_sun_squawk_Ref_referent(ref, Address_zero());
                    if (false && CheneyCollector_tracing(this)) {
                        VM_println_L(getObjectForCStringLiteral(131135, com_sun_squawk_CheneyCollector, "CheneyCollector::processWeakReferenceQueue -- discarded weak reference and cleared referent"));
                    }
                }
            }
        } else {
            if (false && CheneyCollector_tracing(this)) {
                VM_println_L(getObjectForCStringLiteral(131136, com_sun_squawk_CheneyCollector, "CheneyCollector::processWeakReferenceQueue -- discarded weak reference"));
            }
        }
        CheneyCollector_memoryProtect_AA(com_sun_squawk_CheneyCollector_fromSpaceStartPointer(this), com_sun_squawk_CheneyCollector_fromSpaceEndPointer(this));
        ref = next;
    }
    if (false && CheneyCollector_tracing(this)) {
        VM_println_L(getObjectForCStringLiteral(131137, com_sun_squawk_CheneyCollector, "CheneyCollector::processWeakReferenceQueue -- end"));
    }
}

static void VM_deadbeef_AA(Address start, Address end) {
    if (ASSUME || TYPEMAP) { while (start < end) { if (ASSUME) { *((UWord *)start) = DEADBEEF; } setType(start, AddressType_UNDEFINED, HDR_BYTES_PER_WORD); start = (UWord *)start + 1; } }
}


static void CheneyCollector_clearFromSpace(Address this) {
    VM_deadbeef_AA(com_sun_squawk_CheneyCollector_fromSpaceStartPointer(this), com_sun_squawk_CheneyCollector_fromSpaceEndPointer(this));
}

static void GC_setAllocationParameters_AAAA(Address heapStart, Address allocStart, Address allocEnd, Address heapEnd) {
    com_sun_squawk_GC_heapStart = heapStart;
    com_sun_squawk_GC_allocTop = com_sun_squawk_GC_allocStart = allocStart;
    com_sun_squawk_GC_allocEnd = allocEnd;
    com_sun_squawk_GC_heapEnd = heapEnd;
}

static boolean collectGarbage(Address this, Address allocTop, boolean forceFullGC) {
    jlong start;
    Address toSpaceUpdatePointer;
    start = GarbageCollector_now(this);
    if ((false || false) && GC_isTracing_I(16)) {
        CheneyCollector_traceHeap_LA(this, getObjectForCStringLiteral(131138, com_sun_squawk_CheneyCollector, "Before collection"), allocTop);
    }
    set_com_sun_squawk_GarbageCollector_numBytesLastScanned(this, Offset_toPrimitive(Address_diff_A(allocTop, com_sun_squawk_CheneyCollector_toSpaceStartPointer(this))));
    CheneyCollector_toggleSpaces(this);
    CheneyCollector_memoryProtect_AA(com_sun_squawk_CheneyCollector_fromSpaceStartPointer(this), com_sun_squawk_CheneyCollector_fromSpaceEndPointer(this));
    set_com_sun_squawk_CheneyCollector_Timings_setup(com_sun_squawk_CheneyCollector_collectionTimings(this), (com_sun_squawk_CheneyCollector_Timings_setup(com_sun_squawk_CheneyCollector_collectionTimings(this)) + GarbageCollector_now(this) - start));
    start = GarbageCollector_now(this);
    CheneyCollector_copyRootObjects(this);
    set_com_sun_squawk_CheneyCollector_Timings_copyRoots(com_sun_squawk_CheneyCollector_collectionTimings(this), +GarbageCollector_now(this) - start);
    start = GarbageCollector_now(this);
    toSpaceUpdatePointer = CheneyCollector_copyNonRootObjects_A(this, com_sun_squawk_CheneyCollector_toSpaceStartPointer(this));
    set_com_sun_squawk_CheneyCollector_Timings_copyNonRoots(com_sun_squawk_CheneyCollector_collectionTimings(this), (com_sun_squawk_CheneyCollector_Timings_copyNonRoots(com_sun_squawk_CheneyCollector_collectionTimings(this)) + GarbageCollector_now(this) - start));
    start = GarbageCollector_now(this);
    CheneyCollector_processWeakReferenceQueue(this);
    CheneyCollector_memoryProtect_AA(Address_zero(), Address_zero());
    CheneyCollector_clearFromSpace(this);
    GC_setAllocationParameters_AAAA(com_sun_squawk_CheneyCollector_toSpaceStartPointer(this), com_sun_squawk_CheneyCollector_toSpaceAllocationPointer(this), com_sun_squawk_CheneyCollector_toSpaceEndPointer(this), com_sun_squawk_CheneyCollector_toSpaceEndPointer(this));
    if ((false || false) && GC_isTracing_I(32)) {
        CheneyCollector_traceHeap_LA(this, getObjectForCStringLiteral(131139, com_sun_squawk_CheneyCollector, "After collection"), com_sun_squawk_CheneyCollector_toSpaceAllocationPointer(this));
    }
    set_com_sun_squawk_CheneyCollector_Timings_finalize(com_sun_squawk_CheneyCollector_collectionTimings(this), (com_sun_squawk_CheneyCollector_Timings_finalize(com_sun_squawk_CheneyCollector_collectionTimings(this)) + GarbageCollector_now(this) - start));
    return 1;
}

INLINE void GC_setHeaderClass_AL(Address oop, Address klass) {
    NativeUnsafe_setAddress_LIL(oop, -1, klass);
}

INLINE UWord GC_encodeLengthWord_I(int length) {
    if (length > 67108863) {
        GC_encodeLengthWordError();
    }
    return UWord_fromPrimitive_I((sll(length, 2)) | 1);
}

static Address VM_getOutOfMemoryError() {
    return com_sun_squawk_VM_outOfMemoryError;
}

NOINLINE void GC_encodeLengthWordError() {
    VM_println_L(getObjectForCStringLiteral(196608, com_sun_squawk_GC, "encodeLengthWord"));
    fatalVMError("java.lang.OutOfMemoryError");
}

INLINE void GC_setHeaderLength_AI(Address oop, int length) {
    NativeUnsafe_setUWord_LIU(oop, -2, GC_encodeLengthWord_I(length));
}

static Address VM_getCurrentIsolate() {
    return com_sun_squawk_VM_currentIsolate;
}

static Address Isolate_getBootstrapSuite(Address this) {
    return com_sun_squawk_Isolate_bootstrapSuite(this);
}

static boolean Suite_isBootstrap(Address this) {
    return com_sun_squawk_Suite_parent(this) == null;
}

INLINE unsigned short NativeUnsafe_charAt_LI(Address str, int index) {
    Address cls = com_sun_squawk_Klass_self(getObject(str, HDR_klass)); if (com_sun_squawk_Klass_id(cls) == com_sun_squawk_StringOfBytes) { return getUByte(str, index); } else { return getUShort(str, index); }
}


static int String_length(Address this) {
    return GC_getArrayLength_L(this);
}

static int String_compareTo_L(Address this, Address anotherString) {
    int len1;
    int len2;
    int lth;
    int i;
    len1 = String_length(this);
    len2 = String_length(nullPointerCheck(anotherString));
    lth = len1 < len2 ? len1 : len2;
    for (i = 0; i < lth; i++) {
        unsigned short c1;
        unsigned short c2;
        c1 = NativeUnsafe_charAt_LI(this, i);
        c2 = NativeUnsafe_charAt_LI(anotherString, i);
        if (c1 != c2) {
            return c1 - c2;
        }
    }
    return len1 - len2;
}

static Address Suite_lookup_L(Address this, Address name) {
    int i;
    if (!Suite_isBootstrap(this)) {
        Address klass;
        klass = Suite_lookup_L(nullPointerCheck(com_sun_squawk_Suite_parent(this)), name);
        if (klass != null) {
            return klass;
        }
    }
    for (i = 0; i < Array_length(com_sun_squawk_Suite_classes(this)); i++) {
        Address klass;
        klass = aload_o(com_sun_squawk_Suite_classes(this), i);
        if (klass != null) {
            if (String_compareTo_L(nullPointerCheck(Klass_getInternalName(nullPointerCheck(klass))), name) == 0) {
                return klass;
            }
        }
    }
    return null;
}

static Address Suite_getKlass_I(Address this, int suiteID) {
    
    return aload_o(com_sun_squawk_Suite_classes(this), suiteID);
}

static int CheneyCollector_countObjects_AA(Address this, Address start, Address end) {
    int count;
    Address block;
    count = 0;
    for (block = start; Address_lo_A(block, end); ) {
        Address object;
        Address klass;
        ++count;
        object = GC_blockToOop_A(block);
        klass = GC_getKlass_L(object);
        block = Address_add_I(object, GC_getBodySize_LA(klass, object));
    }
    return count;
}

static boolean CheneyCollector_initializeForwardingRepairMap_AAA(Address this, Address allocStart, Address allocTop, Address allocEnd) {
    int mapSize;
    int freeSpace;
    mapSize = (CheneyCollector_countObjects_AA(this, allocStart, allocTop) * 2) * 4;
    freeSpace = Offset_toInt(Address_diff_A(allocEnd, allocTop));
    if (freeSpace < mapSize) {
        return 0;
    }
    set_com_sun_squawk_CheneyCollector_forwardingRepairMapTop(this, Address_sub_I(allocEnd, mapSize));
    set_com_sun_squawk_CheneyCollector_forwardingRepairMap(this, com_sun_squawk_CheneyCollector_forwardingRepairMapTop(this));
    return 1;
}

static void CheneyCollector_repairForwardedObjects(Address this) {
    Address address;
    address = com_sun_squawk_CheneyCollector_forwardingRepairMap(this);
    while (Address_ne_A(address, com_sun_squawk_CheneyCollector_forwardingRepairMapTop(this))) {
        Address forwardedObject;
        UWord classWord;
        forwardedObject = NativeUnsafe_getObject_LI(address, 0);
        classWord = NativeUnsafe_getUWord_LI(address, 1);
        NativeUnsafe_setAddress_LIL(forwardedObject, -1, Address_or_U(Address_zero(), classWord));
        address = Address_add_I(address, 4 * 2);
    }
}

static Address copyObjectGraph(Address this, Address object, Address cb, Address allocTop) {
    jlong start;
    Address graph;
    Address graphEnd;
    Address graphCopy;
    int graphSize;
    int freeSpace;
    if (com_sun_squawk_CheneyCollector_HashTableKlass(this) == null) {
        Address isolate;
        Address bootstrapSuite;
        isolate = VM_getCurrentIsolate();
        bootstrapSuite = Isolate_getBootstrapSuite(nullPointerCheck(isolate));
        set_com_sun_squawk_CheneyCollector_HashTableKlass(this, Suite_lookup_L(nullPointerCheck(bootstrapSuite), getObjectForCStringLiteral(131140, com_sun_squawk_CheneyCollector, "com.sun.squawk.util.SquawkHashtable")));
        set_com_sun_squawk_CheneyCollector_ByteArrayKlass(this, Suite_getKlass_I(nullPointerCheck(bootstrapSuite), 19));
        set_com_sun_squawk_CheneyCollector_IsolateKlass(this, GC_getKlass_L(isolate));
    }
    start = GarbageCollector_now(this);
    if (!CheneyCollector_initializeForwardingRepairMap_AAA(this, com_sun_squawk_CheneyCollector_toSpaceStartPointer(this), allocTop, com_sun_squawk_CheneyCollector_toSpaceEndPointer(this))) {
        return Address_zero();
    }
    set_com_sun_squawk_CheneyCollector_copyingObjectGraph(this, 1);
    set_com_sun_squawk_CheneyCollector_oopMap(this, com_sun_squawk_ObjectMemorySerializer_ControlBlock_oopMap(nullPointerCheck(cb)));
    if (GC_getKlass_L(Address_toObject(object)) == com_sun_squawk_CheneyCollector_IsolateKlass(this)) {
        set_com_sun_squawk_CheneyCollector_theIsolate(this, (Address)Address_toObject(object));
    }
    CheneyCollector_toggleSpaces(this);
    set_com_sun_squawk_CheneyCollector_Timings_setup(com_sun_squawk_CheneyCollector_copyTimings(this), (com_sun_squawk_CheneyCollector_Timings_setup(com_sun_squawk_CheneyCollector_copyTimings(this)) + GarbageCollector_now(this) - start));
    start = GarbageCollector_now(this);
    object = CheneyCollector_copyObject_A(this, object);
    CheneyCollector_copyNonRootObjects_A(this, com_sun_squawk_CheneyCollector_toSpaceStartPointer(this));
    set_com_sun_squawk_CheneyCollector_Timings_copyNonRoots(com_sun_squawk_CheneyCollector_copyTimings(this), (com_sun_squawk_CheneyCollector_Timings_copyNonRoots(com_sun_squawk_CheneyCollector_copyTimings(this)) + GarbageCollector_now(this) - start));
    graph = com_sun_squawk_CheneyCollector_toSpaceStartPointer(this);
    graphEnd = com_sun_squawk_CheneyCollector_toSpaceAllocationPointer(this);
    
    CheneyCollector_toggleSpaces(this);
    start = GarbageCollector_now(this);
    CheneyCollector_repairForwardedObjects(this);
    set_com_sun_squawk_CheneyCollector_Timings_repair(com_sun_squawk_CheneyCollector_copyTimings(this), (com_sun_squawk_CheneyCollector_Timings_repair(com_sun_squawk_CheneyCollector_copyTimings(this)) + GarbageCollector_now(this) - start));
    graphSize = Offset_toInt(Address_diff_A(graphEnd, graph));
    freeSpace = Offset_toInt(Address_diff_A(com_sun_squawk_CheneyCollector_toSpaceEndPointer(this), allocTop)) - 8;
    if (graphSize <= freeSpace) {
        start = GarbageCollector_now(this);
        graphCopy = Address_add_I(allocTop, 4);
        GC_setHeaderClass_AL(graphCopy, com_sun_squawk_CheneyCollector_ByteArrayKlass(this));
        GC_setHeaderLength_AI(graphCopy, graphSize);
        VM_copyBytes_AIAIIZ(graph, 0, graphCopy, 0, graphSize, 0);
        set_com_sun_squawk_ObjectMemorySerializer_ControlBlock_root(cb, Offset_toInt(Address_diff_A(object, graph)));
        set_com_sun_squawk_ObjectMemorySerializer_ControlBlock_start(cb, graph);
        allocTop = Address_add_I(graphCopy, graphSize);
        GC_setAllocationParameters_AAAA(com_sun_squawk_CheneyCollector_toSpaceStartPointer(this), allocTop, com_sun_squawk_CheneyCollector_toSpaceEndPointer(this), com_sun_squawk_CheneyCollector_toSpaceEndPointer(this));
        if (false && CheneyCollector_tracing(this)) {
            VM_println();
            VM_print_L(getObjectForCStringLiteral(131141, com_sun_squawk_CheneyCollector, "CheneyCollector::copyObjectGraph - graph = "));
            VM_printAddress_A(graph);
            VM_print_L(getObjectForCStringLiteral(131142, com_sun_squawk_CheneyCollector, " graphEnd = "));
            VM_printAddress_A(graphEnd);
            VM_print_L(getObjectForCStringLiteral(131143, com_sun_squawk_CheneyCollector, " cb.size "));
            VM_print_I(Array_length(com_sun_squawk_ObjectMemorySerializer_ControlBlock_memory(nullPointerCheck(cb))));
            VM_println();
        }
    } else {
        start = GarbageCollector_now(this);
        graphCopy = Address_zero();
    }
    set_com_sun_squawk_CheneyCollector_copyingObjectGraph(this, 0);
    set_com_sun_squawk_CheneyCollector_theIsolate(this, null);
    set_com_sun_squawk_CheneyCollector_oopMap(this, null);
    set_com_sun_squawk_CheneyCollector_Timings_finalize(com_sun_squawk_CheneyCollector_copyTimings(this), (com_sun_squawk_CheneyCollector_Timings_finalize(com_sun_squawk_CheneyCollector_copyTimings(this)) + GarbageCollector_now(this) - start));
    return graphCopy;
}

static int VMBufferDecoder_nextByte(Address this) {
    int b;
    b = NativeUnsafe_getByte_LI(com_sun_squawk_VMBufferDecoder_oop(this), com_sun_squawk_VMBufferDecoder_offset(this));
    set_com_sun_squawk_VMBufferDecoder_offset(this, (com_sun_squawk_VMBufferDecoder_offset(this) + 1));
    return b;
}

INLINE boolean VM_instanceof(Address obj, Address klass) {
    
    return Klass_isAssignableFrom_L(nullPointerCheck(klass), GC_getKlass_L(obj));
}

INLINE boolean Klass_isSubtypeOf_L(Address this, Address klass) {
    return Klass_isSubtypeOf_LL(this, klass);
}

#define  Klass_isAssignableFrom0_L(this,  klass) (false)


INLINE int Klass_getModifiers(Address this) {
    return com_sun_squawk_Klass_modifiers(this);
}

INLINE boolean Klass_isArray(Address this) {
    return Modifier_isArray_I(Klass_getModifiers(this));
}

INLINE Address Klass_getComponentType(Address this) {
    return Klass_getComponentType_L(this);
}

INLINE boolean Klass_isInterface(Address this) {
    return Modifier_isInterface_I(Klass_getModifiers(this));
}

static int Klass_getState(Address this) {
    return com_sun_squawk_Klass_state(this);
}

static boolean Klass_isImplementorOf_L(Address this, Address anInterface) {
    int i;
    
    for (i = 0; i < Array_length(com_sun_squawk_Klass_interfaces(this)); i++) {
        Address iface;
        iface = aload_o(com_sun_squawk_Klass_interfaces(this), i);
        if (iface == anInterface || Klass_isImplementorOf_L(nullPointerCheck(iface), anInterface)) {
            return 1;
        }
    }
    if (com_sun_squawk_Klass_superType(this) != null) {
        return Klass_isImplementorOf_L(nullPointerCheck(com_sun_squawk_Klass_superType(this)), anInterface);
    }
    return 0;
}

static boolean Klass_isAssignableFrom_L(Address this, Address klass) {
    
    if (this == klass) {
        return 1;
    }
    if (Klass_isSubtypeOf_L(nullPointerCheck(klass), this)) {
        return 1;
    }
    if (Klass_isAssignableFrom0_L(this, klass)) {
        return 1;
    }
    if (Klass_isArray(this)) {
        if (Klass_isArray(nullPointerCheck(klass))) {
            return Klass_isAssignableFrom_L(nullPointerCheck(Klass_getComponentType(this)), Klass_getComponentType(nullPointerCheck(klass)));
        }
    } else {
        if (Klass_isInterface(this)) {
            return Klass_isImplementorOf_L(nullPointerCheck(klass), this);
        }
    }
    return 0;
}

INLINE int VM_arrayOopStoreCheck(Address array, int index, Address value) {
    Address arrayKlass;
    Address componentType;
    arrayKlass = GC_getKlass_L(array);
    
    
    componentType = Klass_getComponentType(nullPointerCheck(arrayKlass));
    if (com_sun_squawk_VM_synchronizationEnabled == 0 || Klass_isAssignableFrom_L(nullPointerCheck(componentType), GC_getKlass_L(value))) {
        return 0;
    } else {
        com_sun_squawk_VM_reportedArray = array;
        com_sun_squawk_VM_reportedIndex = index;
        return 1;
    }
}

INLINE int VM_findSlot(Address obj, Address iklass, int islot) {
    Address klass;
    int result;
    klass = GC_getKlass_L(obj);
    result = Klass_findSlot_LI(nullPointerCheck(klass), iklass, islot);
    return result;
}

static boolean Modifier_isAbstract_I(int mod) {
    return (mod & 1024) != 0;
}

static boolean Klass_isAbstract(Address this) {
    return Modifier_isAbstract_I(Klass_getModifiers(this));
}

static int Klass_findSlot_LI(Address this, Address iklass, int islot) {
    if (!Klass_isAbstract(this)) {
        int icount;
        int i;
        icount = Array_length(com_sun_squawk_Klass_interfaces(this));
        for (i = 0; i < icount; i++) {
            if (aload_o(com_sun_squawk_Klass_interfaces(this), i) == iklass) {
                return aload_s(aload_o(com_sun_squawk_Klass_interfaceVTableMaps(this), i), islot);
            }
        }
    }
    if (com_sun_squawk_Klass_superType(this) == null) {
        return -1;
    }
    return Klass_findSlot_LI(nullPointerCheck(com_sun_squawk_Klass_superType(this)), iklass, islot);
}

INLINE Address VM_getClassState(Address klass) {
    return Isolate_getClassStateForInterpreter_L(nullPointerCheck(com_sun_squawk_VM_currentIsolate), klass);
}

INLINE void VM_addToClassStateCache_LL(Address klass, Address state) {
    addClassState(klass, state);
}


INLINE void NativeUnsafe_setObject_LIL(Address base, int offset, Address value) {
    setObjectAndUpdateWriteBarrier(base, offset, value);
}


NOINLINE Address Isolate_getClassStateForInterpreter_L(Address this, Address klass) {
    Address first;
    first = com_sun_squawk_Isolate_classStateQueue(this);
    if (first == null) {
        return null;
    }
    if (NativeUnsafe_getObject_LI(first, 0) == klass) {
        VM_addToClassStateCache_LL(klass, first);
        return first;
    } else {
        Address last;
        Address ks;
        last = first;
        ks = NativeUnsafe_getObject_LI(first, 1);
        while (ks != null) {
            Address ksnext;
            ksnext = NativeUnsafe_getObject_LI(ks, 1);
            if (NativeUnsafe_getObject_LI(ks, 0) == klass) {
                
                NativeUnsafe_setObject_LIL(last, 1, ksnext);
                NativeUnsafe_setObject_LIL(ks, 1, first);
                set_com_sun_squawk_Isolate_classStateQueue(this, ks);
                VM_addToClassStateCache_LL(klass, ks);
                return ks;
            }
            last = ks;
            ks = ksnext;
        }
    }
    return null;
}

INLINE boolean VM_isHosted() {
    return 0;
}

INLINE boolean Address_hi_A(Address this, Address address2) {
    return this > address2;
}


INLINE boolean GC_inRam_L(Address object) {
    if (VM_isHosted()) {
        return GC_inRamHosted_L(object);
    } else {
        Address ptr;
        ptr = Address_fromObject_L(object);
        if (Address_loeq_A(ptr, com_sun_squawk_GC_ramStart)) {
            return 0;
        } else if (Address_hi_A(ptr, com_sun_squawk_GC_ramEnd)) {
            return 0;
        }
    }
    return 1;
}

static boolean GC_inRamHosted_L(Address object) {
    fatalVMError("hosted-only method"); return false;
}


INLINE boolean VM_inRam(Address object) {
    return GC_inRam_L(object);
}

NOINLINE int VM_lookup_b(int key, Address array) {
    int low;
    int high;
    low = 0;
    high = Array_length(array) - 1;
    while (low <= high) {
        int mid;
        int val;
        mid = srl((low + high), 1);
        val = aload_b(array, mid);
        if (key < val) {
            high = mid - 1;
        } else if (key > val) {
            low = mid + 1;
        } else {
            return mid;
        }
    }
    return -1;
}

NOINLINE int VM_lookup_i(int key, Address array) {
    int low;
    int high;
    low = 0;
    high = Array_length(array) - 1;
    while (low <= high) {
        int mid;
        int val;
        mid = srl((low + high), 1);
        val = aload_i(array, mid);
        if (key < val) {
            high = mid - 1;
        } else if (key > val) {
            low = mid + 1;
        } else {
            return mid;
        }
    }
    return -1;
}

NOINLINE int VM_lookup_s(int key, Address array) {
    int low;
    int high;
    low = 0;
    high = Array_length(array) - 1;
    while (low <= high) {
        int mid;
        int val;
        mid = srl((low + high), 1);
        val = aload_s(array, mid);
        if (key < val) {
            high = mid - 1;
        } else if (key > val) {
            low = mid + 1;
        } else {
            return mid;
        }
    }
    return -1;
}

Address *ALL_LITERALS[4];
Address LITERALS_FOR_com_sun_squawk_VM[2] = {
    NULL, NULL};
Address LITERALS_FOR_com_sun_squawk_GarbageCollector[13] = {
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL};
Address LITERALS_FOR_com_sun_squawk_GC[1] = {NULL};
Address LITERALS_FOR_com_sun_squawk_CheneyCollector[72] = {
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL};

Address findCStringInObjects(Address objects, int length, const char *s) {
    int i = 0;
    int slen = strlen(s);
    while (i != length) {
        Address object = aload_o(objects, i);
        if (strncmp(s, (const char *)object, slen) == 0) {
            assume(!GC_inRam_L(object));
            return object;
        }
        ++i;
    }
    return null;
}

Address getObjectForCStringLiteral(int key, int klassIndex, const char *cstr) {
    static boolean initialized = false;
    int classKey = key >> 16 & 0xFFFF;
    int literalKey = key & 0xFFFF;
    Address *literals;
    Address str;

    if (!initialized) {
        initialized = true;
        ALL_LITERALS[0] =  LITERALS_FOR_com_sun_squawk_VM;
        ALL_LITERALS[1] =  LITERALS_FOR_com_sun_squawk_GarbageCollector;
        ALL_LITERALS[3] =  LITERALS_FOR_com_sun_squawk_GC;
        ALL_LITERALS[2] =  LITERALS_FOR_com_sun_squawk_CheneyCollector;
    }

    literals = ALL_LITERALS[classKey];
    str = literals[literalKey];
    if (str == null) {
        Address bootstrapSuite = com_sun_squawk_ObjectMemory_root(aload_o(com_sun_squawk_GC_readOnlyObjectMemories, 0));
        Address classes = com_sun_squawk_Suite_classes(bootstrapSuite);
        Address klass = aload_o(classes, klassIndex);
        Address objects = com_sun_squawk_Klass_objects(klass);
        int length = Array_length(objects);

        str = findCStringInObjects(objects, length, cstr);
        if (str == null) {
            fatalVMError("accessing string literal in conditionally compiled out code");
        }
        literals[literalKey] = str;
    }
    return str;
}
