/*
 * Copyright 2004-2008 Sun Microsystems, Inc. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Sun Microsystems, Inc., 16 Network Circle, Menlo
 * Park, CA 94025 or visit www.sun.com if you need additional
 * information or have any questions.
 */

package com.sun.squawk.debugger.sdp;

import java.io.*;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.SocketException;

import com.sun.squawk.debugger.*;
import com.sun.squawk.debugger.DataType.*;
import com.sun.squawk.debugger.EventRequestModifier.*;
import com.sun.squawk.util.*;
import java.util.*;
import com.sun.squawk.*;

/**
 * A SDB (Squawk Debugger Proxy) instance intercedes for a SDA
 * (Squawk Debug Agent) when it's connected to a JPDA compliant debugger.
 *
 */
public class SDP {
    protected static final byte KILL_MARKER1 = (byte) 129;
    protected static final byte KILL_MARKER2 = 126;

    /**
     * The object managing proxy types and reference type identifiers.
     */
    private ProxyTypeManager ptm;

    /**
     * The URL of the channel to the VM running the application to be debugged.
     */
    private String vm_url = "socket://localhost:2800";

    /**
     * Seconds to wait before retrying to connect to a Squawk VM.
     */
    private int retry = 5;

    /**
     * UDP port number I listen to in order to be told I should shut down.
     * If this port is bound already, then another instance is running already,
     * go up by one until not bound, then send a kill signal to the original port
     * number and keep going until I can bind to this port.
     */
    protected int killPort;

    /**
     * The URL of the channel to the debugger client.
     */
    private String debugger_url = "serversocket://:2900";
    
    /**
     * This is a unique name of the proxy. Typically it is the port number in the debugger_url,
     * so the default name is "2900";
     */
    private String proxyName;

    /**
     * The connection to the JPDA compliant debugger (e.g. jdb).
     */
    private JDBListener jdb;

    /**
     * The connection to the Squawk Debug Agent running in the Squawk VM.
     */
    private SDAListener sda;

    /**
     * The manager of JDWP events generated by the SDA and event
     * requests sent from jdb.
     */
    SDPEventManager eventManager;

    ProxyTypeManager getPTM() {
        return ptm;
    }

    private ThreadProxiesManager tpm;

	private boolean singleSession = false;
    
    /**
     * Act as a JDWP packet sniffer between a JVM and a debugger.
     */
    private boolean sniffOnly = false;
    
    /**
     * If false, the proxy will try to continue executing in the face of certain errors.
     */
    boolean quitOnError = true;
    
    /**
     *Set true once the VM and proxy have exchanged all info.
     */
    private boolean canTalkToDebugger;
    
    /**
     * @see getSDP()
     */
     private static Hashtable<String, SDP> sdpTable = new Hashtable<String, SDP>();
     
    /**
     * Return the active SDP instance named proxyName. 
     * Used when running SDP embedded in the same Java process as controller, as in Solarium
     * 
     * @param proxyName name to look for
     * @return the SDP instance named proxyName, or null if no active proxy by the name.
     */
     public static SDP getSDP(String proxyName) {
         return (SDP)sdpTable.get(proxyName);
     }
     
    /**
     * Return the unique name of the proxy. Typically it is the port number in the debugger_url,
     * so the default name is "2900";
     * 
     * @return the proxy name
     */
     public String getProxyName() {
         return proxyName;
     }
    
    /**
     * set to true if sdp.quit() was called.
     */
    private boolean quitSDP;
    

    ThreadProxiesManager getTPM() {
        return tpm;
    }

    static class ThreadProxiesManager {

        /**
         * VM thread status mirrors of live threads.
         */
        private Map<ObjectID, ProxyThread>  liveThreads = new HashMap<ObjectID, ProxyThread> ();
        
        /**
         * Also keep track of zombie threads debugger might ask about them.
         */
        private HashMap<ObjectID, ProxyThread> zombieThreads = new HashMap<ObjectID, ProxyThread>();

        synchronized void suspendAllThreads() {
            for (Iterator i = liveThreads.values().iterator(); i.hasNext(); ) {
                ProxyThread pt = (ProxyThread)i.next();
                pt.setSuspendCount(pt.getSuspendCount() + 1);
            }
        }

        synchronized ProxyThread getRunningThread() {
            for (Iterator i = liveThreads.values().iterator(); i.hasNext(); ) {
                ProxyThread thread = (ProxyThread) i.next();
                if (thread.getStatus() == JDWP.ThreadStatus_RUNNING && !thread.isSuspended()) {
                    return thread;
                }
            }
            return null;
        }
        
        /** 
         * To report bootstrap classes, we need a thread to claim repsonisibility. Choose any.
         * Tends to be the isolate's main thread, when called at startup.
         */
        synchronized ProxyThread getSomeThread() {
            for (Iterator i = liveThreads.values().iterator(); i.hasNext(); ) {
                return (ProxyThread) i.next();
            }
            return null;
        }

        /**
         * Gets all the mirrors.
         */
        synchronized Collection<ProxyThread> getThreads() {
            Assert.that(!liveThreads.isEmpty());
            return new ArrayList<ProxyThread> (liveThreads.values());
        }

        /**
         * Gets a thread mirror based on an object identifier.
         * Note that the thread may not be alive.
         *
         * @param id   the ID of the thread to retrieve
         * @return the thread corresponding to <code>id</code>
         * @throws SDWPException if there is no thread corresponding to id
         */
        synchronized ProxyThread getThread(ObjectID id) throws SDWPException {
            ProxyThread thread = (ProxyThread) liveThreads.get(id);
            if (thread == null) {
                // debugger could be asking about now dead thread. Check zombie list:
                thread = (ProxyThread) zombieThreads.get(id);
                if (thread == null) {
                    throw new SDWPException(JDWP.Error_INVALID_THREAD, "object ID does not denote a Thread instance: " + id);
                }
            }
            return thread;
        }

        /**
         * Updates the thread mirrors based on a packet from the VM.
         */
        synchronized void updateThreads(PacketInputStream in) throws IOException {
            int count = in.readInt("threads");
            Map<ObjectID, ProxyThread>  nowLive = new HashMap<ObjectID, ProxyThread> (count);
            
            for (int i = 0; i != count; ++i) {
                ObjectID id = in.readObjectID("thread");
                int status = in.readInt("status");
                int suspendCount = in.readInt("suspendCount");
                String name = in.readString("name");

                ProxyThread thread = (ProxyThread)liveThreads.get(id);
                if (thread == null) {
                    thread = new ProxyThread(id, name, status, suspendCount);
                    liveThreads.put(id, thread); // add new threads to global list;
                } else {
                    thread.setName(name);
                    thread.setStatus(status);
                    thread.setSuspendCount(suspendCount);
                }
                nowLive.put(id, thread);
            }
            
            // notice dead threads
            Set liveThreadKeys = liveThreads.keySet();
            for (Iterator i = liveThreadKeys.iterator(); i.hasNext(); ) {
                ObjectID id = (ObjectID) i.next();
                if (nowLive.get(id) == null) {
                    ProxyThread deadThread = (ProxyThread)liveThreads.get(id);
                    deadThread.setStatus(JDWP.ThreadStatus_ZOMBIE);
                    deadThread.setSuspendCount(0);
                    i.remove();
                    Assert.always(liveThreads.get(id) == null);
                    zombieThreads.put(id, deadThread);
                }
            }
        }

        synchronized void updateThread(ObjectID id, String name, int status, int suspendCount) {
            Assert.always(zombieThreads.get(id) == null); // zombies shouldn't come back to life.'

            ProxyThread thread = (ProxyThread)liveThreads.get(id);
            if (thread == null) {
                thread = new ProxyThread(id, name, status, suspendCount);
                liveThreads.put(id, thread);
            } else {
                thread.setName(name);
                thread.setStatus(status);
                thread.setSuspendCount(suspendCount);
            }
            
            if (status == JDWP.ThreadStatus_ZOMBIE) {
                liveThreads.remove(id);
                zombieThreads.put(id, thread);
            }
        }
    }


    /**
     * Parses the command line arguments to configure this debugger proxy.
     *
     * @param args  the command line arguments
     * @return      true if there were no errors in the arguments and this debugger proxy is now configured
     */
    private boolean parseArgs(String args[]) {
        String logLevel = "none";
        String logURL = null;
        String classPath = null;

        for (int argc = 0; argc != args.length; ++argc) {
            String arg = args[argc];
            try {
                if (arg.startsWith("-cp:")) {
                    classPath = ArgsUtilities.toPlatformPath(arg.substring("-cp:".length()), true);
                } else if (arg.startsWith("-log:")) {
                    logLevel = arg.substring("-log:".length());
                } else if (arg.startsWith("-logFile:")) {
                    logURL = "file://" + arg.substring("-logFile:".length());
                } else if (arg.startsWith("-replay:")) {
                    debugger_url = arg.substring("-replay:".length());
                } else if (arg.startsWith("-l:")) {
                    debugger_url = "serversocket://:" + arg.substring("-l:".length());
                } else if (arg.startsWith("-vm:")) {
                    vm_url = arg.substring("-vm:".length());
                } else if (arg.startsWith("-debugger:")) {
                    debugger_url = arg.substring("-debugger:".length());
                } else if (arg.startsWith("-retry:")) {
                    try {
                        retry = Integer.parseInt(arg.substring("-retry:".length()));
                    } catch (NumberFormatException e) {
                        usage("argument to '-retry' must be an integer");
                        return false;
                    }
                } else if (arg.startsWith("-quitOnError:")) {
                    String boolStr = arg.substring("-quitOnError:".length());
                    quitOnError = Boolean.parseBoolean(boolStr);
                } else if (arg.equals("-h")) {
                    usage(null);
                    return false;
                } else if (arg.equals("-singlesession")) {
                	singleSession = true;
                } else if (arg.equals("-sniffer")) {
                	sniffOnly = true;
                } else if (arg.startsWith("-killport:")) {
                    try {
                        killPort = Integer.parseInt(arg.substring("-killport:".length()));
                    } catch (NumberFormatException e) {
                        usage("Expected integer argument " + arg);
                        return false;
                    }
                } else {
                    usage("Unknown option: " + arg);
                    return false;
                }
            } catch (NumberFormatException e) {
                System.err.println("Badly formatted option: " + arg);
                return false;
            }
        }

        if (!sniffOnly) {
            if (classPath == null) {
                System.err.println("A path for the Squawk classes must be specified using the -cp option. For example:");
                System.err.println("    -cp:j2me/j2meclasses:debugger/j2meclasses:samples/j2meclasses");
                return false;
            }
            ProxySupport.initializeTranslator(classPath);
        }

        System.setProperty("squawk.debugger.log.level", logLevel);
        if (logURL != null) {
            System.setProperty("squawk.debugger.log.url", logURL);
        }
        
        if (debugger_url.indexOf("serversocket://:") == 0) {
            proxyName = debugger_url.substring("serversocket://:".length());
        } else {
            proxyName = debugger_url;
        }
        
        return true;
    }

    /**
     * Prints a usage message to the console.
     *
     * @param errMsg  an optional error message to print first
     */
    private void usage(String errMsg) {
        PrintStream out = System.out;
        if (errMsg != null) {
            out.println(errMsg);
        }
        out.println("Usage: SDP [-options] ");
        out.println("where options include:");
        out.println();
        out.println("    -debugger:<url> The URL of the channel that debug proxy will");
        out.println("                    listen on for a connection from a JPDA debugger.");
        out.println("                    Only specify -debugger OR -l, not both.");
        out.println("                    (default is " + debugger_url + ").");
        out.println("    -retry:<n>      retry to connect to VM every 'n' seconds (default is " + retry +")");
        out.println("    -l:<port>       local port number that the debug proxy will");
        out.println("                    listen on for a connection from a JPDA debugger.");
        out.println("                    (default is 2900)");
        out.println("    -vm:<url>       The URL of the channel to the VM running the");
        out.println("                    application to be debugged.");
        out.println("                    (default is " + vm_url + ").");
        out.println("    -log:<level>    sets logging level to 'none', 'info', 'verbose' or 'debug'");
        out.println("    -logFile:<file> where messages should be logged (default is stdout),");
        out.println("    -cp:<path>      a list of paths separated by '" + File.pathSeparator + "' where the");
        out.println("                    debug proxy can find class files.");
        out.println("                    (default is '.')");
        out.println("    -singlesession  allow only one connection from a debugger before exiting");
        out.println("    -sniffer        act as a JDWP packet sniffer between a JVM and a debugger,");
        out.println("                    logging packets as specified by -log and -logfile options.");
        out.println("    -quitOnError:<b> If false, the proxy will try to ignore certain proxy errors.");
        out.println("                    (default is true).");
        out.println("    -h              shows this usage message");
        out.println();
    }

    /**
     * Quit this proxy
     */
    public void quit() {
        quitSDP = true;
        if (sda != null) {
            sda.quit();
        }
        if (jdb != null) {
            jdb.quit();
        }
    }
    
    /**
     * Set true once VM and proxy have exchanged info.
     */
    synchronized void setCanTalkToDebugger() {
        canTalkToDebugger = true;
        notifyAll();
    }
    
    synchronized void waitTillReadyForDebugger0(boolean showProgress) throws SDWPException {
        if (showProgress) {
            // System.out.print("Synchronizing debug state with VM for isolate " + sdaListener.isolateName + "...");
            System.out.print("Synchronizing debug state with VM...");
            System.out.flush();
        }
        while (!canTalkToDebugger) {
            if (Log.debug()) {
                Log.log("Waiting for proxy types to be populated...");
            }
            try {
                wait(500);
            } catch (InterruptedException ex) {
            }
            if (showProgress) {
                System.out.print(".");
                System.out.flush();
            }
            if (sda.hasQuit()) {
                throw new SDWPException();
            }
             if (Log.debug() && canTalkToDebugger) {
                Log.log("...Proxy types are populated");
            }
        }
        if (showProgress) {
            System.out.println("");
            System.out.flush();
        }
    }
    
    /**
     * Wait until the VM and the proxy have synchronized before connecting to debugger.
     * This can be called by threads external to the proxy to decide when to start up the Debugger.
     * @return true if safe, false if some error orccurred.
     */
    public boolean waitTillReadyForDebugger() {
        try {
            waitTillReadyForDebugger0(false);
            return true;
        } catch (SDWPException e) {
            System.err.println("Error while waiting for proxy to sync with VM: " + e);
        }
        return false;
    }
    
    /**
     * Connect to VM, either for debugging or sniffing.
     * This is a static method to avoid sharing data unintentioanlly in the sniffing case...
     * 
     * @param sdp this proxy
     * @param toVM if true, connect to VM, otherwise to debugger.
     * @param sda the listener (SDAListener or sniffer)
     * @param handshakeStr
     * @param url
     * @return true if connected
     */
    private static boolean connect(boolean toVM, final SDP sdp, JDWPListener listener, String handshakeStr, String url) {
        byte[] handshake = handshakeStr.getBytes();
        String targetName = toVM ? "VM" : "Debugger";
        do {
            try {
                long now = System.currentTimeMillis();
                if (toVM) {
                    System.out.println("Trying to connect to VM on " + url);
                    listener.open(url, handshake, true, false, null);
                } else {
                    System.out.println("Waiting for connection from debugger on " + url);
                    
                    listener.open(url, handshake, false, true, new Runnable() {
                        public void run() {
                            try {
                                sdp.waitTillReadyForDebugger0(true);
                            } catch(SDWPException e) {
                                
                            }
                        }
                    });
                }

                System.out.println("Established connection to " + targetName + " (handshake took " + (System.currentTimeMillis() - now) + "ms)");
                return true;
            } catch (IOException e) {
                if (sdp.quitSDP) {
                    return false;
                }
                System.out.println("Failed to establish connection with " + targetName + ": " + e.getMessage() + " - trying again in " + sdp.retry + " seconds...");

                // Sleep and try again
                try {
                    Thread.sleep(sdp.retry * 1000);
                } catch (InterruptedException ie) {
                }
            }
        } while (toVM); // only loop for VM connect
        return false;
    }
    
    private static boolean connectToVM(SDP sdp, JDWPListener listener, String handshakeStr) {
        return connect(true, sdp, listener, handshakeStr, sdp.vm_url);
    }

    private static boolean connectToDebugger(SDP sdp, JDWPListener listener, String handshakeStr) {
        return connect(false, sdp, listener, handshakeStr, sdp.debugger_url);
    }
        
    /**
     * Starts a single debug session between a VM and a debug client. Returns
     * when the session is closed from either end.
     */
    private void go() {
        // Establish the connection to the VM
        sda = new SDAListener(this);
        ptm = new ProxyTypeManager();
        tpm = new ThreadProxiesManager();
        if (!connectToVM(this, sda, "SDWP-Handshake")) {
            return;
        }
        ptm.setVM(sda);

        // Establish connection from debugger
        jdb = new JDBListener(this);
        jdb.bindProxyPeer(sda);
        eventManager = new SDPEventManager(new MatcherImpl());

        //
        // Two threads are required here so that we can listen to
        // the debugger and the VM at the same time. Each thread
        // knows how to talk to the other so that information can flow
        // over the proxy.
        //
        Thread sdaThread = new Thread(sda, "SDAListener");
        Thread jdbThread = new Thread(jdb, "JDBListener");

        sdaThread.start();
        try { // let sdaThread get ahead a bit...
            Thread.sleep(100);
        } catch (InterruptedException interruptedException) {
        }

        if (!connectToDebugger(this, jdb, "JDWP-Handshake")) {
            sda.quit();
            jdb.quit();
            return;
        }
                
        if (!sda.hasQuit()) {
            jdbThread.start();
        }

        // At this point we have successfully connected the debugger
        // through this proxy to the Squawk VM. We can now sit back and
        // wait for packets to start flowing.
        try {
            sdaThread.join();
            jdbThread.join();
        } catch (InterruptedException ex) {
        }

        if (Log.info()) {
            Log.log("Completed shutdown");
        }
        System.out.println("Debug session completed.");
        System.out.println();
    }

    public static void main(String args[]) throws IOException {
//        Log.level = Log.INFO;
        SDP sdp = new SDP();
        try {

            Thread.currentThread().setName("SDP");

            if (!sdp.parseArgs(args)) {
                System.exit(1);
            }
            if (sdp.killPort != 0) {
                killOthers(sdp.killPort, sdp);
            }
            sdpTable.put(sdp.getProxyName(), sdp);
            do {
                if (sdp.sniffOnly) {
                    sdp.goSniff();
                } else {
                    sdp.go();
                }
            } while (!sdp.singleSession);
        } finally {
            sdpTable.remove(sdp.getProxyName());
        }
    }
    
    public static void killOthers(final int killPort, final SDP me) {
        DatagramSocket socket = null;
        while (true) {
            int currentKillPort = killPort;
            while (true) {
                try {
                    if (Log.verbose()) {
                        Log.log("--- trying port " + currentKillPort);
                    }
                    socket = new DatagramSocket(currentKillPort);
                    if (Log.verbose()) {
                        Log.log("--- got it");
                    }
                    break;
                } catch (SocketException e) {
                    currentKillPort++;
                }
            }
            if (currentKillPort == killPort) {
                break;
            }
            byte[] buffer = new byte[2];
            buffer[0] = KILL_MARKER1;
            buffer[1] = KILL_MARKER2;
            DatagramPacket packet = null;
            try {
                packet = new DatagramPacket(buffer, 0, buffer.length, new InetSocketAddress(killPort));
            } catch (Exception e) {
                continue;
            }
            try {
                if (Log.verbose()) {
                    Log.log("--- sending kill");
                }
                socket.send(packet);
            } catch (IOException e) {
            }
            socket.close();
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
            }
        }
        if (Log.verbose()) {
            Log.log("--- getting ready to listen for kill");
        }
        final DatagramSocket finalSocket = socket;
        Thread thread = new Thread(new Runnable() {
            public void run() {
                byte[] buffer = new byte[2];
                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
                while (true) {
                    try {
                        finalSocket.receive(packet);
                        if (packet.getLength() != 2) {
                            continue;
                        }
                        if (buffer[0] != KILL_MARKER1) {
                            continue;
                        }
                        if (buffer[1] != KILL_MARKER2) {
                            continue;
                        }
                        if (Log.verbose()) {
                            Log.log("--- received kill");
                        }
                        me.quit();
                        finalSocket.close();
                    } catch (IOException e) {
                        break;
                    }
                }
            }
        });
        thread.setName("SDP.killListenThread");
        thread.start();
    }
    
    /**
     * Starts a single sniff session between a JVM and a debug client. Returns
     * when the session is closed from either end.
     */
    private void goSniff() {
        canTalkToDebugger = true; // always true for sniffer
        
        // Establish the connection to the VM
        JDWPListener vmSniffer = new JDWPSniffer.JVMSniffer();
        
        if (!connectToVM(this, vmSniffer, "JDWP-Handshake")) {
            return;
        }

        // Establish connection from debugger
        JDWPListener dbSniffer = new JDWPSniffer.JDBSniffer();
        if (!connectToDebugger(this, dbSniffer, "JDWP-Handshake")) {
            vmSniffer.quit();
            dbSniffer.quit();
            return;
        }

        dbSniffer.bindProxyPeer(vmSniffer);

        Thread jvmThread = new Thread(vmSniffer, "JVM-Sniffer");
        Thread jdbThread = new Thread(dbSniffer, "Debugger-Sniffer");

        jvmThread.start();
        jdbThread.start();

        // At this point we have successfully connected the debugger
        // through this proxy to the JVM. We can now sit back and
        // wait for packets to start flowing.
        try {
            jvmThread.join();
            jdbThread.join();
        } catch (InterruptedException ex) {
        }

        if (Log.info()) {
            Log.log("Completed shutdown");
        }
        System.out.println("Sniff session completed.");
        System.out.println();
    }

    /*-----------------------------------------------------------------------*\
     *                            SDPEventManager                            *
    \*-----------------------------------------------------------------------*/

    class MatcherImpl implements EventRequestModifier.Matcher {

        /**
         * {@inheritDoc}
         */
        public boolean matches(ClassMatch modifier, Debugger.Event event) {
            String name = ((ProxyType)event.object).getName();
            boolean result = false;
            switch (modifier.matchKind) {
                case ClassMatch.EQUALS:      result = name.equals(modifier.pattern);        break;
                case ClassMatch.STARTS_WITH: result = name.startsWith(modifier.pattern);    break;
                case ClassMatch.ENDS_WITH:   result = name.endsWith(modifier.pattern);      break;
                case ClassMatch.CONTAINS:    result = name.indexOf(modifier.pattern) != -1; break;
                default: Assert.shouldNotReachHere();
            }
            return modifier.exclude ^ result;
        }

        /**
         * {@inheritDoc}
         */
        public boolean matches(ClassOnly modifier, Debugger.Event event) {
            ProxyType type = (ProxyType)event.object;
            try {
                return ptm.lookup(modifier.clazz, true).getKlass().isAssignableFrom(type.getKlass());
            } catch (SDWPException e) {
                System.err.println("Class ID in ClassOnly modifier is invalid: " + e);
                return false;
            }
        }

        /**
         * {@inheritDoc}
         */
        public boolean matches(ExceptionOnly modifier, Debugger.Event event) {
            return false;
        }

        /**
         * {@inheritDoc}
         */
        public boolean matches(LocationOnly modifier, Debugger.Event event) {
            return false;
        }
    }

    class SDPEventManager extends EventManager {

        /**
         * Event IDs originating from the SDA will be even and events from the SDP will be odd.
         */
        private int nextEventID = 1;

        SDPEventManager(EventRequestModifier.Matcher matcher) {
            super(matcher);
        }
        
        /** 
         * @param id an EventRequest id
         * @retun true if this id is for a proxy handled event.
         */
        public boolean isMyEventRequestID(int id) {
            return (id & 1) == 1;
        }
        
        /**
         * Calculate the next valid proxy Event request id.
         * @return id
         */
        private int getNextEventRequestID() {
            int id = nextEventID += 2;
            Assert.that(isMyEventRequestID(id));
            return id;
        }

        public int registerEventRequest(PacketInputStream in) throws IOException, SDWPException {
            int kind = in.readByte("eventKind");
            EventRequest request;
            
            switch (kind) {
                case JDWP.EventKind_CLASS_PREPARE:
                    /* Treat CLASS_PREPARE events as if they will never happen,
                     * unless the VM supports dynamic class loading. Treat system as if all 
                     * classloading happened before the debugger attached. The debugger needs to be 
                     * able to handle this situation anyway. So the proxy can pass these on to VM, which
                     * can ignore them (Unsupported), or handle if dynamic classloading enabled.
                     */
                case JDWP.EventKind_BREAKPOINT:
                case JDWP.EventKind_SINGLE_STEP:
                case JDWP.EventKind_VM_INIT:
                case JDWP.EventKind_THREAD_START:
                case JDWP.EventKind_THREAD_END:
                case JDWP.EventKind_VM_DEATH:
                case JDWP.EventKind_EXCEPTION:
                    return -1;
                case JDWP.EventKind_FRAME_POP:
                case JDWP.EventKind_USER_DEFINED:
                case JDWP.EventKind_CLASS_UNLOAD:
                case JDWP.EventKind_CLASS_LOAD:
                case JDWP.EventKind_FIELD_ACCESS:
                case JDWP.EventKind_FIELD_MODIFICATION:
                case JDWP.EventKind_EXCEPTION_CATCH:
                case JDWP.EventKind_METHOD_ENTRY:
                case JDWP.EventKind_METHOD_EXIT:
                    request = new Unsupported(getNextEventRequestID(), in, kind);
                    break;
                default:
                    throw new SDWPException(JDWP.Error_INVALID_EVENT_TYPE, "event kind = " + kind);
            }
            // We will ignore suspension for unsupported events, so don't bother with this:
//            if (request.suspendPolicy != JDWP.SuspendPolicy_NONE) {
//                // forget about handling suspension remotely, just send off.
//                return -1;
//            }
            register(request);
            return request.id;
        }

        public void send(Debugger.Event event, MatchedRequests mr) throws IOException, SDWPException {

            Assert.that(mr.suspendPolicy == JDWP.SuspendPolicy_NONE);
//            // do thread suspension:
//            if (mr.suspendPolicy != JDWP.SuspendPolicy_NONE) {
//                Thread thread = event.getThread();
//                suspendThreads(mr.suspendPolicy == JDWP.SuspendPolicy_ALL ? null : thread);
//            }

            CommandPacket command = new CommandPacket(JDWP.Event_COMMAND_SET, JDWP.Event_Composite_COMMAND, false);
            PacketOutputStream out = command.getOutputStream();
            out.writeByte(mr.suspendPolicy, "suspendPolicy");
            out.writeInt(mr.requests.size(), "events");
            for (Enumeration e = mr.requests.elements(); e.hasMoreElements(); ) {
                SDPEventRequest request = (SDPEventRequest)e.nextElement();
                out.writeByte(request.kind, "eventKind");
                out.writeInt(request.id, "requestID");
                request.write(out, event);
                if (Log.info()) {
                    Log.log("Added notification: " + request);
                }
            }

            jdb.sendCommand(command);
        }

    } // SDPEventManager

    abstract class SDPEventRequest extends EventRequest {
        protected SDPEventRequest(int kind, int suspendPolicy) {
            super(kind, suspendPolicy);
        }
        protected SDPEventRequest(int id, PacketInputStream in, int kind) throws SDWPException, IOException {
            super(id, in, kind);
        }
        protected EventRequestModifier readModifier(PacketInputStream in, int kind) throws SDWPException, IOException {
            int modKind = in.readByte("modKind");
            EventRequestModifier modifier;
            switch (modKind) {
                case JDWP.EventRequest_MOD_COUNT:          modifier = new Count(in);                    break;
                case JDWP.EventRequest_MOD_CLASS_ONLY:     modifier = new ClassOnly(in, kind);          break;
                case JDWP.EventRequest_MOD_CLASS_MATCH:    modifier = new ClassMatch(in, kind, false);  break;
                case JDWP.EventRequest_MOD_CLASS_EXCLUDE:  modifier = new ClassMatch(in, kind, true);   break;
                case JDWP.EventRequest_MOD_THREAD_ONLY:    modifier = new ThreadOnly(in, kind);         break;
                default: throw new SDWPException(JDWP.Error_NOT_IMPLEMENTED, "Unimplemented modkind " + modKind);
            }
            return modifier;
        }

        abstract void write(PacketOutputStream out, Debugger.Event event) throws IOException, SDWPException;
    }

    /**
     * This class encapsulates a request for notification of an event kind that is not applicable to Squawk.
     * These events are registered so that a VenetRequest.Set command from a debugger client is
     * successful. It also means that the debugger can later clear the event.
     */
    class Unsupported extends SDPEventRequest {
        Unsupported(int id, PacketInputStream in, int kind) throws SDWPException, IOException {
            super(id, in, kind);
        }
        public void write(PacketOutputStream out, Debugger.Event event) throws IOException {
            Assert.shouldNotReachHere();
        }
        public boolean matchKind(int eventKind) {
            return false;
        }
    }

    public void suspendThreads(Thread thread) {
        try {
            if (thread == null) {

                tpm.suspendAllThreads();
                // Asynchronous command
                CommandPacket command = new CommandPacket(JDWP.VirtualMachine_COMMAND_SET, JDWP.VirtualMachine_Suspend_COMMAND, false);
                sda.sendCommand(command);
            } else {
                ProxyThread pt = (ProxyThread)thread;
                pt.setSuspendCount(pt.getSuspendCount() + 1);

                // Asynchronous command
                CommandPacket command = new CommandPacket(JDWP.ThreadReference_COMMAND_SET, JDWP.ThreadReference_Suspend_COMMAND, false);
                command.getOutputStream().writeObjectID(pt.id, "thread");
                sda.sendCommand(command);
            }
        } catch (IOException e) {
            System.err.println("Error sending suspend command to VM: ");
            e.printStackTrace();
        } catch (Exception e) {
            System.err.println("Error sending suspend command to VM: ");
            e.printStackTrace();
        }
    }
}
